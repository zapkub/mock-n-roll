// Code generated by Prisma (prisma@1.27.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AdsBanner {
  id: ID!
  image: Image
  name: String
  order: Float
  altTag: String
  backgroundColor: String
  url: String
  page: String
  position: String
  publishTimeline: PublishTimeline
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AdsBannerConnection {
  pageInfo: PageInfo!
  edges: [AdsBannerEdge]!
  aggregate: AggregateAdsBanner!
}

input AdsBannerCreateInput {
  image: ImageCreateOneInput
  name: String
  order: Float
  altTag: String
  backgroundColor: String
  url: String
  page: String
  position: String
  publishTimeline: PublishTimelineCreateOneInput
}

type AdsBannerEdge {
  node: AdsBanner!
  cursor: String!
}

enum AdsBannerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  order_ASC
  order_DESC
  altTag_ASC
  altTag_DESC
  backgroundColor_ASC
  backgroundColor_DESC
  url_ASC
  url_DESC
  page_ASC
  page_DESC
  position_ASC
  position_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AdsBannerPreviousValues {
  id: ID!
  name: String
  order: Float
  altTag: String
  backgroundColor: String
  url: String
  page: String
  position: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AdsBannerSubscriptionPayload {
  mutation: MutationType!
  node: AdsBanner
  updatedFields: [String!]
  previousValues: AdsBannerPreviousValues
}

input AdsBannerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AdsBannerWhereInput
  AND: [AdsBannerSubscriptionWhereInput!]
  OR: [AdsBannerSubscriptionWhereInput!]
  NOT: [AdsBannerSubscriptionWhereInput!]
}

input AdsBannerUpdateInput {
  image: ImageUpdateOneInput
  name: String
  order: Float
  altTag: String
  backgroundColor: String
  url: String
  page: String
  position: String
  publishTimeline: PublishTimelineUpdateOneInput
}

input AdsBannerUpdateManyMutationInput {
  name: String
  order: Float
  altTag: String
  backgroundColor: String
  url: String
  page: String
  position: String
}

input AdsBannerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: ImageWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Float
  order_not: Float
  order_in: [Float!]
  order_not_in: [Float!]
  order_lt: Float
  order_lte: Float
  order_gt: Float
  order_gte: Float
  altTag: String
  altTag_not: String
  altTag_in: [String!]
  altTag_not_in: [String!]
  altTag_lt: String
  altTag_lte: String
  altTag_gt: String
  altTag_gte: String
  altTag_contains: String
  altTag_not_contains: String
  altTag_starts_with: String
  altTag_not_starts_with: String
  altTag_ends_with: String
  altTag_not_ends_with: String
  backgroundColor: String
  backgroundColor_not: String
  backgroundColor_in: [String!]
  backgroundColor_not_in: [String!]
  backgroundColor_lt: String
  backgroundColor_lte: String
  backgroundColor_gt: String
  backgroundColor_gte: String
  backgroundColor_contains: String
  backgroundColor_not_contains: String
  backgroundColor_starts_with: String
  backgroundColor_not_starts_with: String
  backgroundColor_ends_with: String
  backgroundColor_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  page: String
  page_not: String
  page_in: [String!]
  page_not_in: [String!]
  page_lt: String
  page_lte: String
  page_gt: String
  page_gte: String
  page_contains: String
  page_not_contains: String
  page_starts_with: String
  page_not_starts_with: String
  page_ends_with: String
  page_not_ends_with: String
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  publishTimeline: PublishTimelineWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AdsBannerWhereInput!]
  OR: [AdsBannerWhereInput!]
  NOT: [AdsBannerWhereInput!]
}

input AdsBannerWhereUniqueInput {
  id: ID
}

type AggregateAdsBanner {
  count: Int!
}

type AggregateAuthor {
  count: Int!
}

type AggregateBehavior {
  count: Int!
}

type AggregateBook {
  count: Int!
}

type AggregateBookEpisode {
  count: Int!
}

type AggregateBookEpisodeContent {
  count: Int!
}

type AggregateBookEpisodeRecentRead {
  count: Int!
}

type AggregateBookEpisodeReviewPost {
  count: Int!
}

type AggregateBookRecommended {
  count: Int!
}

type AggregateBookVolume {
  count: Int!
}

type AggregateCategory {
  count: Int!
}

type AggregateCopyrightHolder {
  count: Int!
}

type AggregateDashbardDataCache {
  count: Int!
}

type AggregateDocument {
  count: Int!
}

type AggregateExchangeTier {
  count: Int!
}

type AggregateExchangeTransaction {
  count: Int!
}

type AggregateExchangeTransactionStatusHistory {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateHistory {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateItemAsset {
  count: Int!
}

type AggregateMigration {
  count: Int!
}

type AggregatePageView {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregatePrice {
  count: Int!
}

type AggregatePromotion {
  count: Int!
}

type AggregatePublishTimeline {
  count: Int!
}

type AggregateRemoteConfig {
  count: Int!
}

type AggregateRevenueSharing {
  count: Int!
}

type AggregateShelf {
  count: Int!
}

type AggregateSystemConfig {
  count: Int!
}

type AggregateTransaction {
  count: Int!
}

type AggregateTranslator {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserAdmin {
  count: Int!
}

type AggregateUserAdminPermission {
  count: Int!
}

type AggregateUserAdminRole {
  count: Int!
}

type AggregateVendor {
  count: Int!
}

type AggregateVendorBillingInformation {
  count: Int!
}

type AggregateVendorRevenue {
  count: Int!
}

type Author {
  id: ID!
  name: String!
  vendor: Vendor
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AuthorConnection {
  pageInfo: PageInfo!
  edges: [AuthorEdge]!
  aggregate: AggregateAuthor!
}

input AuthorCreateInput {
  name: String!
  vendor: VendorCreateOneWithoutAuthorsInput
}

input AuthorCreateManyInput {
  create: [AuthorCreateInput!]
  connect: [AuthorWhereUniqueInput!]
}

input AuthorCreateManyWithoutVendorInput {
  create: [AuthorCreateWithoutVendorInput!]
  connect: [AuthorWhereUniqueInput!]
}

input AuthorCreateWithoutVendorInput {
  name: String!
}

type AuthorEdge {
  node: Author!
  cursor: String!
}

enum AuthorOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AuthorPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AuthorScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AuthorScalarWhereInput!]
  OR: [AuthorScalarWhereInput!]
  NOT: [AuthorScalarWhereInput!]
}

type AuthorSubscriptionPayload {
  mutation: MutationType!
  node: Author
  updatedFields: [String!]
  previousValues: AuthorPreviousValues
}

input AuthorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AuthorWhereInput
  AND: [AuthorSubscriptionWhereInput!]
  OR: [AuthorSubscriptionWhereInput!]
  NOT: [AuthorSubscriptionWhereInput!]
}

input AuthorUpdateDataInput {
  name: String
  vendor: VendorUpdateOneWithoutAuthorsInput
}

input AuthorUpdateInput {
  name: String
  vendor: VendorUpdateOneWithoutAuthorsInput
}

input AuthorUpdateManyDataInput {
  name: String
}

input AuthorUpdateManyInput {
  create: [AuthorCreateInput!]
  update: [AuthorUpdateWithWhereUniqueNestedInput!]
  upsert: [AuthorUpsertWithWhereUniqueNestedInput!]
  delete: [AuthorWhereUniqueInput!]
  connect: [AuthorWhereUniqueInput!]
  set: [AuthorWhereUniqueInput!]
  disconnect: [AuthorWhereUniqueInput!]
  deleteMany: [AuthorScalarWhereInput!]
  updateMany: [AuthorUpdateManyWithWhereNestedInput!]
}

input AuthorUpdateManyMutationInput {
  name: String
}

input AuthorUpdateManyWithoutVendorInput {
  create: [AuthorCreateWithoutVendorInput!]
  delete: [AuthorWhereUniqueInput!]
  connect: [AuthorWhereUniqueInput!]
  set: [AuthorWhereUniqueInput!]
  disconnect: [AuthorWhereUniqueInput!]
  update: [AuthorUpdateWithWhereUniqueWithoutVendorInput!]
  upsert: [AuthorUpsertWithWhereUniqueWithoutVendorInput!]
  deleteMany: [AuthorScalarWhereInput!]
  updateMany: [AuthorUpdateManyWithWhereNestedInput!]
}

input AuthorUpdateManyWithWhereNestedInput {
  where: AuthorScalarWhereInput!
  data: AuthorUpdateManyDataInput!
}

input AuthorUpdateWithoutVendorDataInput {
  name: String
}

input AuthorUpdateWithWhereUniqueNestedInput {
  where: AuthorWhereUniqueInput!
  data: AuthorUpdateDataInput!
}

input AuthorUpdateWithWhereUniqueWithoutVendorInput {
  where: AuthorWhereUniqueInput!
  data: AuthorUpdateWithoutVendorDataInput!
}

input AuthorUpsertWithWhereUniqueNestedInput {
  where: AuthorWhereUniqueInput!
  update: AuthorUpdateDataInput!
  create: AuthorCreateInput!
}

input AuthorUpsertWithWhereUniqueWithoutVendorInput {
  where: AuthorWhereUniqueInput!
  update: AuthorUpdateWithoutVendorDataInput!
  create: AuthorCreateWithoutVendorInput!
}

input AuthorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  vendor: VendorWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AuthorWhereInput!]
  OR: [AuthorWhereInput!]
  NOT: [AuthorWhereInput!]
}

input AuthorWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Behavior {
  id: ID!
  user: User
  ip: String!
  action: String!
  payload: Json!
  createdAt: DateTime!
}

type BehaviorConnection {
  pageInfo: PageInfo!
  edges: [BehaviorEdge]!
  aggregate: AggregateBehavior!
}

input BehaviorCreateInput {
  user: UserCreateOneInput
  ip: String!
  action: String!
  payload: Json!
}

type BehaviorEdge {
  node: Behavior!
  cursor: String!
}

enum BehaviorOrderByInput {
  id_ASC
  id_DESC
  ip_ASC
  ip_DESC
  action_ASC
  action_DESC
  payload_ASC
  payload_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BehaviorPreviousValues {
  id: ID!
  ip: String!
  action: String!
  payload: Json!
  createdAt: DateTime!
}

type BehaviorSubscriptionPayload {
  mutation: MutationType!
  node: Behavior
  updatedFields: [String!]
  previousValues: BehaviorPreviousValues
}

input BehaviorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BehaviorWhereInput
  AND: [BehaviorSubscriptionWhereInput!]
  OR: [BehaviorSubscriptionWhereInput!]
  NOT: [BehaviorSubscriptionWhereInput!]
}

input BehaviorUpdateInput {
  user: UserUpdateOneInput
  ip: String
  action: String
  payload: Json
}

input BehaviorUpdateManyMutationInput {
  ip: String
  action: String
  payload: Json
}

input BehaviorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  ip: String
  ip_not: String
  ip_in: [String!]
  ip_not_in: [String!]
  ip_lt: String
  ip_lte: String
  ip_gt: String
  ip_gte: String
  ip_contains: String
  ip_not_contains: String
  ip_starts_with: String
  ip_not_starts_with: String
  ip_ends_with: String
  ip_not_ends_with: String
  action: String
  action_not: String
  action_in: [String!]
  action_not_in: [String!]
  action_lt: String
  action_lte: String
  action_gt: String
  action_gte: String
  action_contains: String
  action_not_contains: String
  action_starts_with: String
  action_not_starts_with: String
  action_ends_with: String
  action_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [BehaviorWhereInput!]
  OR: [BehaviorWhereInput!]
  NOT: [BehaviorWhereInput!]
}

input BehaviorWhereUniqueInput {
  id: ID
}

type Book {
  id: ID!
  slug: String
  name: String!
  introduction: Json!
  synopsis: String
  thumbnail: Image
  copyrightHolder: CopyrightHolder
  authors(where: AuthorWhereInput, orderBy: AuthorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Author!]
  mainCategory: Category
  secondaryCategory: Category
  translators(where: TranslatorWhereInput, orderBy: TranslatorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Translator!]
  volumes(where: BookVolumeWhereInput, orderBy: BookVolumeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookVolume!]
  isPublished: Boolean!
  publishedAt: DateTime
  publishTimeline: PublishTimeline
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookConnection {
  pageInfo: PageInfo!
  edges: [BookEdge]!
  aggregate: AggregateBook!
}

input BookCreateInput {
  slug: String
  name: String!
  introduction: Json!
  synopsis: String
  thumbnail: ImageCreateOneInput
  copyrightHolder: CopyrightHolderCreateOneInput
  authors: AuthorCreateManyInput
  mainCategory: CategoryCreateOneInput
  secondaryCategory: CategoryCreateOneInput
  translators: TranslatorCreateManyInput
  volumes: BookVolumeCreateManyWithoutBookInput
  isPublished: Boolean
  publishedAt: DateTime
  publishTimeline: PublishTimelineCreateOneInput
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookCreateOneInput {
  create: BookCreateInput
  connect: BookWhereUniqueInput
}

input BookCreateOneWithoutVolumesInput {
  create: BookCreateWithoutVolumesInput
  connect: BookWhereUniqueInput
}

input BookCreateWithoutVolumesInput {
  slug: String
  name: String!
  introduction: Json!
  synopsis: String
  thumbnail: ImageCreateOneInput
  copyrightHolder: CopyrightHolderCreateOneInput
  authors: AuthorCreateManyInput
  mainCategory: CategoryCreateOneInput
  secondaryCategory: CategoryCreateOneInput
  translators: TranslatorCreateManyInput
  isPublished: Boolean
  publishedAt: DateTime
  publishTimeline: PublishTimelineCreateOneInput
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

type BookEdge {
  node: Book!
  cursor: String!
}

type BookEpisode {
  id: ID!
  slug: String
  authors(where: AuthorWhereInput, orderBy: AuthorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Author!]
  translators(where: TranslatorWhereInput, orderBy: TranslatorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Translator!]
  prices(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price!]
  priceHistory(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price!]
  publishContent: BookEpisodeContent
  draftContent: BookEpisodeContent
  revisionContents(where: BookEpisodeContentWhereInput, orderBy: BookEpisodeContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookEpisodeContent!]
  volume: BookVolume!
  isPublished: Boolean!
  publishedAt: DateTime
  vendor: Vendor
  publishTimeline: PublishTimeline
  isUnlisted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  pageView: PageView
  reviews(where: BookEpisodeReviewPostWhereInput, orderBy: BookEpisodeReviewPostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookEpisodeReviewPost!]
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

type BookEpisodeConnection {
  pageInfo: PageInfo!
  edges: [BookEpisodeEdge]!
  aggregate: AggregateBookEpisode!
}

type BookEpisodeContent {
  id: ID!
  title: String!
  draft: Json
}

type BookEpisodeContentConnection {
  pageInfo: PageInfo!
  edges: [BookEpisodeContentEdge]!
  aggregate: AggregateBookEpisodeContent!
}

input BookEpisodeContentCreateInput {
  title: String!
  draft: Json
}

input BookEpisodeContentCreateManyInput {
  create: [BookEpisodeContentCreateInput!]
  connect: [BookEpisodeContentWhereUniqueInput!]
}

input BookEpisodeContentCreateOneInput {
  create: BookEpisodeContentCreateInput
  connect: BookEpisodeContentWhereUniqueInput
}

type BookEpisodeContentEdge {
  node: BookEpisodeContent!
  cursor: String!
}

enum BookEpisodeContentOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  draft_ASC
  draft_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BookEpisodeContentPreviousValues {
  id: ID!
  title: String!
  draft: Json
}

input BookEpisodeContentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [BookEpisodeContentScalarWhereInput!]
  OR: [BookEpisodeContentScalarWhereInput!]
  NOT: [BookEpisodeContentScalarWhereInput!]
}

type BookEpisodeContentSubscriptionPayload {
  mutation: MutationType!
  node: BookEpisodeContent
  updatedFields: [String!]
  previousValues: BookEpisodeContentPreviousValues
}

input BookEpisodeContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookEpisodeContentWhereInput
  AND: [BookEpisodeContentSubscriptionWhereInput!]
  OR: [BookEpisodeContentSubscriptionWhereInput!]
  NOT: [BookEpisodeContentSubscriptionWhereInput!]
}

input BookEpisodeContentUpdateDataInput {
  title: String
  draft: Json
}

input BookEpisodeContentUpdateInput {
  title: String
  draft: Json
}

input BookEpisodeContentUpdateManyDataInput {
  title: String
  draft: Json
}

input BookEpisodeContentUpdateManyInput {
  create: [BookEpisodeContentCreateInput!]
  update: [BookEpisodeContentUpdateWithWhereUniqueNestedInput!]
  upsert: [BookEpisodeContentUpsertWithWhereUniqueNestedInput!]
  delete: [BookEpisodeContentWhereUniqueInput!]
  connect: [BookEpisodeContentWhereUniqueInput!]
  set: [BookEpisodeContentWhereUniqueInput!]
  disconnect: [BookEpisodeContentWhereUniqueInput!]
  deleteMany: [BookEpisodeContentScalarWhereInput!]
  updateMany: [BookEpisodeContentUpdateManyWithWhereNestedInput!]
}

input BookEpisodeContentUpdateManyMutationInput {
  title: String
  draft: Json
}

input BookEpisodeContentUpdateManyWithWhereNestedInput {
  where: BookEpisodeContentScalarWhereInput!
  data: BookEpisodeContentUpdateManyDataInput!
}

input BookEpisodeContentUpdateOneInput {
  create: BookEpisodeContentCreateInput
  update: BookEpisodeContentUpdateDataInput
  upsert: BookEpisodeContentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BookEpisodeContentWhereUniqueInput
}

input BookEpisodeContentUpdateWithWhereUniqueNestedInput {
  where: BookEpisodeContentWhereUniqueInput!
  data: BookEpisodeContentUpdateDataInput!
}

input BookEpisodeContentUpsertNestedInput {
  update: BookEpisodeContentUpdateDataInput!
  create: BookEpisodeContentCreateInput!
}

input BookEpisodeContentUpsertWithWhereUniqueNestedInput {
  where: BookEpisodeContentWhereUniqueInput!
  update: BookEpisodeContentUpdateDataInput!
  create: BookEpisodeContentCreateInput!
}

input BookEpisodeContentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [BookEpisodeContentWhereInput!]
  OR: [BookEpisodeContentWhereInput!]
  NOT: [BookEpisodeContentWhereInput!]
}

input BookEpisodeContentWhereUniqueInput {
  id: ID
}

input BookEpisodeCreateInput {
  slug: String
  authors: AuthorCreateManyInput
  translators: TranslatorCreateManyInput
  prices: PriceCreateManyInput
  priceHistory: PriceCreateManyInput
  publishContent: BookEpisodeContentCreateOneInput
  draftContent: BookEpisodeContentCreateOneInput
  revisionContents: BookEpisodeContentCreateManyInput
  volume: BookVolumeCreateOneWithoutEpisodesInput!
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorCreateOneInput
  publishTimeline: PublishTimelineCreateOneInput
  isUnlisted: Boolean
  pageView: PageViewCreateOneWithoutEpisodeInput
  reviews: BookEpisodeReviewPostCreateManyWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeCreateManyWithoutVolumeInput {
  create: [BookEpisodeCreateWithoutVolumeInput!]
  connect: [BookEpisodeWhereUniqueInput!]
}

input BookEpisodeCreateOneInput {
  create: BookEpisodeCreateInput
  connect: BookEpisodeWhereUniqueInput
}

input BookEpisodeCreateOneWithoutPageViewInput {
  create: BookEpisodeCreateWithoutPageViewInput
  connect: BookEpisodeWhereUniqueInput
}

input BookEpisodeCreateOneWithoutReviewsInput {
  create: BookEpisodeCreateWithoutReviewsInput
  connect: BookEpisodeWhereUniqueInput
}

input BookEpisodeCreateWithoutPageViewInput {
  slug: String
  authors: AuthorCreateManyInput
  translators: TranslatorCreateManyInput
  prices: PriceCreateManyInput
  priceHistory: PriceCreateManyInput
  publishContent: BookEpisodeContentCreateOneInput
  draftContent: BookEpisodeContentCreateOneInput
  revisionContents: BookEpisodeContentCreateManyInput
  volume: BookVolumeCreateOneWithoutEpisodesInput!
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorCreateOneInput
  publishTimeline: PublishTimelineCreateOneInput
  isUnlisted: Boolean
  reviews: BookEpisodeReviewPostCreateManyWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeCreateWithoutReviewsInput {
  slug: String
  authors: AuthorCreateManyInput
  translators: TranslatorCreateManyInput
  prices: PriceCreateManyInput
  priceHistory: PriceCreateManyInput
  publishContent: BookEpisodeContentCreateOneInput
  draftContent: BookEpisodeContentCreateOneInput
  revisionContents: BookEpisodeContentCreateManyInput
  volume: BookVolumeCreateOneWithoutEpisodesInput!
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorCreateOneInput
  publishTimeline: PublishTimelineCreateOneInput
  isUnlisted: Boolean
  pageView: PageViewCreateOneWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeCreateWithoutVolumeInput {
  slug: String
  authors: AuthorCreateManyInput
  translators: TranslatorCreateManyInput
  prices: PriceCreateManyInput
  priceHistory: PriceCreateManyInput
  publishContent: BookEpisodeContentCreateOneInput
  draftContent: BookEpisodeContentCreateOneInput
  revisionContents: BookEpisodeContentCreateManyInput
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorCreateOneInput
  publishTimeline: PublishTimelineCreateOneInput
  isUnlisted: Boolean
  pageView: PageViewCreateOneWithoutEpisodeInput
  reviews: BookEpisodeReviewPostCreateManyWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

type BookEpisodeEdge {
  node: BookEpisode!
  cursor: String!
}

enum BookEpisodeOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  isPublished_ASC
  isPublished_DESC
  publishedAt_ASC
  publishedAt_DESC
  isUnlisted_ASC
  isUnlisted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  metaTitle_ASC
  metaTitle_DESC
  metaDescription_ASC
  metaDescription_DESC
  metaKeyword_ASC
  metaKeyword_DESC
}

type BookEpisodePreviousValues {
  id: ID!
  slug: String
  isPublished: Boolean!
  publishedAt: DateTime
  isUnlisted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

type BookEpisodeRecentRead {
  id: ID!
  user: User!
  episode: BookEpisode!
  offsetKey: String!
  offsetRatio: Float!
}

type BookEpisodeRecentReadConnection {
  pageInfo: PageInfo!
  edges: [BookEpisodeRecentReadEdge]!
  aggregate: AggregateBookEpisodeRecentRead!
}

input BookEpisodeRecentReadCreateInput {
  user: UserCreateOneInput!
  episode: BookEpisodeCreateOneInput!
  offsetKey: String!
  offsetRatio: Float!
}

type BookEpisodeRecentReadEdge {
  node: BookEpisodeRecentRead!
  cursor: String!
}

enum BookEpisodeRecentReadOrderByInput {
  id_ASC
  id_DESC
  offsetKey_ASC
  offsetKey_DESC
  offsetRatio_ASC
  offsetRatio_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BookEpisodeRecentReadPreviousValues {
  id: ID!
  offsetKey: String!
  offsetRatio: Float!
}

type BookEpisodeRecentReadSubscriptionPayload {
  mutation: MutationType!
  node: BookEpisodeRecentRead
  updatedFields: [String!]
  previousValues: BookEpisodeRecentReadPreviousValues
}

input BookEpisodeRecentReadSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookEpisodeRecentReadWhereInput
  AND: [BookEpisodeRecentReadSubscriptionWhereInput!]
  OR: [BookEpisodeRecentReadSubscriptionWhereInput!]
  NOT: [BookEpisodeRecentReadSubscriptionWhereInput!]
}

input BookEpisodeRecentReadUpdateInput {
  user: UserUpdateOneRequiredInput
  episode: BookEpisodeUpdateOneRequiredInput
  offsetKey: String
  offsetRatio: Float
}

input BookEpisodeRecentReadUpdateManyMutationInput {
  offsetKey: String
  offsetRatio: Float
}

input BookEpisodeRecentReadWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  episode: BookEpisodeWhereInput
  offsetKey: String
  offsetKey_not: String
  offsetKey_in: [String!]
  offsetKey_not_in: [String!]
  offsetKey_lt: String
  offsetKey_lte: String
  offsetKey_gt: String
  offsetKey_gte: String
  offsetKey_contains: String
  offsetKey_not_contains: String
  offsetKey_starts_with: String
  offsetKey_not_starts_with: String
  offsetKey_ends_with: String
  offsetKey_not_ends_with: String
  offsetRatio: Float
  offsetRatio_not: Float
  offsetRatio_in: [Float!]
  offsetRatio_not_in: [Float!]
  offsetRatio_lt: Float
  offsetRatio_lte: Float
  offsetRatio_gt: Float
  offsetRatio_gte: Float
  AND: [BookEpisodeRecentReadWhereInput!]
  OR: [BookEpisodeRecentReadWhereInput!]
  NOT: [BookEpisodeRecentReadWhereInput!]
}

input BookEpisodeRecentReadWhereUniqueInput {
  id: ID
}

type BookEpisodeReviewPost {
  id: ID!
  episode: BookEpisode!
  rating: Int!
  post: Post!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookEpisodeReviewPostConnection {
  pageInfo: PageInfo!
  edges: [BookEpisodeReviewPostEdge]!
  aggregate: AggregateBookEpisodeReviewPost!
}

input BookEpisodeReviewPostCreateInput {
  episode: BookEpisodeCreateOneWithoutReviewsInput!
  rating: Int!
  post: PostCreateOneInput!
}

input BookEpisodeReviewPostCreateManyWithoutEpisodeInput {
  create: [BookEpisodeReviewPostCreateWithoutEpisodeInput!]
  connect: [BookEpisodeReviewPostWhereUniqueInput!]
}

input BookEpisodeReviewPostCreateWithoutEpisodeInput {
  rating: Int!
  post: PostCreateOneInput!
}

type BookEpisodeReviewPostEdge {
  node: BookEpisodeReviewPost!
  cursor: String!
}

enum BookEpisodeReviewPostOrderByInput {
  id_ASC
  id_DESC
  rating_ASC
  rating_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BookEpisodeReviewPostPreviousValues {
  id: ID!
  rating: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input BookEpisodeReviewPostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BookEpisodeReviewPostScalarWhereInput!]
  OR: [BookEpisodeReviewPostScalarWhereInput!]
  NOT: [BookEpisodeReviewPostScalarWhereInput!]
}

type BookEpisodeReviewPostSubscriptionPayload {
  mutation: MutationType!
  node: BookEpisodeReviewPost
  updatedFields: [String!]
  previousValues: BookEpisodeReviewPostPreviousValues
}

input BookEpisodeReviewPostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookEpisodeReviewPostWhereInput
  AND: [BookEpisodeReviewPostSubscriptionWhereInput!]
  OR: [BookEpisodeReviewPostSubscriptionWhereInput!]
  NOT: [BookEpisodeReviewPostSubscriptionWhereInput!]
}

input BookEpisodeReviewPostUpdateInput {
  episode: BookEpisodeUpdateOneRequiredWithoutReviewsInput
  rating: Int
  post: PostUpdateOneRequiredInput
}

input BookEpisodeReviewPostUpdateManyDataInput {
  rating: Int
}

input BookEpisodeReviewPostUpdateManyMutationInput {
  rating: Int
}

input BookEpisodeReviewPostUpdateManyWithoutEpisodeInput {
  create: [BookEpisodeReviewPostCreateWithoutEpisodeInput!]
  delete: [BookEpisodeReviewPostWhereUniqueInput!]
  connect: [BookEpisodeReviewPostWhereUniqueInput!]
  set: [BookEpisodeReviewPostWhereUniqueInput!]
  disconnect: [BookEpisodeReviewPostWhereUniqueInput!]
  update: [BookEpisodeReviewPostUpdateWithWhereUniqueWithoutEpisodeInput!]
  upsert: [BookEpisodeReviewPostUpsertWithWhereUniqueWithoutEpisodeInput!]
  deleteMany: [BookEpisodeReviewPostScalarWhereInput!]
  updateMany: [BookEpisodeReviewPostUpdateManyWithWhereNestedInput!]
}

input BookEpisodeReviewPostUpdateManyWithWhereNestedInput {
  where: BookEpisodeReviewPostScalarWhereInput!
  data: BookEpisodeReviewPostUpdateManyDataInput!
}

input BookEpisodeReviewPostUpdateWithoutEpisodeDataInput {
  rating: Int
  post: PostUpdateOneRequiredInput
}

input BookEpisodeReviewPostUpdateWithWhereUniqueWithoutEpisodeInput {
  where: BookEpisodeReviewPostWhereUniqueInput!
  data: BookEpisodeReviewPostUpdateWithoutEpisodeDataInput!
}

input BookEpisodeReviewPostUpsertWithWhereUniqueWithoutEpisodeInput {
  where: BookEpisodeReviewPostWhereUniqueInput!
  update: BookEpisodeReviewPostUpdateWithoutEpisodeDataInput!
  create: BookEpisodeReviewPostCreateWithoutEpisodeInput!
}

input BookEpisodeReviewPostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  episode: BookEpisodeWhereInput
  rating: Int
  rating_not: Int
  rating_in: [Int!]
  rating_not_in: [Int!]
  rating_lt: Int
  rating_lte: Int
  rating_gt: Int
  rating_gte: Int
  post: PostWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BookEpisodeReviewPostWhereInput!]
  OR: [BookEpisodeReviewPostWhereInput!]
  NOT: [BookEpisodeReviewPostWhereInput!]
}

input BookEpisodeReviewPostWhereUniqueInput {
  id: ID
}

input BookEpisodeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  isUnlisted: Boolean
  isUnlisted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  metaKeyword: String
  metaKeyword_not: String
  metaKeyword_in: [String!]
  metaKeyword_not_in: [String!]
  metaKeyword_lt: String
  metaKeyword_lte: String
  metaKeyword_gt: String
  metaKeyword_gte: String
  metaKeyword_contains: String
  metaKeyword_not_contains: String
  metaKeyword_starts_with: String
  metaKeyword_not_starts_with: String
  metaKeyword_ends_with: String
  metaKeyword_not_ends_with: String
  AND: [BookEpisodeScalarWhereInput!]
  OR: [BookEpisodeScalarWhereInput!]
  NOT: [BookEpisodeScalarWhereInput!]
}

type BookEpisodeSubscriptionPayload {
  mutation: MutationType!
  node: BookEpisode
  updatedFields: [String!]
  previousValues: BookEpisodePreviousValues
}

input BookEpisodeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookEpisodeWhereInput
  AND: [BookEpisodeSubscriptionWhereInput!]
  OR: [BookEpisodeSubscriptionWhereInput!]
  NOT: [BookEpisodeSubscriptionWhereInput!]
}

input BookEpisodeUpdateDataInput {
  slug: String
  authors: AuthorUpdateManyInput
  translators: TranslatorUpdateManyInput
  prices: PriceUpdateManyInput
  priceHistory: PriceUpdateManyInput
  publishContent: BookEpisodeContentUpdateOneInput
  draftContent: BookEpisodeContentUpdateOneInput
  revisionContents: BookEpisodeContentUpdateManyInput
  volume: BookVolumeUpdateOneRequiredWithoutEpisodesInput
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorUpdateOneInput
  publishTimeline: PublishTimelineUpdateOneInput
  isUnlisted: Boolean
  pageView: PageViewUpdateOneWithoutEpisodeInput
  reviews: BookEpisodeReviewPostUpdateManyWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeUpdateInput {
  slug: String
  authors: AuthorUpdateManyInput
  translators: TranslatorUpdateManyInput
  prices: PriceUpdateManyInput
  priceHistory: PriceUpdateManyInput
  publishContent: BookEpisodeContentUpdateOneInput
  draftContent: BookEpisodeContentUpdateOneInput
  revisionContents: BookEpisodeContentUpdateManyInput
  volume: BookVolumeUpdateOneRequiredWithoutEpisodesInput
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorUpdateOneInput
  publishTimeline: PublishTimelineUpdateOneInput
  isUnlisted: Boolean
  pageView: PageViewUpdateOneWithoutEpisodeInput
  reviews: BookEpisodeReviewPostUpdateManyWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeUpdateManyDataInput {
  slug: String
  isPublished: Boolean
  publishedAt: DateTime
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeUpdateManyMutationInput {
  slug: String
  isPublished: Boolean
  publishedAt: DateTime
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeUpdateManyWithoutVolumeInput {
  create: [BookEpisodeCreateWithoutVolumeInput!]
  delete: [BookEpisodeWhereUniqueInput!]
  connect: [BookEpisodeWhereUniqueInput!]
  set: [BookEpisodeWhereUniqueInput!]
  disconnect: [BookEpisodeWhereUniqueInput!]
  update: [BookEpisodeUpdateWithWhereUniqueWithoutVolumeInput!]
  upsert: [BookEpisodeUpsertWithWhereUniqueWithoutVolumeInput!]
  deleteMany: [BookEpisodeScalarWhereInput!]
  updateMany: [BookEpisodeUpdateManyWithWhereNestedInput!]
}

input BookEpisodeUpdateManyWithWhereNestedInput {
  where: BookEpisodeScalarWhereInput!
  data: BookEpisodeUpdateManyDataInput!
}

input BookEpisodeUpdateOneRequiredInput {
  create: BookEpisodeCreateInput
  update: BookEpisodeUpdateDataInput
  upsert: BookEpisodeUpsertNestedInput
  connect: BookEpisodeWhereUniqueInput
}

input BookEpisodeUpdateOneRequiredWithoutPageViewInput {
  create: BookEpisodeCreateWithoutPageViewInput
  update: BookEpisodeUpdateWithoutPageViewDataInput
  upsert: BookEpisodeUpsertWithoutPageViewInput
  connect: BookEpisodeWhereUniqueInput
}

input BookEpisodeUpdateOneRequiredWithoutReviewsInput {
  create: BookEpisodeCreateWithoutReviewsInput
  update: BookEpisodeUpdateWithoutReviewsDataInput
  upsert: BookEpisodeUpsertWithoutReviewsInput
  connect: BookEpisodeWhereUniqueInput
}

input BookEpisodeUpdateWithoutPageViewDataInput {
  slug: String
  authors: AuthorUpdateManyInput
  translators: TranslatorUpdateManyInput
  prices: PriceUpdateManyInput
  priceHistory: PriceUpdateManyInput
  publishContent: BookEpisodeContentUpdateOneInput
  draftContent: BookEpisodeContentUpdateOneInput
  revisionContents: BookEpisodeContentUpdateManyInput
  volume: BookVolumeUpdateOneRequiredWithoutEpisodesInput
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorUpdateOneInput
  publishTimeline: PublishTimelineUpdateOneInput
  isUnlisted: Boolean
  reviews: BookEpisodeReviewPostUpdateManyWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeUpdateWithoutReviewsDataInput {
  slug: String
  authors: AuthorUpdateManyInput
  translators: TranslatorUpdateManyInput
  prices: PriceUpdateManyInput
  priceHistory: PriceUpdateManyInput
  publishContent: BookEpisodeContentUpdateOneInput
  draftContent: BookEpisodeContentUpdateOneInput
  revisionContents: BookEpisodeContentUpdateManyInput
  volume: BookVolumeUpdateOneRequiredWithoutEpisodesInput
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorUpdateOneInput
  publishTimeline: PublishTimelineUpdateOneInput
  isUnlisted: Boolean
  pageView: PageViewUpdateOneWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeUpdateWithoutVolumeDataInput {
  slug: String
  authors: AuthorUpdateManyInput
  translators: TranslatorUpdateManyInput
  prices: PriceUpdateManyInput
  priceHistory: PriceUpdateManyInput
  publishContent: BookEpisodeContentUpdateOneInput
  draftContent: BookEpisodeContentUpdateOneInput
  revisionContents: BookEpisodeContentUpdateManyInput
  isPublished: Boolean
  publishedAt: DateTime
  vendor: VendorUpdateOneInput
  publishTimeline: PublishTimelineUpdateOneInput
  isUnlisted: Boolean
  pageView: PageViewUpdateOneWithoutEpisodeInput
  reviews: BookEpisodeReviewPostUpdateManyWithoutEpisodeInput
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookEpisodeUpdateWithWhereUniqueWithoutVolumeInput {
  where: BookEpisodeWhereUniqueInput!
  data: BookEpisodeUpdateWithoutVolumeDataInput!
}

input BookEpisodeUpsertNestedInput {
  update: BookEpisodeUpdateDataInput!
  create: BookEpisodeCreateInput!
}

input BookEpisodeUpsertWithoutPageViewInput {
  update: BookEpisodeUpdateWithoutPageViewDataInput!
  create: BookEpisodeCreateWithoutPageViewInput!
}

input BookEpisodeUpsertWithoutReviewsInput {
  update: BookEpisodeUpdateWithoutReviewsDataInput!
  create: BookEpisodeCreateWithoutReviewsInput!
}

input BookEpisodeUpsertWithWhereUniqueWithoutVolumeInput {
  where: BookEpisodeWhereUniqueInput!
  update: BookEpisodeUpdateWithoutVolumeDataInput!
  create: BookEpisodeCreateWithoutVolumeInput!
}

input BookEpisodeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  authors_every: AuthorWhereInput
  authors_some: AuthorWhereInput
  authors_none: AuthorWhereInput
  translators_every: TranslatorWhereInput
  translators_some: TranslatorWhereInput
  translators_none: TranslatorWhereInput
  prices_every: PriceWhereInput
  prices_some: PriceWhereInput
  prices_none: PriceWhereInput
  priceHistory_every: PriceWhereInput
  priceHistory_some: PriceWhereInput
  priceHistory_none: PriceWhereInput
  publishContent: BookEpisodeContentWhereInput
  draftContent: BookEpisodeContentWhereInput
  revisionContents_every: BookEpisodeContentWhereInput
  revisionContents_some: BookEpisodeContentWhereInput
  revisionContents_none: BookEpisodeContentWhereInput
  volume: BookVolumeWhereInput
  isPublished: Boolean
  isPublished_not: Boolean
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  vendor: VendorWhereInput
  publishTimeline: PublishTimelineWhereInput
  isUnlisted: Boolean
  isUnlisted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  pageView: PageViewWhereInput
  reviews_every: BookEpisodeReviewPostWhereInput
  reviews_some: BookEpisodeReviewPostWhereInput
  reviews_none: BookEpisodeReviewPostWhereInput
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  metaKeyword: String
  metaKeyword_not: String
  metaKeyword_in: [String!]
  metaKeyword_not_in: [String!]
  metaKeyword_lt: String
  metaKeyword_lte: String
  metaKeyword_gt: String
  metaKeyword_gte: String
  metaKeyword_contains: String
  metaKeyword_not_contains: String
  metaKeyword_starts_with: String
  metaKeyword_not_starts_with: String
  metaKeyword_ends_with: String
  metaKeyword_not_ends_with: String
  AND: [BookEpisodeWhereInput!]
  OR: [BookEpisodeWhereInput!]
  NOT: [BookEpisodeWhereInput!]
}

input BookEpisodeWhereUniqueInput {
  id: ID
}

enum BookOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  name_ASC
  name_DESC
  introduction_ASC
  introduction_DESC
  synopsis_ASC
  synopsis_DESC
  isPublished_ASC
  isPublished_DESC
  publishedAt_ASC
  publishedAt_DESC
  isUnlisted_ASC
  isUnlisted_DESC
  metaTitle_ASC
  metaTitle_DESC
  metaDescription_ASC
  metaDescription_DESC
  metaKeyword_ASC
  metaKeyword_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BookPreviousValues {
  id: ID!
  slug: String
  name: String!
  introduction: Json!
  synopsis: String
  isPublished: Boolean!
  publishedAt: DateTime
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookRecommended {
  id: ID!
  book: Book!
  weight: Int!
  publishTimeline: PublishTimeline
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookRecommendedConnection {
  pageInfo: PageInfo!
  edges: [BookRecommendedEdge]!
  aggregate: AggregateBookRecommended!
}

input BookRecommendedCreateInput {
  book: BookCreateOneInput!
  weight: Int!
  publishTimeline: PublishTimelineCreateOneInput
}

type BookRecommendedEdge {
  node: BookRecommended!
  cursor: String!
}

enum BookRecommendedOrderByInput {
  id_ASC
  id_DESC
  weight_ASC
  weight_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BookRecommendedPreviousValues {
  id: ID!
  weight: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookRecommendedSubscriptionPayload {
  mutation: MutationType!
  node: BookRecommended
  updatedFields: [String!]
  previousValues: BookRecommendedPreviousValues
}

input BookRecommendedSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookRecommendedWhereInput
  AND: [BookRecommendedSubscriptionWhereInput!]
  OR: [BookRecommendedSubscriptionWhereInput!]
  NOT: [BookRecommendedSubscriptionWhereInput!]
}

input BookRecommendedUpdateInput {
  book: BookUpdateOneRequiredInput
  weight: Int
  publishTimeline: PublishTimelineUpdateOneInput
}

input BookRecommendedUpdateManyMutationInput {
  weight: Int
}

input BookRecommendedWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  book: BookWhereInput
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  publishTimeline: PublishTimelineWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BookRecommendedWhereInput!]
  OR: [BookRecommendedWhereInput!]
  NOT: [BookRecommendedWhereInput!]
}

input BookRecommendedWhereUniqueInput {
  id: ID
}

type BookSubscriptionPayload {
  mutation: MutationType!
  node: Book
  updatedFields: [String!]
  previousValues: BookPreviousValues
}

input BookSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookWhereInput
  AND: [BookSubscriptionWhereInput!]
  OR: [BookSubscriptionWhereInput!]
  NOT: [BookSubscriptionWhereInput!]
}

input BookUpdateDataInput {
  slug: String
  name: String
  introduction: Json
  synopsis: String
  thumbnail: ImageUpdateOneInput
  copyrightHolder: CopyrightHolderUpdateOneInput
  authors: AuthorUpdateManyInput
  mainCategory: CategoryUpdateOneInput
  secondaryCategory: CategoryUpdateOneInput
  translators: TranslatorUpdateManyInput
  volumes: BookVolumeUpdateManyWithoutBookInput
  isPublished: Boolean
  publishedAt: DateTime
  publishTimeline: PublishTimelineUpdateOneInput
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookUpdateInput {
  slug: String
  name: String
  introduction: Json
  synopsis: String
  thumbnail: ImageUpdateOneInput
  copyrightHolder: CopyrightHolderUpdateOneInput
  authors: AuthorUpdateManyInput
  mainCategory: CategoryUpdateOneInput
  secondaryCategory: CategoryUpdateOneInput
  translators: TranslatorUpdateManyInput
  volumes: BookVolumeUpdateManyWithoutBookInput
  isPublished: Boolean
  publishedAt: DateTime
  publishTimeline: PublishTimelineUpdateOneInput
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookUpdateManyMutationInput {
  slug: String
  name: String
  introduction: Json
  synopsis: String
  isPublished: Boolean
  publishedAt: DateTime
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookUpdateOneInput {
  create: BookCreateInput
  update: BookUpdateDataInput
  upsert: BookUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BookWhereUniqueInput
}

input BookUpdateOneRequiredInput {
  create: BookCreateInput
  update: BookUpdateDataInput
  upsert: BookUpsertNestedInput
  connect: BookWhereUniqueInput
}

input BookUpdateOneRequiredWithoutVolumesInput {
  create: BookCreateWithoutVolumesInput
  update: BookUpdateWithoutVolumesDataInput
  upsert: BookUpsertWithoutVolumesInput
  connect: BookWhereUniqueInput
}

input BookUpdateWithoutVolumesDataInput {
  slug: String
  name: String
  introduction: Json
  synopsis: String
  thumbnail: ImageUpdateOneInput
  copyrightHolder: CopyrightHolderUpdateOneInput
  authors: AuthorUpdateManyInput
  mainCategory: CategoryUpdateOneInput
  secondaryCategory: CategoryUpdateOneInput
  translators: TranslatorUpdateManyInput
  isPublished: Boolean
  publishedAt: DateTime
  publishTimeline: PublishTimelineUpdateOneInput
  isUnlisted: Boolean
  metaTitle: String
  metaDescription: String
  metaKeyword: String
}

input BookUpsertNestedInput {
  update: BookUpdateDataInput!
  create: BookCreateInput!
}

input BookUpsertWithoutVolumesInput {
  update: BookUpdateWithoutVolumesDataInput!
  create: BookCreateWithoutVolumesInput!
}

type BookVolume {
  id: ID!
  slug: String
  title: String!
  book: Book!
  episodes(where: BookEpisodeWhereInput, orderBy: BookEpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookEpisode!]
  isPublished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookVolumeConnection {
  pageInfo: PageInfo!
  edges: [BookVolumeEdge]!
  aggregate: AggregateBookVolume!
}

input BookVolumeCreateInput {
  slug: String
  title: String!
  book: BookCreateOneWithoutVolumesInput!
  episodes: BookEpisodeCreateManyWithoutVolumeInput
  isPublished: Boolean
}

input BookVolumeCreateManyWithoutBookInput {
  create: [BookVolumeCreateWithoutBookInput!]
  connect: [BookVolumeWhereUniqueInput!]
}

input BookVolumeCreateOneWithoutEpisodesInput {
  create: BookVolumeCreateWithoutEpisodesInput
  connect: BookVolumeWhereUniqueInput
}

input BookVolumeCreateWithoutBookInput {
  slug: String
  title: String!
  episodes: BookEpisodeCreateManyWithoutVolumeInput
  isPublished: Boolean
}

input BookVolumeCreateWithoutEpisodesInput {
  slug: String
  title: String!
  book: BookCreateOneWithoutVolumesInput!
  isPublished: Boolean
}

type BookVolumeEdge {
  node: BookVolume!
  cursor: String!
}

enum BookVolumeOrderByInput {
  id_ASC
  id_DESC
  slug_ASC
  slug_DESC
  title_ASC
  title_DESC
  isPublished_ASC
  isPublished_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BookVolumePreviousValues {
  id: ID!
  slug: String
  title: String!
  isPublished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input BookVolumeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  isPublished: Boolean
  isPublished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BookVolumeScalarWhereInput!]
  OR: [BookVolumeScalarWhereInput!]
  NOT: [BookVolumeScalarWhereInput!]
}

type BookVolumeSubscriptionPayload {
  mutation: MutationType!
  node: BookVolume
  updatedFields: [String!]
  previousValues: BookVolumePreviousValues
}

input BookVolumeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookVolumeWhereInput
  AND: [BookVolumeSubscriptionWhereInput!]
  OR: [BookVolumeSubscriptionWhereInput!]
  NOT: [BookVolumeSubscriptionWhereInput!]
}

input BookVolumeUpdateInput {
  slug: String
  title: String
  book: BookUpdateOneRequiredWithoutVolumesInput
  episodes: BookEpisodeUpdateManyWithoutVolumeInput
  isPublished: Boolean
}

input BookVolumeUpdateManyDataInput {
  slug: String
  title: String
  isPublished: Boolean
}

input BookVolumeUpdateManyMutationInput {
  slug: String
  title: String
  isPublished: Boolean
}

input BookVolumeUpdateManyWithoutBookInput {
  create: [BookVolumeCreateWithoutBookInput!]
  delete: [BookVolumeWhereUniqueInput!]
  connect: [BookVolumeWhereUniqueInput!]
  set: [BookVolumeWhereUniqueInput!]
  disconnect: [BookVolumeWhereUniqueInput!]
  update: [BookVolumeUpdateWithWhereUniqueWithoutBookInput!]
  upsert: [BookVolumeUpsertWithWhereUniqueWithoutBookInput!]
  deleteMany: [BookVolumeScalarWhereInput!]
  updateMany: [BookVolumeUpdateManyWithWhereNestedInput!]
}

input BookVolumeUpdateManyWithWhereNestedInput {
  where: BookVolumeScalarWhereInput!
  data: BookVolumeUpdateManyDataInput!
}

input BookVolumeUpdateOneRequiredWithoutEpisodesInput {
  create: BookVolumeCreateWithoutEpisodesInput
  update: BookVolumeUpdateWithoutEpisodesDataInput
  upsert: BookVolumeUpsertWithoutEpisodesInput
  connect: BookVolumeWhereUniqueInput
}

input BookVolumeUpdateWithoutBookDataInput {
  slug: String
  title: String
  episodes: BookEpisodeUpdateManyWithoutVolumeInput
  isPublished: Boolean
}

input BookVolumeUpdateWithoutEpisodesDataInput {
  slug: String
  title: String
  book: BookUpdateOneRequiredWithoutVolumesInput
  isPublished: Boolean
}

input BookVolumeUpdateWithWhereUniqueWithoutBookInput {
  where: BookVolumeWhereUniqueInput!
  data: BookVolumeUpdateWithoutBookDataInput!
}

input BookVolumeUpsertWithoutEpisodesInput {
  update: BookVolumeUpdateWithoutEpisodesDataInput!
  create: BookVolumeCreateWithoutEpisodesInput!
}

input BookVolumeUpsertWithWhereUniqueWithoutBookInput {
  where: BookVolumeWhereUniqueInput!
  update: BookVolumeUpdateWithoutBookDataInput!
  create: BookVolumeCreateWithoutBookInput!
}

input BookVolumeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  book: BookWhereInput
  episodes_every: BookEpisodeWhereInput
  episodes_some: BookEpisodeWhereInput
  episodes_none: BookEpisodeWhereInput
  isPublished: Boolean
  isPublished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BookVolumeWhereInput!]
  OR: [BookVolumeWhereInput!]
  NOT: [BookVolumeWhereInput!]
}

input BookVolumeWhereUniqueInput {
  id: ID
}

input BookWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  synopsis: String
  synopsis_not: String
  synopsis_in: [String!]
  synopsis_not_in: [String!]
  synopsis_lt: String
  synopsis_lte: String
  synopsis_gt: String
  synopsis_gte: String
  synopsis_contains: String
  synopsis_not_contains: String
  synopsis_starts_with: String
  synopsis_not_starts_with: String
  synopsis_ends_with: String
  synopsis_not_ends_with: String
  thumbnail: ImageWhereInput
  copyrightHolder: CopyrightHolderWhereInput
  authors_every: AuthorWhereInput
  authors_some: AuthorWhereInput
  authors_none: AuthorWhereInput
  mainCategory: CategoryWhereInput
  secondaryCategory: CategoryWhereInput
  translators_every: TranslatorWhereInput
  translators_some: TranslatorWhereInput
  translators_none: TranslatorWhereInput
  volumes_every: BookVolumeWhereInput
  volumes_some: BookVolumeWhereInput
  volumes_none: BookVolumeWhereInput
  isPublished: Boolean
  isPublished_not: Boolean
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  publishTimeline: PublishTimelineWhereInput
  isUnlisted: Boolean
  isUnlisted_not: Boolean
  metaTitle: String
  metaTitle_not: String
  metaTitle_in: [String!]
  metaTitle_not_in: [String!]
  metaTitle_lt: String
  metaTitle_lte: String
  metaTitle_gt: String
  metaTitle_gte: String
  metaTitle_contains: String
  metaTitle_not_contains: String
  metaTitle_starts_with: String
  metaTitle_not_starts_with: String
  metaTitle_ends_with: String
  metaTitle_not_ends_with: String
  metaDescription: String
  metaDescription_not: String
  metaDescription_in: [String!]
  metaDescription_not_in: [String!]
  metaDescription_lt: String
  metaDescription_lte: String
  metaDescription_gt: String
  metaDescription_gte: String
  metaDescription_contains: String
  metaDescription_not_contains: String
  metaDescription_starts_with: String
  metaDescription_not_starts_with: String
  metaDescription_ends_with: String
  metaDescription_not_ends_with: String
  metaKeyword: String
  metaKeyword_not: String
  metaKeyword_in: [String!]
  metaKeyword_not_in: [String!]
  metaKeyword_lt: String
  metaKeyword_lte: String
  metaKeyword_gt: String
  metaKeyword_gte: String
  metaKeyword_contains: String
  metaKeyword_not_contains: String
  metaKeyword_starts_with: String
  metaKeyword_not_starts_with: String
  metaKeyword_ends_with: String
  metaKeyword_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BookWhereInput!]
  OR: [BookWhereInput!]
  NOT: [BookWhereInput!]
}

input BookWhereUniqueInput {
  id: ID
}

type Category {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CategoryConnection {
  pageInfo: PageInfo!
  edges: [CategoryEdge]!
  aggregate: AggregateCategory!
}

input CategoryCreateInput {
  name: String!
}

input CategoryCreateOneInput {
  create: CategoryCreateInput
  connect: CategoryWhereUniqueInput
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CategoryPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CategorySubscriptionPayload {
  mutation: MutationType!
  node: Category
  updatedFields: [String!]
  previousValues: CategoryPreviousValues
}

input CategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CategoryWhereInput
  AND: [CategorySubscriptionWhereInput!]
  OR: [CategorySubscriptionWhereInput!]
  NOT: [CategorySubscriptionWhereInput!]
}

input CategoryUpdateDataInput {
  name: String
}

input CategoryUpdateInput {
  name: String
}

input CategoryUpdateManyMutationInput {
  name: String
}

input CategoryUpdateOneInput {
  create: CategoryCreateInput
  update: CategoryUpdateDataInput
  upsert: CategoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CategoryWhereUniqueInput
}

input CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput!
  create: CategoryCreateInput!
}

input CategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
}

input CategoryWhereUniqueInput {
  id: ID
  name: String
}

type CopyrightHolder {
  id: ID!
  name: String!
  vendor: Vendor
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CopyrightHolderConnection {
  pageInfo: PageInfo!
  edges: [CopyrightHolderEdge]!
  aggregate: AggregateCopyrightHolder!
}

input CopyrightHolderCreateInput {
  name: String!
  vendor: VendorCreateOneWithoutCopyrightHoldersInput
}

input CopyrightHolderCreateManyWithoutVendorInput {
  create: [CopyrightHolderCreateWithoutVendorInput!]
  connect: [CopyrightHolderWhereUniqueInput!]
}

input CopyrightHolderCreateOneInput {
  create: CopyrightHolderCreateInput
  connect: CopyrightHolderWhereUniqueInput
}

input CopyrightHolderCreateWithoutVendorInput {
  name: String!
}

type CopyrightHolderEdge {
  node: CopyrightHolder!
  cursor: String!
}

enum CopyrightHolderOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CopyrightHolderPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CopyrightHolderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CopyrightHolderScalarWhereInput!]
  OR: [CopyrightHolderScalarWhereInput!]
  NOT: [CopyrightHolderScalarWhereInput!]
}

type CopyrightHolderSubscriptionPayload {
  mutation: MutationType!
  node: CopyrightHolder
  updatedFields: [String!]
  previousValues: CopyrightHolderPreviousValues
}

input CopyrightHolderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CopyrightHolderWhereInput
  AND: [CopyrightHolderSubscriptionWhereInput!]
  OR: [CopyrightHolderSubscriptionWhereInput!]
  NOT: [CopyrightHolderSubscriptionWhereInput!]
}

input CopyrightHolderUpdateDataInput {
  name: String
  vendor: VendorUpdateOneWithoutCopyrightHoldersInput
}

input CopyrightHolderUpdateInput {
  name: String
  vendor: VendorUpdateOneWithoutCopyrightHoldersInput
}

input CopyrightHolderUpdateManyDataInput {
  name: String
}

input CopyrightHolderUpdateManyMutationInput {
  name: String
}

input CopyrightHolderUpdateManyWithoutVendorInput {
  create: [CopyrightHolderCreateWithoutVendorInput!]
  delete: [CopyrightHolderWhereUniqueInput!]
  connect: [CopyrightHolderWhereUniqueInput!]
  set: [CopyrightHolderWhereUniqueInput!]
  disconnect: [CopyrightHolderWhereUniqueInput!]
  update: [CopyrightHolderUpdateWithWhereUniqueWithoutVendorInput!]
  upsert: [CopyrightHolderUpsertWithWhereUniqueWithoutVendorInput!]
  deleteMany: [CopyrightHolderScalarWhereInput!]
  updateMany: [CopyrightHolderUpdateManyWithWhereNestedInput!]
}

input CopyrightHolderUpdateManyWithWhereNestedInput {
  where: CopyrightHolderScalarWhereInput!
  data: CopyrightHolderUpdateManyDataInput!
}

input CopyrightHolderUpdateOneInput {
  create: CopyrightHolderCreateInput
  update: CopyrightHolderUpdateDataInput
  upsert: CopyrightHolderUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CopyrightHolderWhereUniqueInput
}

input CopyrightHolderUpdateWithoutVendorDataInput {
  name: String
}

input CopyrightHolderUpdateWithWhereUniqueWithoutVendorInput {
  where: CopyrightHolderWhereUniqueInput!
  data: CopyrightHolderUpdateWithoutVendorDataInput!
}

input CopyrightHolderUpsertNestedInput {
  update: CopyrightHolderUpdateDataInput!
  create: CopyrightHolderCreateInput!
}

input CopyrightHolderUpsertWithWhereUniqueWithoutVendorInput {
  where: CopyrightHolderWhereUniqueInput!
  update: CopyrightHolderUpdateWithoutVendorDataInput!
  create: CopyrightHolderCreateWithoutVendorInput!
}

input CopyrightHolderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  vendor: VendorWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CopyrightHolderWhereInput!]
  OR: [CopyrightHolderWhereInput!]
  NOT: [CopyrightHolderWhereInput!]
}

input CopyrightHolderWhereUniqueInput {
  id: ID
}

enum CurrencyType {
  Reeeed
}

type DashbardDataCache {
  queryName: String!
  arguments: String
  result: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DashbardDataCacheConnection {
  pageInfo: PageInfo!
  edges: [DashbardDataCacheEdge]!
  aggregate: AggregateDashbardDataCache!
}

input DashbardDataCacheCreateInput {
  queryName: String!
  arguments: String
  result: String!
}

type DashbardDataCacheEdge {
  node: DashbardDataCache!
  cursor: String!
}

enum DashbardDataCacheOrderByInput {
  queryName_ASC
  queryName_DESC
  arguments_ASC
  arguments_DESC
  result_ASC
  result_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  id_ASC
  id_DESC
}

type DashbardDataCachePreviousValues {
  queryName: String!
  arguments: String
  result: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DashbardDataCacheSubscriptionPayload {
  mutation: MutationType!
  node: DashbardDataCache
  updatedFields: [String!]
  previousValues: DashbardDataCachePreviousValues
}

input DashbardDataCacheSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DashbardDataCacheWhereInput
  AND: [DashbardDataCacheSubscriptionWhereInput!]
  OR: [DashbardDataCacheSubscriptionWhereInput!]
  NOT: [DashbardDataCacheSubscriptionWhereInput!]
}

input DashbardDataCacheUpdateManyMutationInput {
  queryName: String
  arguments: String
  result: String
}

input DashbardDataCacheWhereInput {
  queryName: String
  queryName_not: String
  queryName_in: [String!]
  queryName_not_in: [String!]
  queryName_lt: String
  queryName_lte: String
  queryName_gt: String
  queryName_gte: String
  queryName_contains: String
  queryName_not_contains: String
  queryName_starts_with: String
  queryName_not_starts_with: String
  queryName_ends_with: String
  queryName_not_ends_with: String
  arguments: String
  arguments_not: String
  arguments_in: [String!]
  arguments_not_in: [String!]
  arguments_lt: String
  arguments_lte: String
  arguments_gt: String
  arguments_gte: String
  arguments_contains: String
  arguments_not_contains: String
  arguments_starts_with: String
  arguments_not_starts_with: String
  arguments_ends_with: String
  arguments_not_ends_with: String
  result: String
  result_not: String
  result_in: [String!]
  result_not_in: [String!]
  result_lt: String
  result_lte: String
  result_gt: String
  result_gte: String
  result_contains: String
  result_not_contains: String
  result_starts_with: String
  result_not_starts_with: String
  result_ends_with: String
  result_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DashbardDataCacheWhereInput!]
  OR: [DashbardDataCacheWhereInput!]
  NOT: [DashbardDataCacheWhereInput!]
}

scalar DateTime

type Document {
  id: ID!
  file: File
  image: Image
  type: DocumentType!
}

type DocumentConnection {
  pageInfo: PageInfo!
  edges: [DocumentEdge]!
  aggregate: AggregateDocument!
}

input DocumentCreateInput {
  file: FileCreateOneInput
  image: ImageCreateOneInput
  type: DocumentType!
}

input DocumentCreateManyInput {
  create: [DocumentCreateInput!]
  connect: [DocumentWhereUniqueInput!]
}

type DocumentEdge {
  node: Document!
  cursor: String!
}

enum DocumentOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DocumentPreviousValues {
  id: ID!
  type: DocumentType!
}

input DocumentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: DocumentType
  type_not: DocumentType
  type_in: [DocumentType!]
  type_not_in: [DocumentType!]
  AND: [DocumentScalarWhereInput!]
  OR: [DocumentScalarWhereInput!]
  NOT: [DocumentScalarWhereInput!]
}

type DocumentSubscriptionPayload {
  mutation: MutationType!
  node: Document
  updatedFields: [String!]
  previousValues: DocumentPreviousValues
}

input DocumentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DocumentWhereInput
  AND: [DocumentSubscriptionWhereInput!]
  OR: [DocumentSubscriptionWhereInput!]
  NOT: [DocumentSubscriptionWhereInput!]
}

enum DocumentType {
  Other
  CitizenID
  PassportID
  CertificateVATRegistration
  CertificateCompanyRegistration
}

input DocumentUpdateDataInput {
  file: FileUpdateOneInput
  image: ImageUpdateOneInput
  type: DocumentType
}

input DocumentUpdateInput {
  file: FileUpdateOneInput
  image: ImageUpdateOneInput
  type: DocumentType
}

input DocumentUpdateManyDataInput {
  type: DocumentType
}

input DocumentUpdateManyInput {
  create: [DocumentCreateInput!]
  update: [DocumentUpdateWithWhereUniqueNestedInput!]
  upsert: [DocumentUpsertWithWhereUniqueNestedInput!]
  delete: [DocumentWhereUniqueInput!]
  connect: [DocumentWhereUniqueInput!]
  set: [DocumentWhereUniqueInput!]
  disconnect: [DocumentWhereUniqueInput!]
  deleteMany: [DocumentScalarWhereInput!]
  updateMany: [DocumentUpdateManyWithWhereNestedInput!]
}

input DocumentUpdateManyMutationInput {
  type: DocumentType
}

input DocumentUpdateManyWithWhereNestedInput {
  where: DocumentScalarWhereInput!
  data: DocumentUpdateManyDataInput!
}

input DocumentUpdateWithWhereUniqueNestedInput {
  where: DocumentWhereUniqueInput!
  data: DocumentUpdateDataInput!
}

input DocumentUpsertWithWhereUniqueNestedInput {
  where: DocumentWhereUniqueInput!
  update: DocumentUpdateDataInput!
  create: DocumentCreateInput!
}

input DocumentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  file: FileWhereInput
  image: ImageWhereInput
  type: DocumentType
  type_not: DocumentType
  type_in: [DocumentType!]
  type_not_in: [DocumentType!]
  AND: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  NOT: [DocumentWhereInput!]
}

input DocumentWhereUniqueInput {
  id: ID
}

type ExchangeTier {
  id: ID!
  type: ExchangeType!
  name: String!
  currencyType: CurrencyType!
  income: Float!
  outcome: Float!
  promotions(where: PromotionWhereInput, orderBy: PromotionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Promotion!]
  isDefault: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  publishTimeline: PublishTimeline
}

type ExchangeTierConnection {
  pageInfo: PageInfo!
  edges: [ExchangeTierEdge]!
  aggregate: AggregateExchangeTier!
}

input ExchangeTierCreateInput {
  type: ExchangeType!
  name: String!
  currencyType: CurrencyType!
  income: Float!
  outcome: Float!
  promotions: PromotionCreateManyInput
  isDefault: Boolean
  publishTimeline: PublishTimelineCreateOneInput
}

input ExchangeTierCreateOneInput {
  create: ExchangeTierCreateInput
  connect: ExchangeTierWhereUniqueInput
}

type ExchangeTierEdge {
  node: ExchangeTier!
  cursor: String!
}

enum ExchangeTierOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  name_ASC
  name_DESC
  currencyType_ASC
  currencyType_DESC
  income_ASC
  income_DESC
  outcome_ASC
  outcome_DESC
  isDefault_ASC
  isDefault_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExchangeTierPreviousValues {
  id: ID!
  type: ExchangeType!
  name: String!
  currencyType: CurrencyType!
  income: Float!
  outcome: Float!
  isDefault: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExchangeTierSubscriptionPayload {
  mutation: MutationType!
  node: ExchangeTier
  updatedFields: [String!]
  previousValues: ExchangeTierPreviousValues
}

input ExchangeTierSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExchangeTierWhereInput
  AND: [ExchangeTierSubscriptionWhereInput!]
  OR: [ExchangeTierSubscriptionWhereInput!]
  NOT: [ExchangeTierSubscriptionWhereInput!]
}

input ExchangeTierUpdateDataInput {
  type: ExchangeType
  name: String
  currencyType: CurrencyType
  income: Float
  outcome: Float
  promotions: PromotionUpdateManyInput
  isDefault: Boolean
  publishTimeline: PublishTimelineUpdateOneInput
}

input ExchangeTierUpdateInput {
  type: ExchangeType
  name: String
  currencyType: CurrencyType
  income: Float
  outcome: Float
  promotions: PromotionUpdateManyInput
  isDefault: Boolean
  publishTimeline: PublishTimelineUpdateOneInput
}

input ExchangeTierUpdateManyMutationInput {
  type: ExchangeType
  name: String
  currencyType: CurrencyType
  income: Float
  outcome: Float
  isDefault: Boolean
}

input ExchangeTierUpdateOneRequiredInput {
  create: ExchangeTierCreateInput
  update: ExchangeTierUpdateDataInput
  upsert: ExchangeTierUpsertNestedInput
  connect: ExchangeTierWhereUniqueInput
}

input ExchangeTierUpsertNestedInput {
  update: ExchangeTierUpdateDataInput!
  create: ExchangeTierCreateInput!
}

input ExchangeTierWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ExchangeType
  type_not: ExchangeType
  type_in: [ExchangeType!]
  type_not_in: [ExchangeType!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  currencyType: CurrencyType
  currencyType_not: CurrencyType
  currencyType_in: [CurrencyType!]
  currencyType_not_in: [CurrencyType!]
  income: Float
  income_not: Float
  income_in: [Float!]
  income_not_in: [Float!]
  income_lt: Float
  income_lte: Float
  income_gt: Float
  income_gte: Float
  outcome: Float
  outcome_not: Float
  outcome_in: [Float!]
  outcome_not_in: [Float!]
  outcome_lt: Float
  outcome_lte: Float
  outcome_gt: Float
  outcome_gte: Float
  promotions_every: PromotionWhereInput
  promotions_some: PromotionWhereInput
  promotions_none: PromotionWhereInput
  isDefault: Boolean
  isDefault_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  publishTimeline: PublishTimelineWhereInput
  AND: [ExchangeTierWhereInput!]
  OR: [ExchangeTierWhereInput!]
  NOT: [ExchangeTierWhereInput!]
}

input ExchangeTierWhereUniqueInput {
  id: ID
}

type ExchangeTransaction {
  id: ID!
  orderID: String
  user: User!
  tier: ExchangeTier!
  status(where: ExchangeTransactionStatusHistoryWhereInput, orderBy: ExchangeTransactionStatusHistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExchangeTransactionStatusHistory!]
  currentStatus: ExchangeTransactionType
  payload: Json!
  createdAt: DateTime!
  updatedAt: DateTime!
  refCode: String
}

type ExchangeTransactionConnection {
  pageInfo: PageInfo!
  edges: [ExchangeTransactionEdge]!
  aggregate: AggregateExchangeTransaction!
}

input ExchangeTransactionCreateInput {
  orderID: String
  user: UserCreateOneWithoutExchangeTransactionsInput!
  tier: ExchangeTierCreateOneInput!
  status: ExchangeTransactionStatusHistoryCreateManyInput
  currentStatus: ExchangeTransactionType
  payload: Json!
  refCode: String
}

input ExchangeTransactionCreateManyWithoutUserInput {
  create: [ExchangeTransactionCreateWithoutUserInput!]
  connect: [ExchangeTransactionWhereUniqueInput!]
}

input ExchangeTransactionCreateOneInput {
  create: ExchangeTransactionCreateInput
  connect: ExchangeTransactionWhereUniqueInput
}

input ExchangeTransactionCreateWithoutUserInput {
  orderID: String
  tier: ExchangeTierCreateOneInput!
  status: ExchangeTransactionStatusHistoryCreateManyInput
  currentStatus: ExchangeTransactionType
  payload: Json!
  refCode: String
}

type ExchangeTransactionEdge {
  node: ExchangeTransaction!
  cursor: String!
}

enum ExchangeTransactionOrderByInput {
  id_ASC
  id_DESC
  orderID_ASC
  orderID_DESC
  currentStatus_ASC
  currentStatus_DESC
  payload_ASC
  payload_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  refCode_ASC
  refCode_DESC
}

type ExchangeTransactionPreviousValues {
  id: ID!
  orderID: String
  currentStatus: ExchangeTransactionType
  payload: Json!
  createdAt: DateTime!
  updatedAt: DateTime!
  refCode: String
}

input ExchangeTransactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  orderID: String
  orderID_not: String
  orderID_in: [String!]
  orderID_not_in: [String!]
  orderID_lt: String
  orderID_lte: String
  orderID_gt: String
  orderID_gte: String
  orderID_contains: String
  orderID_not_contains: String
  orderID_starts_with: String
  orderID_not_starts_with: String
  orderID_ends_with: String
  orderID_not_ends_with: String
  currentStatus: ExchangeTransactionType
  currentStatus_not: ExchangeTransactionType
  currentStatus_in: [ExchangeTransactionType!]
  currentStatus_not_in: [ExchangeTransactionType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  refCode: String
  refCode_not: String
  refCode_in: [String!]
  refCode_not_in: [String!]
  refCode_lt: String
  refCode_lte: String
  refCode_gt: String
  refCode_gte: String
  refCode_contains: String
  refCode_not_contains: String
  refCode_starts_with: String
  refCode_not_starts_with: String
  refCode_ends_with: String
  refCode_not_ends_with: String
  AND: [ExchangeTransactionScalarWhereInput!]
  OR: [ExchangeTransactionScalarWhereInput!]
  NOT: [ExchangeTransactionScalarWhereInput!]
}

type ExchangeTransactionStatusHistory {
  id: ID!
  status: ExchangeTransactionType!
  message: String
}

type ExchangeTransactionStatusHistoryConnection {
  pageInfo: PageInfo!
  edges: [ExchangeTransactionStatusHistoryEdge]!
  aggregate: AggregateExchangeTransactionStatusHistory!
}

input ExchangeTransactionStatusHistoryCreateInput {
  status: ExchangeTransactionType!
  message: String
}

input ExchangeTransactionStatusHistoryCreateManyInput {
  create: [ExchangeTransactionStatusHistoryCreateInput!]
  connect: [ExchangeTransactionStatusHistoryWhereUniqueInput!]
}

type ExchangeTransactionStatusHistoryEdge {
  node: ExchangeTransactionStatusHistory!
  cursor: String!
}

enum ExchangeTransactionStatusHistoryOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  message_ASC
  message_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExchangeTransactionStatusHistoryPreviousValues {
  id: ID!
  status: ExchangeTransactionType!
  message: String
}

input ExchangeTransactionStatusHistoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ExchangeTransactionType
  status_not: ExchangeTransactionType
  status_in: [ExchangeTransactionType!]
  status_not_in: [ExchangeTransactionType!]
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  AND: [ExchangeTransactionStatusHistoryScalarWhereInput!]
  OR: [ExchangeTransactionStatusHistoryScalarWhereInput!]
  NOT: [ExchangeTransactionStatusHistoryScalarWhereInput!]
}

type ExchangeTransactionStatusHistorySubscriptionPayload {
  mutation: MutationType!
  node: ExchangeTransactionStatusHistory
  updatedFields: [String!]
  previousValues: ExchangeTransactionStatusHistoryPreviousValues
}

input ExchangeTransactionStatusHistorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExchangeTransactionStatusHistoryWhereInput
  AND: [ExchangeTransactionStatusHistorySubscriptionWhereInput!]
  OR: [ExchangeTransactionStatusHistorySubscriptionWhereInput!]
  NOT: [ExchangeTransactionStatusHistorySubscriptionWhereInput!]
}

input ExchangeTransactionStatusHistoryUpdateDataInput {
  status: ExchangeTransactionType
  message: String
}

input ExchangeTransactionStatusHistoryUpdateInput {
  status: ExchangeTransactionType
  message: String
}

input ExchangeTransactionStatusHistoryUpdateManyDataInput {
  status: ExchangeTransactionType
  message: String
}

input ExchangeTransactionStatusHistoryUpdateManyInput {
  create: [ExchangeTransactionStatusHistoryCreateInput!]
  update: [ExchangeTransactionStatusHistoryUpdateWithWhereUniqueNestedInput!]
  upsert: [ExchangeTransactionStatusHistoryUpsertWithWhereUniqueNestedInput!]
  delete: [ExchangeTransactionStatusHistoryWhereUniqueInput!]
  connect: [ExchangeTransactionStatusHistoryWhereUniqueInput!]
  set: [ExchangeTransactionStatusHistoryWhereUniqueInput!]
  disconnect: [ExchangeTransactionStatusHistoryWhereUniqueInput!]
  deleteMany: [ExchangeTransactionStatusHistoryScalarWhereInput!]
  updateMany: [ExchangeTransactionStatusHistoryUpdateManyWithWhereNestedInput!]
}

input ExchangeTransactionStatusHistoryUpdateManyMutationInput {
  status: ExchangeTransactionType
  message: String
}

input ExchangeTransactionStatusHistoryUpdateManyWithWhereNestedInput {
  where: ExchangeTransactionStatusHistoryScalarWhereInput!
  data: ExchangeTransactionStatusHistoryUpdateManyDataInput!
}

input ExchangeTransactionStatusHistoryUpdateWithWhereUniqueNestedInput {
  where: ExchangeTransactionStatusHistoryWhereUniqueInput!
  data: ExchangeTransactionStatusHistoryUpdateDataInput!
}

input ExchangeTransactionStatusHistoryUpsertWithWhereUniqueNestedInput {
  where: ExchangeTransactionStatusHistoryWhereUniqueInput!
  update: ExchangeTransactionStatusHistoryUpdateDataInput!
  create: ExchangeTransactionStatusHistoryCreateInput!
}

input ExchangeTransactionStatusHistoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ExchangeTransactionType
  status_not: ExchangeTransactionType
  status_in: [ExchangeTransactionType!]
  status_not_in: [ExchangeTransactionType!]
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  AND: [ExchangeTransactionStatusHistoryWhereInput!]
  OR: [ExchangeTransactionStatusHistoryWhereInput!]
  NOT: [ExchangeTransactionStatusHistoryWhereInput!]
}

input ExchangeTransactionStatusHistoryWhereUniqueInput {
  id: ID
}

type ExchangeTransactionSubscriptionPayload {
  mutation: MutationType!
  node: ExchangeTransaction
  updatedFields: [String!]
  previousValues: ExchangeTransactionPreviousValues
}

input ExchangeTransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExchangeTransactionWhereInput
  AND: [ExchangeTransactionSubscriptionWhereInput!]
  OR: [ExchangeTransactionSubscriptionWhereInput!]
  NOT: [ExchangeTransactionSubscriptionWhereInput!]
}

enum ExchangeTransactionType {
  Init
  Pending
  Success
  Failed
}

input ExchangeTransactionUpdateDataInput {
  orderID: String
  user: UserUpdateOneRequiredWithoutExchangeTransactionsInput
  tier: ExchangeTierUpdateOneRequiredInput
  status: ExchangeTransactionStatusHistoryUpdateManyInput
  currentStatus: ExchangeTransactionType
  payload: Json
  refCode: String
}

input ExchangeTransactionUpdateInput {
  orderID: String
  user: UserUpdateOneRequiredWithoutExchangeTransactionsInput
  tier: ExchangeTierUpdateOneRequiredInput
  status: ExchangeTransactionStatusHistoryUpdateManyInput
  currentStatus: ExchangeTransactionType
  payload: Json
  refCode: String
}

input ExchangeTransactionUpdateManyDataInput {
  orderID: String
  currentStatus: ExchangeTransactionType
  payload: Json
  refCode: String
}

input ExchangeTransactionUpdateManyMutationInput {
  orderID: String
  currentStatus: ExchangeTransactionType
  payload: Json
  refCode: String
}

input ExchangeTransactionUpdateManyWithoutUserInput {
  create: [ExchangeTransactionCreateWithoutUserInput!]
  delete: [ExchangeTransactionWhereUniqueInput!]
  connect: [ExchangeTransactionWhereUniqueInput!]
  set: [ExchangeTransactionWhereUniqueInput!]
  disconnect: [ExchangeTransactionWhereUniqueInput!]
  update: [ExchangeTransactionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ExchangeTransactionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ExchangeTransactionScalarWhereInput!]
  updateMany: [ExchangeTransactionUpdateManyWithWhereNestedInput!]
}

input ExchangeTransactionUpdateManyWithWhereNestedInput {
  where: ExchangeTransactionScalarWhereInput!
  data: ExchangeTransactionUpdateManyDataInput!
}

input ExchangeTransactionUpdateOneInput {
  create: ExchangeTransactionCreateInput
  update: ExchangeTransactionUpdateDataInput
  upsert: ExchangeTransactionUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ExchangeTransactionWhereUniqueInput
}

input ExchangeTransactionUpdateWithoutUserDataInput {
  orderID: String
  tier: ExchangeTierUpdateOneRequiredInput
  status: ExchangeTransactionStatusHistoryUpdateManyInput
  currentStatus: ExchangeTransactionType
  payload: Json
  refCode: String
}

input ExchangeTransactionUpdateWithWhereUniqueWithoutUserInput {
  where: ExchangeTransactionWhereUniqueInput!
  data: ExchangeTransactionUpdateWithoutUserDataInput!
}

input ExchangeTransactionUpsertNestedInput {
  update: ExchangeTransactionUpdateDataInput!
  create: ExchangeTransactionCreateInput!
}

input ExchangeTransactionUpsertWithWhereUniqueWithoutUserInput {
  where: ExchangeTransactionWhereUniqueInput!
  update: ExchangeTransactionUpdateWithoutUserDataInput!
  create: ExchangeTransactionCreateWithoutUserInput!
}

input ExchangeTransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  orderID: String
  orderID_not: String
  orderID_in: [String!]
  orderID_not_in: [String!]
  orderID_lt: String
  orderID_lte: String
  orderID_gt: String
  orderID_gte: String
  orderID_contains: String
  orderID_not_contains: String
  orderID_starts_with: String
  orderID_not_starts_with: String
  orderID_ends_with: String
  orderID_not_ends_with: String
  user: UserWhereInput
  tier: ExchangeTierWhereInput
  status_every: ExchangeTransactionStatusHistoryWhereInput
  status_some: ExchangeTransactionStatusHistoryWhereInput
  status_none: ExchangeTransactionStatusHistoryWhereInput
  currentStatus: ExchangeTransactionType
  currentStatus_not: ExchangeTransactionType
  currentStatus_in: [ExchangeTransactionType!]
  currentStatus_not_in: [ExchangeTransactionType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  refCode: String
  refCode_not: String
  refCode_in: [String!]
  refCode_not_in: [String!]
  refCode_lt: String
  refCode_lte: String
  refCode_gt: String
  refCode_gte: String
  refCode_contains: String
  refCode_not_contains: String
  refCode_starts_with: String
  refCode_not_starts_with: String
  refCode_ends_with: String
  refCode_not_ends_with: String
  AND: [ExchangeTransactionWhereInput!]
  OR: [ExchangeTransactionWhereInput!]
  NOT: [ExchangeTransactionWhereInput!]
}

input ExchangeTransactionWhereUniqueInput {
  id: ID
}

enum ExchangeType {
  CreditCard
  WebPay
  LinePay
  TrueWallet
}

type File {
  id: ID!
  path: String!
  fileName: String!
  createdAt: DateTime!
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  path: String!
  fileName: String!
}

input FileCreateOneInput {
  create: FileCreateInput
  connect: FileWhereUniqueInput
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  path_ASC
  path_DESC
  fileName_ASC
  fileName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FilePreviousValues {
  id: ID!
  path: String!
  fileName: String!
  createdAt: DateTime!
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateDataInput {
  path: String
  fileName: String
}

input FileUpdateInput {
  path: String
  fileName: String
}

input FileUpdateManyMutationInput {
  path: String
  fileName: String
}

input FileUpdateOneInput {
  create: FileCreateInput
  update: FileUpdateDataInput
  upsert: FileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FileWhereUniqueInput
}

input FileUpsertNestedInput {
  update: FileUpdateDataInput!
  create: FileCreateInput!
}

input FileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  fileName: String
  fileName_not: String
  fileName_in: [String!]
  fileName_not_in: [String!]
  fileName_lt: String
  fileName_lte: String
  fileName_gt: String
  fileName_gte: String
  fileName_contains: String
  fileName_not_contains: String
  fileName_starts_with: String
  fileName_not_starts_with: String
  fileName_ends_with: String
  fileName_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
}

enum Gender {
  Male
  Female
  Unknown
}

type History {
  id: ID!
  payload: Json
  mutationName: String!
  updateBy: String!
}

type HistoryConnection {
  pageInfo: PageInfo!
  edges: [HistoryEdge]!
  aggregate: AggregateHistory!
}

input HistoryCreateInput {
  payload: Json
  mutationName: String!
  updateBy: String!
}

type HistoryEdge {
  node: History!
  cursor: String!
}

enum HistoryOrderByInput {
  id_ASC
  id_DESC
  payload_ASC
  payload_DESC
  mutationName_ASC
  mutationName_DESC
  updateBy_ASC
  updateBy_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HistoryPreviousValues {
  id: ID!
  payload: Json
  mutationName: String!
  updateBy: String!
}

type HistorySubscriptionPayload {
  mutation: MutationType!
  node: History
  updatedFields: [String!]
  previousValues: HistoryPreviousValues
}

input HistorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HistoryWhereInput
  AND: [HistorySubscriptionWhereInput!]
  OR: [HistorySubscriptionWhereInput!]
  NOT: [HistorySubscriptionWhereInput!]
}

input HistoryUpdateInput {
  payload: Json
  mutationName: String
  updateBy: String
}

input HistoryUpdateManyMutationInput {
  payload: Json
  mutationName: String
  updateBy: String
}

input HistoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  mutationName: String
  mutationName_not: String
  mutationName_in: [String!]
  mutationName_not_in: [String!]
  mutationName_lt: String
  mutationName_lte: String
  mutationName_gt: String
  mutationName_gte: String
  mutationName_contains: String
  mutationName_not_contains: String
  mutationName_starts_with: String
  mutationName_not_starts_with: String
  mutationName_ends_with: String
  mutationName_not_ends_with: String
  updateBy: String
  updateBy_not: String
  updateBy_in: [String!]
  updateBy_not_in: [String!]
  updateBy_lt: String
  updateBy_lte: String
  updateBy_gt: String
  updateBy_gte: String
  updateBy_contains: String
  updateBy_not_contains: String
  updateBy_starts_with: String
  updateBy_not_starts_with: String
  updateBy_ends_with: String
  updateBy_not_ends_with: String
  AND: [HistoryWhereInput!]
  OR: [HistoryWhereInput!]
  NOT: [HistoryWhereInput!]
}

input HistoryWhereUniqueInput {
  id: ID
}

type Image {
  id: ID!
  small: String!
  medium: String!
  large: String!
  fileName: String!
  createdAt: DateTime!
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  small: String!
  medium: String!
  large: String!
  fileName: String!
}

input ImageCreateOneInput {
  create: ImageCreateInput
  connect: ImageWhereUniqueInput
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  small_ASC
  small_DESC
  medium_ASC
  medium_DESC
  large_ASC
  large_DESC
  fileName_ASC
  fileName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ImagePreviousValues {
  id: ID!
  small: String!
  medium: String!
  large: String!
  fileName: String!
  createdAt: DateTime!
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateDataInput {
  small: String
  medium: String
  large: String
  fileName: String
}

input ImageUpdateInput {
  small: String
  medium: String
  large: String
  fileName: String
}

input ImageUpdateManyMutationInput {
  small: String
  medium: String
  large: String
  fileName: String
}

input ImageUpdateOneInput {
  create: ImageCreateInput
  update: ImageUpdateDataInput
  upsert: ImageUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ImageWhereUniqueInput
}

input ImageUpsertNestedInput {
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  small: String
  small_not: String
  small_in: [String!]
  small_not_in: [String!]
  small_lt: String
  small_lte: String
  small_gt: String
  small_gte: String
  small_contains: String
  small_not_contains: String
  small_starts_with: String
  small_not_starts_with: String
  small_ends_with: String
  small_not_ends_with: String
  medium: String
  medium_not: String
  medium_in: [String!]
  medium_not_in: [String!]
  medium_lt: String
  medium_lte: String
  medium_gt: String
  medium_gte: String
  medium_contains: String
  medium_not_contains: String
  medium_starts_with: String
  medium_not_starts_with: String
  medium_ends_with: String
  medium_not_ends_with: String
  large: String
  large_not: String
  large_in: [String!]
  large_not_in: [String!]
  large_lt: String
  large_lte: String
  large_gt: String
  large_gte: String
  large_contains: String
  large_not_contains: String
  large_starts_with: String
  large_not_starts_with: String
  large_ends_with: String
  large_not_ends_with: String
  fileName: String
  fileName_not: String
  fileName_in: [String!]
  fileName_not_in: [String!]
  fileName_lt: String
  fileName_lte: String
  fileName_gt: String
  fileName_gte: String
  fileName_contains: String
  fileName_not_contains: String
  fileName_starts_with: String
  fileName_not_starts_with: String
  fileName_ends_with: String
  fileName_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

type Item {
  id: ID!
  user: User!
  asset: ItemAsset
  amount: Int!
  expireAt: DateTime
  transaction: Transaction
}

type ItemAsset {
  id: ID!
  assetType: String!
  assetID: ID!
  item: Item
}

type ItemAssetConnection {
  pageInfo: PageInfo!
  edges: [ItemAssetEdge]!
  aggregate: AggregateItemAsset!
}

input ItemAssetCreateInput {
  assetType: String!
  assetID: ID!
  item: ItemCreateOneWithoutAssetInput
}

input ItemAssetCreateOneWithoutItemInput {
  create: ItemAssetCreateWithoutItemInput
  connect: ItemAssetWhereUniqueInput
}

input ItemAssetCreateWithoutItemInput {
  assetType: String!
  assetID: ID!
}

type ItemAssetEdge {
  node: ItemAsset!
  cursor: String!
}

enum ItemAssetOrderByInput {
  id_ASC
  id_DESC
  assetType_ASC
  assetType_DESC
  assetID_ASC
  assetID_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ItemAssetPreviousValues {
  id: ID!
  assetType: String!
  assetID: ID!
}

type ItemAssetSubscriptionPayload {
  mutation: MutationType!
  node: ItemAsset
  updatedFields: [String!]
  previousValues: ItemAssetPreviousValues
}

input ItemAssetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemAssetWhereInput
  AND: [ItemAssetSubscriptionWhereInput!]
  OR: [ItemAssetSubscriptionWhereInput!]
  NOT: [ItemAssetSubscriptionWhereInput!]
}

input ItemAssetUpdateInput {
  assetType: String
  assetID: ID
  item: ItemUpdateOneWithoutAssetInput
}

input ItemAssetUpdateManyMutationInput {
  assetType: String
  assetID: ID
}

input ItemAssetUpdateOneWithoutItemInput {
  create: ItemAssetCreateWithoutItemInput
  update: ItemAssetUpdateWithoutItemDataInput
  upsert: ItemAssetUpsertWithoutItemInput
  delete: Boolean
  disconnect: Boolean
  connect: ItemAssetWhereUniqueInput
}

input ItemAssetUpdateWithoutItemDataInput {
  assetType: String
  assetID: ID
}

input ItemAssetUpsertWithoutItemInput {
  update: ItemAssetUpdateWithoutItemDataInput!
  create: ItemAssetCreateWithoutItemInput!
}

input ItemAssetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  assetType: String
  assetType_not: String
  assetType_in: [String!]
  assetType_not_in: [String!]
  assetType_lt: String
  assetType_lte: String
  assetType_gt: String
  assetType_gte: String
  assetType_contains: String
  assetType_not_contains: String
  assetType_starts_with: String
  assetType_not_starts_with: String
  assetType_ends_with: String
  assetType_not_ends_with: String
  assetID: ID
  assetID_not: ID
  assetID_in: [ID!]
  assetID_not_in: [ID!]
  assetID_lt: ID
  assetID_lte: ID
  assetID_gt: ID
  assetID_gte: ID
  assetID_contains: ID
  assetID_not_contains: ID
  assetID_starts_with: ID
  assetID_not_starts_with: ID
  assetID_ends_with: ID
  assetID_not_ends_with: ID
  item: ItemWhereInput
  AND: [ItemAssetWhereInput!]
  OR: [ItemAssetWhereInput!]
  NOT: [ItemAssetWhereInput!]
}

input ItemAssetWhereUniqueInput {
  id: ID
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  user: UserCreateOneInput!
  asset: ItemAssetCreateOneWithoutItemInput
  amount: Int!
  expireAt: DateTime
  transaction: TransactionCreateOneWithoutItemsInput
}

input ItemCreateManyWithoutTransactionInput {
  create: [ItemCreateWithoutTransactionInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateOneWithoutAssetInput {
  create: ItemCreateWithoutAssetInput
  connect: ItemWhereUniqueInput
}

input ItemCreateWithoutAssetInput {
  user: UserCreateOneInput!
  amount: Int!
  expireAt: DateTime
  transaction: TransactionCreateOneWithoutItemsInput
}

input ItemCreateWithoutTransactionInput {
  user: UserCreateOneInput!
  asset: ItemAssetCreateOneWithoutItemInput
  amount: Int!
  expireAt: DateTime
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  expireAt_ASC
  expireAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ItemPreviousValues {
  id: ID!
  amount: Int!
  expireAt: DateTime
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  expireAt: DateTime
  expireAt_not: DateTime
  expireAt_in: [DateTime!]
  expireAt_not_in: [DateTime!]
  expireAt_lt: DateTime
  expireAt_lte: DateTime
  expireAt_gt: DateTime
  expireAt_gte: DateTime
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  user: UserUpdateOneRequiredInput
  asset: ItemAssetUpdateOneWithoutItemInput
  amount: Int
  expireAt: DateTime
  transaction: TransactionUpdateOneWithoutItemsInput
}

input ItemUpdateManyDataInput {
  amount: Int
  expireAt: DateTime
}

input ItemUpdateManyMutationInput {
  amount: Int
  expireAt: DateTime
}

input ItemUpdateManyWithoutTransactionInput {
  create: [ItemCreateWithoutTransactionInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutTransactionInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutTransactionInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateOneWithoutAssetInput {
  create: ItemCreateWithoutAssetInput
  update: ItemUpdateWithoutAssetDataInput
  upsert: ItemUpsertWithoutAssetInput
  delete: Boolean
  disconnect: Boolean
  connect: ItemWhereUniqueInput
}

input ItemUpdateWithoutAssetDataInput {
  user: UserUpdateOneRequiredInput
  amount: Int
  expireAt: DateTime
  transaction: TransactionUpdateOneWithoutItemsInput
}

input ItemUpdateWithoutTransactionDataInput {
  user: UserUpdateOneRequiredInput
  asset: ItemAssetUpdateOneWithoutItemInput
  amount: Int
  expireAt: DateTime
}

input ItemUpdateWithWhereUniqueWithoutTransactionInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutTransactionDataInput!
}

input ItemUpsertWithoutAssetInput {
  update: ItemUpdateWithoutAssetDataInput!
  create: ItemCreateWithoutAssetInput!
}

input ItemUpsertWithWhereUniqueWithoutTransactionInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutTransactionDataInput!
  create: ItemCreateWithoutTransactionInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  asset: ItemAssetWhereInput
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  expireAt: DateTime
  expireAt_not: DateTime
  expireAt_in: [DateTime!]
  expireAt_not_in: [DateTime!]
  expireAt_lt: DateTime
  expireAt_lte: DateTime
  expireAt_gt: DateTime
  expireAt_gte: DateTime
  transaction: TransactionWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Json

scalar Long

type Migration {
  id: ID!
  num: Int!
}

type MigrationConnection {
  pageInfo: PageInfo!
  edges: [MigrationEdge]!
  aggregate: AggregateMigration!
}

input MigrationCreateInput {
  num: Int!
}

type MigrationEdge {
  node: Migration!
  cursor: String!
}

enum MigrationOrderByInput {
  id_ASC
  id_DESC
  num_ASC
  num_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MigrationPreviousValues {
  id: ID!
  num: Int!
}

type MigrationSubscriptionPayload {
  mutation: MutationType!
  node: Migration
  updatedFields: [String!]
  previousValues: MigrationPreviousValues
}

input MigrationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MigrationWhereInput
  AND: [MigrationSubscriptionWhereInput!]
  OR: [MigrationSubscriptionWhereInput!]
  NOT: [MigrationSubscriptionWhereInput!]
}

input MigrationUpdateInput {
  num: Int
}

input MigrationUpdateManyMutationInput {
  num: Int
}

input MigrationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  num: Int
  num_not: Int
  num_in: [Int!]
  num_not_in: [Int!]
  num_lt: Int
  num_lte: Int
  num_gt: Int
  num_gte: Int
  AND: [MigrationWhereInput!]
  OR: [MigrationWhereInput!]
  NOT: [MigrationWhereInput!]
}

input MigrationWhereUniqueInput {
  id: ID
  num: Int
}

type Mutation {
  createAdsBanner(data: AdsBannerCreateInput!): AdsBanner!
  updateAdsBanner(data: AdsBannerUpdateInput!, where: AdsBannerWhereUniqueInput!): AdsBanner
  updateManyAdsBanners(data: AdsBannerUpdateManyMutationInput!, where: AdsBannerWhereInput): BatchPayload!
  upsertAdsBanner(where: AdsBannerWhereUniqueInput!, create: AdsBannerCreateInput!, update: AdsBannerUpdateInput!): AdsBanner!
  deleteAdsBanner(where: AdsBannerWhereUniqueInput!): AdsBanner
  deleteManyAdsBanners(where: AdsBannerWhereInput): BatchPayload!
  createAuthor(data: AuthorCreateInput!): Author!
  updateAuthor(data: AuthorUpdateInput!, where: AuthorWhereUniqueInput!): Author
  updateManyAuthors(data: AuthorUpdateManyMutationInput!, where: AuthorWhereInput): BatchPayload!
  upsertAuthor(where: AuthorWhereUniqueInput!, create: AuthorCreateInput!, update: AuthorUpdateInput!): Author!
  deleteAuthor(where: AuthorWhereUniqueInput!): Author
  deleteManyAuthors(where: AuthorWhereInput): BatchPayload!
  createBehavior(data: BehaviorCreateInput!): Behavior!
  updateBehavior(data: BehaviorUpdateInput!, where: BehaviorWhereUniqueInput!): Behavior
  updateManyBehaviors(data: BehaviorUpdateManyMutationInput!, where: BehaviorWhereInput): BatchPayload!
  upsertBehavior(where: BehaviorWhereUniqueInput!, create: BehaviorCreateInput!, update: BehaviorUpdateInput!): Behavior!
  deleteBehavior(where: BehaviorWhereUniqueInput!): Behavior
  deleteManyBehaviors(where: BehaviorWhereInput): BatchPayload!
  createBook(data: BookCreateInput!): Book!
  updateBook(data: BookUpdateInput!, where: BookWhereUniqueInput!): Book
  updateManyBooks(data: BookUpdateManyMutationInput!, where: BookWhereInput): BatchPayload!
  upsertBook(where: BookWhereUniqueInput!, create: BookCreateInput!, update: BookUpdateInput!): Book!
  deleteBook(where: BookWhereUniqueInput!): Book
  deleteManyBooks(where: BookWhereInput): BatchPayload!
  createBookEpisode(data: BookEpisodeCreateInput!): BookEpisode!
  updateBookEpisode(data: BookEpisodeUpdateInput!, where: BookEpisodeWhereUniqueInput!): BookEpisode
  updateManyBookEpisodes(data: BookEpisodeUpdateManyMutationInput!, where: BookEpisodeWhereInput): BatchPayload!
  upsertBookEpisode(where: BookEpisodeWhereUniqueInput!, create: BookEpisodeCreateInput!, update: BookEpisodeUpdateInput!): BookEpisode!
  deleteBookEpisode(where: BookEpisodeWhereUniqueInput!): BookEpisode
  deleteManyBookEpisodes(where: BookEpisodeWhereInput): BatchPayload!
  createBookEpisodeContent(data: BookEpisodeContentCreateInput!): BookEpisodeContent!
  updateBookEpisodeContent(data: BookEpisodeContentUpdateInput!, where: BookEpisodeContentWhereUniqueInput!): BookEpisodeContent
  updateManyBookEpisodeContents(data: BookEpisodeContentUpdateManyMutationInput!, where: BookEpisodeContentWhereInput): BatchPayload!
  upsertBookEpisodeContent(where: BookEpisodeContentWhereUniqueInput!, create: BookEpisodeContentCreateInput!, update: BookEpisodeContentUpdateInput!): BookEpisodeContent!
  deleteBookEpisodeContent(where: BookEpisodeContentWhereUniqueInput!): BookEpisodeContent
  deleteManyBookEpisodeContents(where: BookEpisodeContentWhereInput): BatchPayload!
  createBookEpisodeRecentRead(data: BookEpisodeRecentReadCreateInput!): BookEpisodeRecentRead!
  updateBookEpisodeRecentRead(data: BookEpisodeRecentReadUpdateInput!, where: BookEpisodeRecentReadWhereUniqueInput!): BookEpisodeRecentRead
  updateManyBookEpisodeRecentReads(data: BookEpisodeRecentReadUpdateManyMutationInput!, where: BookEpisodeRecentReadWhereInput): BatchPayload!
  upsertBookEpisodeRecentRead(where: BookEpisodeRecentReadWhereUniqueInput!, create: BookEpisodeRecentReadCreateInput!, update: BookEpisodeRecentReadUpdateInput!): BookEpisodeRecentRead!
  deleteBookEpisodeRecentRead(where: BookEpisodeRecentReadWhereUniqueInput!): BookEpisodeRecentRead
  deleteManyBookEpisodeRecentReads(where: BookEpisodeRecentReadWhereInput): BatchPayload!
  createBookEpisodeReviewPost(data: BookEpisodeReviewPostCreateInput!): BookEpisodeReviewPost!
  updateBookEpisodeReviewPost(data: BookEpisodeReviewPostUpdateInput!, where: BookEpisodeReviewPostWhereUniqueInput!): BookEpisodeReviewPost
  updateManyBookEpisodeReviewPosts(data: BookEpisodeReviewPostUpdateManyMutationInput!, where: BookEpisodeReviewPostWhereInput): BatchPayload!
  upsertBookEpisodeReviewPost(where: BookEpisodeReviewPostWhereUniqueInput!, create: BookEpisodeReviewPostCreateInput!, update: BookEpisodeReviewPostUpdateInput!): BookEpisodeReviewPost!
  deleteBookEpisodeReviewPost(where: BookEpisodeReviewPostWhereUniqueInput!): BookEpisodeReviewPost
  deleteManyBookEpisodeReviewPosts(where: BookEpisodeReviewPostWhereInput): BatchPayload!
  createBookRecommended(data: BookRecommendedCreateInput!): BookRecommended!
  updateBookRecommended(data: BookRecommendedUpdateInput!, where: BookRecommendedWhereUniqueInput!): BookRecommended
  updateManyBookRecommendeds(data: BookRecommendedUpdateManyMutationInput!, where: BookRecommendedWhereInput): BatchPayload!
  upsertBookRecommended(where: BookRecommendedWhereUniqueInput!, create: BookRecommendedCreateInput!, update: BookRecommendedUpdateInput!): BookRecommended!
  deleteBookRecommended(where: BookRecommendedWhereUniqueInput!): BookRecommended
  deleteManyBookRecommendeds(where: BookRecommendedWhereInput): BatchPayload!
  createBookVolume(data: BookVolumeCreateInput!): BookVolume!
  updateBookVolume(data: BookVolumeUpdateInput!, where: BookVolumeWhereUniqueInput!): BookVolume
  updateManyBookVolumes(data: BookVolumeUpdateManyMutationInput!, where: BookVolumeWhereInput): BatchPayload!
  upsertBookVolume(where: BookVolumeWhereUniqueInput!, create: BookVolumeCreateInput!, update: BookVolumeUpdateInput!): BookVolume!
  deleteBookVolume(where: BookVolumeWhereUniqueInput!): BookVolume
  deleteManyBookVolumes(where: BookVolumeWhereInput): BatchPayload!
  createCategory(data: CategoryCreateInput!): Category!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateManyCategories(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  upsertCategory(where: CategoryWhereUniqueInput!, create: CategoryCreateInput!, update: CategoryUpdateInput!): Category!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteManyCategories(where: CategoryWhereInput): BatchPayload!
  createCopyrightHolder(data: CopyrightHolderCreateInput!): CopyrightHolder!
  updateCopyrightHolder(data: CopyrightHolderUpdateInput!, where: CopyrightHolderWhereUniqueInput!): CopyrightHolder
  updateManyCopyrightHolders(data: CopyrightHolderUpdateManyMutationInput!, where: CopyrightHolderWhereInput): BatchPayload!
  upsertCopyrightHolder(where: CopyrightHolderWhereUniqueInput!, create: CopyrightHolderCreateInput!, update: CopyrightHolderUpdateInput!): CopyrightHolder!
  deleteCopyrightHolder(where: CopyrightHolderWhereUniqueInput!): CopyrightHolder
  deleteManyCopyrightHolders(where: CopyrightHolderWhereInput): BatchPayload!
  createDashbardDataCache(data: DashbardDataCacheCreateInput!): DashbardDataCache!
  updateManyDashbardDataCaches(data: DashbardDataCacheUpdateManyMutationInput!, where: DashbardDataCacheWhereInput): BatchPayload!
  deleteManyDashbardDataCaches(where: DashbardDataCacheWhereInput): BatchPayload!
  createDocument(data: DocumentCreateInput!): Document!
  updateDocument(data: DocumentUpdateInput!, where: DocumentWhereUniqueInput!): Document
  updateManyDocuments(data: DocumentUpdateManyMutationInput!, where: DocumentWhereInput): BatchPayload!
  upsertDocument(where: DocumentWhereUniqueInput!, create: DocumentCreateInput!, update: DocumentUpdateInput!): Document!
  deleteDocument(where: DocumentWhereUniqueInput!): Document
  deleteManyDocuments(where: DocumentWhereInput): BatchPayload!
  createExchangeTier(data: ExchangeTierCreateInput!): ExchangeTier!
  updateExchangeTier(data: ExchangeTierUpdateInput!, where: ExchangeTierWhereUniqueInput!): ExchangeTier
  updateManyExchangeTiers(data: ExchangeTierUpdateManyMutationInput!, where: ExchangeTierWhereInput): BatchPayload!
  upsertExchangeTier(where: ExchangeTierWhereUniqueInput!, create: ExchangeTierCreateInput!, update: ExchangeTierUpdateInput!): ExchangeTier!
  deleteExchangeTier(where: ExchangeTierWhereUniqueInput!): ExchangeTier
  deleteManyExchangeTiers(where: ExchangeTierWhereInput): BatchPayload!
  createExchangeTransaction(data: ExchangeTransactionCreateInput!): ExchangeTransaction!
  updateExchangeTransaction(data: ExchangeTransactionUpdateInput!, where: ExchangeTransactionWhereUniqueInput!): ExchangeTransaction
  updateManyExchangeTransactions(data: ExchangeTransactionUpdateManyMutationInput!, where: ExchangeTransactionWhereInput): BatchPayload!
  upsertExchangeTransaction(where: ExchangeTransactionWhereUniqueInput!, create: ExchangeTransactionCreateInput!, update: ExchangeTransactionUpdateInput!): ExchangeTransaction!
  deleteExchangeTransaction(where: ExchangeTransactionWhereUniqueInput!): ExchangeTransaction
  deleteManyExchangeTransactions(where: ExchangeTransactionWhereInput): BatchPayload!
  createExchangeTransactionStatusHistory(data: ExchangeTransactionStatusHistoryCreateInput!): ExchangeTransactionStatusHistory!
  updateExchangeTransactionStatusHistory(data: ExchangeTransactionStatusHistoryUpdateInput!, where: ExchangeTransactionStatusHistoryWhereUniqueInput!): ExchangeTransactionStatusHistory
  updateManyExchangeTransactionStatusHistories(data: ExchangeTransactionStatusHistoryUpdateManyMutationInput!, where: ExchangeTransactionStatusHistoryWhereInput): BatchPayload!
  upsertExchangeTransactionStatusHistory(where: ExchangeTransactionStatusHistoryWhereUniqueInput!, create: ExchangeTransactionStatusHistoryCreateInput!, update: ExchangeTransactionStatusHistoryUpdateInput!): ExchangeTransactionStatusHistory!
  deleteExchangeTransactionStatusHistory(where: ExchangeTransactionStatusHistoryWhereUniqueInput!): ExchangeTransactionStatusHistory
  deleteManyExchangeTransactionStatusHistories(where: ExchangeTransactionStatusHistoryWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createHistory(data: HistoryCreateInput!): History!
  updateHistory(data: HistoryUpdateInput!, where: HistoryWhereUniqueInput!): History
  updateManyHistories(data: HistoryUpdateManyMutationInput!, where: HistoryWhereInput): BatchPayload!
  upsertHistory(where: HistoryWhereUniqueInput!, create: HistoryCreateInput!, update: HistoryUpdateInput!): History!
  deleteHistory(where: HistoryWhereUniqueInput!): History
  deleteManyHistories(where: HistoryWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createItemAsset(data: ItemAssetCreateInput!): ItemAsset!
  updateItemAsset(data: ItemAssetUpdateInput!, where: ItemAssetWhereUniqueInput!): ItemAsset
  updateManyItemAssets(data: ItemAssetUpdateManyMutationInput!, where: ItemAssetWhereInput): BatchPayload!
  upsertItemAsset(where: ItemAssetWhereUniqueInput!, create: ItemAssetCreateInput!, update: ItemAssetUpdateInput!): ItemAsset!
  deleteItemAsset(where: ItemAssetWhereUniqueInput!): ItemAsset
  deleteManyItemAssets(where: ItemAssetWhereInput): BatchPayload!
  createMigration(data: MigrationCreateInput!): Migration!
  updateMigration(data: MigrationUpdateInput!, where: MigrationWhereUniqueInput!): Migration
  updateManyMigrations(data: MigrationUpdateManyMutationInput!, where: MigrationWhereInput): BatchPayload!
  upsertMigration(where: MigrationWhereUniqueInput!, create: MigrationCreateInput!, update: MigrationUpdateInput!): Migration!
  deleteMigration(where: MigrationWhereUniqueInput!): Migration
  deleteManyMigrations(where: MigrationWhereInput): BatchPayload!
  createPageView(data: PageViewCreateInput!): PageView!
  updatePageView(data: PageViewUpdateInput!, where: PageViewWhereUniqueInput!): PageView
  updateManyPageViews(data: PageViewUpdateManyMutationInput!, where: PageViewWhereInput): BatchPayload!
  upsertPageView(where: PageViewWhereUniqueInput!, create: PageViewCreateInput!, update: PageViewUpdateInput!): PageView!
  deletePageView(where: PageViewWhereUniqueInput!): PageView
  deleteManyPageViews(where: PageViewWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createPrice(data: PriceCreateInput!): Price!
  updatePrice(data: PriceUpdateInput!, where: PriceWhereUniqueInput!): Price
  updateManyPrices(data: PriceUpdateManyMutationInput!, where: PriceWhereInput): BatchPayload!
  upsertPrice(where: PriceWhereUniqueInput!, create: PriceCreateInput!, update: PriceUpdateInput!): Price!
  deletePrice(where: PriceWhereUniqueInput!): Price
  deleteManyPrices(where: PriceWhereInput): BatchPayload!
  createPromotion(data: PromotionCreateInput!): Promotion!
  updatePromotion(data: PromotionUpdateInput!, where: PromotionWhereUniqueInput!): Promotion
  updateManyPromotions(data: PromotionUpdateManyMutationInput!, where: PromotionWhereInput): BatchPayload!
  upsertPromotion(where: PromotionWhereUniqueInput!, create: PromotionCreateInput!, update: PromotionUpdateInput!): Promotion!
  deletePromotion(where: PromotionWhereUniqueInput!): Promotion
  deleteManyPromotions(where: PromotionWhereInput): BatchPayload!
  createPublishTimeline(data: PublishTimelineCreateInput!): PublishTimeline!
  updateManyPublishTimelines(data: PublishTimelineUpdateManyMutationInput!, where: PublishTimelineWhereInput): BatchPayload!
  deleteManyPublishTimelines(where: PublishTimelineWhereInput): BatchPayload!
  createRemoteConfig(data: RemoteConfigCreateInput!): RemoteConfig!
  updateRemoteConfig(data: RemoteConfigUpdateInput!, where: RemoteConfigWhereUniqueInput!): RemoteConfig
  updateManyRemoteConfigs(data: RemoteConfigUpdateManyMutationInput!, where: RemoteConfigWhereInput): BatchPayload!
  upsertRemoteConfig(where: RemoteConfigWhereUniqueInput!, create: RemoteConfigCreateInput!, update: RemoteConfigUpdateInput!): RemoteConfig!
  deleteRemoteConfig(where: RemoteConfigWhereUniqueInput!): RemoteConfig
  deleteManyRemoteConfigs(where: RemoteConfigWhereInput): BatchPayload!
  createRevenueSharing(data: RevenueSharingCreateInput!): RevenueSharing!
  updateRevenueSharing(data: RevenueSharingUpdateInput!, where: RevenueSharingWhereUniqueInput!): RevenueSharing
  updateManyRevenueSharings(data: RevenueSharingUpdateManyMutationInput!, where: RevenueSharingWhereInput): BatchPayload!
  upsertRevenueSharing(where: RevenueSharingWhereUniqueInput!, create: RevenueSharingCreateInput!, update: RevenueSharingUpdateInput!): RevenueSharing!
  deleteRevenueSharing(where: RevenueSharingWhereUniqueInput!): RevenueSharing
  deleteManyRevenueSharings(where: RevenueSharingWhereInput): BatchPayload!
  createShelf(data: ShelfCreateInput!): Shelf!
  updateShelf(data: ShelfUpdateInput!, where: ShelfWhereUniqueInput!): Shelf
  updateManyShelves(data: ShelfUpdateManyMutationInput!, where: ShelfWhereInput): BatchPayload!
  upsertShelf(where: ShelfWhereUniqueInput!, create: ShelfCreateInput!, update: ShelfUpdateInput!): Shelf!
  deleteShelf(where: ShelfWhereUniqueInput!): Shelf
  deleteManyShelves(where: ShelfWhereInput): BatchPayload!
  createSystemConfig(data: SystemConfigCreateInput!): SystemConfig!
  updateSystemConfig(data: SystemConfigUpdateInput!, where: SystemConfigWhereUniqueInput!): SystemConfig
  updateManySystemConfigs(data: SystemConfigUpdateManyMutationInput!, where: SystemConfigWhereInput): BatchPayload!
  upsertSystemConfig(where: SystemConfigWhereUniqueInput!, create: SystemConfigCreateInput!, update: SystemConfigUpdateInput!): SystemConfig!
  deleteSystemConfig(where: SystemConfigWhereUniqueInput!): SystemConfig
  deleteManySystemConfigs(where: SystemConfigWhereInput): BatchPayload!
  createTransaction(data: TransactionCreateInput!): Transaction!
  updateTransaction(data: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction
  updateManyTransactions(data: TransactionUpdateManyMutationInput!, where: TransactionWhereInput): BatchPayload!
  upsertTransaction(where: TransactionWhereUniqueInput!, create: TransactionCreateInput!, update: TransactionUpdateInput!): Transaction!
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction
  deleteManyTransactions(where: TransactionWhereInput): BatchPayload!
  createTranslator(data: TranslatorCreateInput!): Translator!
  updateTranslator(data: TranslatorUpdateInput!, where: TranslatorWhereUniqueInput!): Translator
  updateManyTranslators(data: TranslatorUpdateManyMutationInput!, where: TranslatorWhereInput): BatchPayload!
  upsertTranslator(where: TranslatorWhereUniqueInput!, create: TranslatorCreateInput!, update: TranslatorUpdateInput!): Translator!
  deleteTranslator(where: TranslatorWhereUniqueInput!): Translator
  deleteManyTranslators(where: TranslatorWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserAdmin(data: UserAdminCreateInput!): UserAdmin!
  updateUserAdmin(data: UserAdminUpdateInput!, where: UserAdminWhereUniqueInput!): UserAdmin
  updateManyUserAdmins(data: UserAdminUpdateManyMutationInput!, where: UserAdminWhereInput): BatchPayload!
  upsertUserAdmin(where: UserAdminWhereUniqueInput!, create: UserAdminCreateInput!, update: UserAdminUpdateInput!): UserAdmin!
  deleteUserAdmin(where: UserAdminWhereUniqueInput!): UserAdmin
  deleteManyUserAdmins(where: UserAdminWhereInput): BatchPayload!
  createUserAdminPermission(data: UserAdminPermissionCreateInput!): UserAdminPermission!
  updateUserAdminPermission(data: UserAdminPermissionUpdateInput!, where: UserAdminPermissionWhereUniqueInput!): UserAdminPermission
  updateManyUserAdminPermissions(data: UserAdminPermissionUpdateManyMutationInput!, where: UserAdminPermissionWhereInput): BatchPayload!
  upsertUserAdminPermission(where: UserAdminPermissionWhereUniqueInput!, create: UserAdminPermissionCreateInput!, update: UserAdminPermissionUpdateInput!): UserAdminPermission!
  deleteUserAdminPermission(where: UserAdminPermissionWhereUniqueInput!): UserAdminPermission
  deleteManyUserAdminPermissions(where: UserAdminPermissionWhereInput): BatchPayload!
  createUserAdminRole(data: UserAdminRoleCreateInput!): UserAdminRole!
  updateUserAdminRole(data: UserAdminRoleUpdateInput!, where: UserAdminRoleWhereUniqueInput!): UserAdminRole
  updateManyUserAdminRoles(data: UserAdminRoleUpdateManyMutationInput!, where: UserAdminRoleWhereInput): BatchPayload!
  upsertUserAdminRole(where: UserAdminRoleWhereUniqueInput!, create: UserAdminRoleCreateInput!, update: UserAdminRoleUpdateInput!): UserAdminRole!
  deleteUserAdminRole(where: UserAdminRoleWhereUniqueInput!): UserAdminRole
  deleteManyUserAdminRoles(where: UserAdminRoleWhereInput): BatchPayload!
  createVendor(data: VendorCreateInput!): Vendor!
  updateVendor(data: VendorUpdateInput!, where: VendorWhereUniqueInput!): Vendor
  updateManyVendors(data: VendorUpdateManyMutationInput!, where: VendorWhereInput): BatchPayload!
  upsertVendor(where: VendorWhereUniqueInput!, create: VendorCreateInput!, update: VendorUpdateInput!): Vendor!
  deleteVendor(where: VendorWhereUniqueInput!): Vendor
  deleteManyVendors(where: VendorWhereInput): BatchPayload!
  createVendorBillingInformation(data: VendorBillingInformationCreateInput!): VendorBillingInformation!
  updateVendorBillingInformation(data: VendorBillingInformationUpdateInput!, where: VendorBillingInformationWhereUniqueInput!): VendorBillingInformation
  updateManyVendorBillingInformations(data: VendorBillingInformationUpdateManyMutationInput!, where: VendorBillingInformationWhereInput): BatchPayload!
  upsertVendorBillingInformation(where: VendorBillingInformationWhereUniqueInput!, create: VendorBillingInformationCreateInput!, update: VendorBillingInformationUpdateInput!): VendorBillingInformation!
  deleteVendorBillingInformation(where: VendorBillingInformationWhereUniqueInput!): VendorBillingInformation
  deleteManyVendorBillingInformations(where: VendorBillingInformationWhereInput): BatchPayload!
  createVendorRevenue(data: VendorRevenueCreateInput!): VendorRevenue!
  updateVendorRevenue(data: VendorRevenueUpdateInput!, where: VendorRevenueWhereUniqueInput!): VendorRevenue
  updateManyVendorRevenues(data: VendorRevenueUpdateManyMutationInput!, where: VendorRevenueWhereInput): BatchPayload!
  upsertVendorRevenue(where: VendorRevenueWhereUniqueInput!, create: VendorRevenueCreateInput!, update: VendorRevenueUpdateInput!): VendorRevenue!
  deleteVendorRevenue(where: VendorRevenueWhereUniqueInput!): VendorRevenue
  deleteManyVendorRevenues(where: VendorRevenueWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PageView {
  id: ID!
  episode: BookEpisode!
  count: Int!
  updatedAt: DateTime!
}

type PageViewConnection {
  pageInfo: PageInfo!
  edges: [PageViewEdge]!
  aggregate: AggregatePageView!
}

input PageViewCreateInput {
  episode: BookEpisodeCreateOneWithoutPageViewInput!
  count: Int
}

input PageViewCreateOneWithoutEpisodeInput {
  create: PageViewCreateWithoutEpisodeInput
  connect: PageViewWhereUniqueInput
}

input PageViewCreateWithoutEpisodeInput {
  count: Int
}

type PageViewEdge {
  node: PageView!
  cursor: String!
}

enum PageViewOrderByInput {
  id_ASC
  id_DESC
  count_ASC
  count_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PageViewPreviousValues {
  id: ID!
  count: Int!
  updatedAt: DateTime!
}

type PageViewSubscriptionPayload {
  mutation: MutationType!
  node: PageView
  updatedFields: [String!]
  previousValues: PageViewPreviousValues
}

input PageViewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PageViewWhereInput
  AND: [PageViewSubscriptionWhereInput!]
  OR: [PageViewSubscriptionWhereInput!]
  NOT: [PageViewSubscriptionWhereInput!]
}

input PageViewUpdateInput {
  episode: BookEpisodeUpdateOneRequiredWithoutPageViewInput
  count: Int
}

input PageViewUpdateManyMutationInput {
  count: Int
}

input PageViewUpdateOneWithoutEpisodeInput {
  create: PageViewCreateWithoutEpisodeInput
  update: PageViewUpdateWithoutEpisodeDataInput
  upsert: PageViewUpsertWithoutEpisodeInput
  delete: Boolean
  disconnect: Boolean
  connect: PageViewWhereUniqueInput
}

input PageViewUpdateWithoutEpisodeDataInput {
  count: Int
}

input PageViewUpsertWithoutEpisodeInput {
  update: PageViewUpdateWithoutEpisodeDataInput!
  create: PageViewCreateWithoutEpisodeInput!
}

input PageViewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  episode: BookEpisodeWhereInput
  count: Int
  count_not: Int
  count_in: [Int!]
  count_not_in: [Int!]
  count_lt: Int
  count_lte: Int
  count_gt: Int
  count_gte: Int
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PageViewWhereInput!]
  OR: [PageViewWhereInput!]
  NOT: [PageViewWhereInput!]
}

input PageViewWhereUniqueInput {
  id: ID
}

type Post {
  type: PostType!
  id: ID!
  user: User!
  message: String!
  status: ReviewPostStatus
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  type: PostType!
  user: UserCreateOneInput!
  message: String!
  status: ReviewPostStatus
}

input PostCreateOneInput {
  create: PostCreateInput
  connect: PostWhereUniqueInput
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  type_ASC
  type_DESC
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PostPreviousValues {
  type: PostType!
  id: ID!
  message: String!
  status: ReviewPostStatus
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

enum PostType {
  BookEpisodeReview
}

input PostUpdateDataInput {
  type: PostType
  user: UserUpdateOneRequiredInput
  message: String
  status: ReviewPostStatus
}

input PostUpdateInput {
  type: PostType
  user: UserUpdateOneRequiredInput
  message: String
  status: ReviewPostStatus
}

input PostUpdateManyMutationInput {
  type: PostType
  message: String
  status: ReviewPostStatus
}

input PostUpdateOneRequiredInput {
  create: PostCreateInput
  update: PostUpdateDataInput
  upsert: PostUpsertNestedInput
  connect: PostWhereUniqueInput
}

input PostUpsertNestedInput {
  update: PostUpdateDataInput!
  create: PostCreateInput!
}

input PostWhereInput {
  type: PostType
  type_not: PostType
  type_in: [PostType!]
  type_not_in: [PostType!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  status: ReviewPostStatus
  status_not: ReviewPostStatus
  status_in: [ReviewPostStatus!]
  status_not_in: [ReviewPostStatus!]
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Price {
  id: ID!
  currencyType: CurrencyType!
  amount: Float!
  archiveAt: DateTime
}

type PriceConnection {
  pageInfo: PageInfo!
  edges: [PriceEdge]!
  aggregate: AggregatePrice!
}

input PriceCreateInput {
  currencyType: CurrencyType!
  amount: Float!
  archiveAt: DateTime
}

input PriceCreateManyInput {
  create: [PriceCreateInput!]
  connect: [PriceWhereUniqueInput!]
}

type PriceEdge {
  node: Price!
  cursor: String!
}

enum PriceOrderByInput {
  id_ASC
  id_DESC
  currencyType_ASC
  currencyType_DESC
  amount_ASC
  amount_DESC
  archiveAt_ASC
  archiveAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PricePreviousValues {
  id: ID!
  currencyType: CurrencyType!
  amount: Float!
  archiveAt: DateTime
}

input PriceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  currencyType: CurrencyType
  currencyType_not: CurrencyType
  currencyType_in: [CurrencyType!]
  currencyType_not_in: [CurrencyType!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  archiveAt: DateTime
  archiveAt_not: DateTime
  archiveAt_in: [DateTime!]
  archiveAt_not_in: [DateTime!]
  archiveAt_lt: DateTime
  archiveAt_lte: DateTime
  archiveAt_gt: DateTime
  archiveAt_gte: DateTime
  AND: [PriceScalarWhereInput!]
  OR: [PriceScalarWhereInput!]
  NOT: [PriceScalarWhereInput!]
}

type PriceSubscriptionPayload {
  mutation: MutationType!
  node: Price
  updatedFields: [String!]
  previousValues: PricePreviousValues
}

input PriceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PriceWhereInput
  AND: [PriceSubscriptionWhereInput!]
  OR: [PriceSubscriptionWhereInput!]
  NOT: [PriceSubscriptionWhereInput!]
}

input PriceUpdateDataInput {
  currencyType: CurrencyType
  amount: Float
  archiveAt: DateTime
}

input PriceUpdateInput {
  currencyType: CurrencyType
  amount: Float
  archiveAt: DateTime
}

input PriceUpdateManyDataInput {
  currencyType: CurrencyType
  amount: Float
  archiveAt: DateTime
}

input PriceUpdateManyInput {
  create: [PriceCreateInput!]
  update: [PriceUpdateWithWhereUniqueNestedInput!]
  upsert: [PriceUpsertWithWhereUniqueNestedInput!]
  delete: [PriceWhereUniqueInput!]
  connect: [PriceWhereUniqueInput!]
  set: [PriceWhereUniqueInput!]
  disconnect: [PriceWhereUniqueInput!]
  deleteMany: [PriceScalarWhereInput!]
  updateMany: [PriceUpdateManyWithWhereNestedInput!]
}

input PriceUpdateManyMutationInput {
  currencyType: CurrencyType
  amount: Float
  archiveAt: DateTime
}

input PriceUpdateManyWithWhereNestedInput {
  where: PriceScalarWhereInput!
  data: PriceUpdateManyDataInput!
}

input PriceUpdateWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput!
  data: PriceUpdateDataInput!
}

input PriceUpsertWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput!
  update: PriceUpdateDataInput!
  create: PriceCreateInput!
}

input PriceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  currencyType: CurrencyType
  currencyType_not: CurrencyType
  currencyType_in: [CurrencyType!]
  currencyType_not_in: [CurrencyType!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  archiveAt: DateTime
  archiveAt_not: DateTime
  archiveAt_in: [DateTime!]
  archiveAt_not_in: [DateTime!]
  archiveAt_lt: DateTime
  archiveAt_lte: DateTime
  archiveAt_gt: DateTime
  archiveAt_gte: DateTime
  AND: [PriceWhereInput!]
  OR: [PriceWhereInput!]
  NOT: [PriceWhereInput!]
}

input PriceWhereUniqueInput {
  id: ID
}

type Promotion {
  id: ID!
  name: String!
  unit: PromotionUnit!
  type: PromotionType!
  amount: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PromotionConnection {
  pageInfo: PageInfo!
  edges: [PromotionEdge]!
  aggregate: AggregatePromotion!
}

input PromotionCreateInput {
  name: String!
  unit: PromotionUnit!
  type: PromotionType!
  amount: Float!
}

input PromotionCreateManyInput {
  create: [PromotionCreateInput!]
  connect: [PromotionWhereUniqueInput!]
}

type PromotionEdge {
  node: Promotion!
  cursor: String!
}

enum PromotionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  unit_ASC
  unit_DESC
  type_ASC
  type_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PromotionPreviousValues {
  id: ID!
  name: String!
  unit: PromotionUnit!
  type: PromotionType!
  amount: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PromotionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  unit: PromotionUnit
  unit_not: PromotionUnit
  unit_in: [PromotionUnit!]
  unit_not_in: [PromotionUnit!]
  type: PromotionType
  type_not: PromotionType
  type_in: [PromotionType!]
  type_not_in: [PromotionType!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PromotionScalarWhereInput!]
  OR: [PromotionScalarWhereInput!]
  NOT: [PromotionScalarWhereInput!]
}

type PromotionSubscriptionPayload {
  mutation: MutationType!
  node: Promotion
  updatedFields: [String!]
  previousValues: PromotionPreviousValues
}

input PromotionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PromotionWhereInput
  AND: [PromotionSubscriptionWhereInput!]
  OR: [PromotionSubscriptionWhereInput!]
  NOT: [PromotionSubscriptionWhereInput!]
}

enum PromotionType {
  TopUp
  Discount
}

enum PromotionUnit {
  Percent
  Baht
  Reeeed
}

input PromotionUpdateDataInput {
  name: String
  unit: PromotionUnit
  type: PromotionType
  amount: Float
}

input PromotionUpdateInput {
  name: String
  unit: PromotionUnit
  type: PromotionType
  amount: Float
}

input PromotionUpdateManyDataInput {
  name: String
  unit: PromotionUnit
  type: PromotionType
  amount: Float
}

input PromotionUpdateManyInput {
  create: [PromotionCreateInput!]
  update: [PromotionUpdateWithWhereUniqueNestedInput!]
  upsert: [PromotionUpsertWithWhereUniqueNestedInput!]
  delete: [PromotionWhereUniqueInput!]
  connect: [PromotionWhereUniqueInput!]
  set: [PromotionWhereUniqueInput!]
  disconnect: [PromotionWhereUniqueInput!]
  deleteMany: [PromotionScalarWhereInput!]
  updateMany: [PromotionUpdateManyWithWhereNestedInput!]
}

input PromotionUpdateManyMutationInput {
  name: String
  unit: PromotionUnit
  type: PromotionType
  amount: Float
}

input PromotionUpdateManyWithWhereNestedInput {
  where: PromotionScalarWhereInput!
  data: PromotionUpdateManyDataInput!
}

input PromotionUpdateWithWhereUniqueNestedInput {
  where: PromotionWhereUniqueInput!
  data: PromotionUpdateDataInput!
}

input PromotionUpsertWithWhereUniqueNestedInput {
  where: PromotionWhereUniqueInput!
  update: PromotionUpdateDataInput!
  create: PromotionCreateInput!
}

input PromotionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  unit: PromotionUnit
  unit_not: PromotionUnit
  unit_in: [PromotionUnit!]
  unit_not_in: [PromotionUnit!]
  type: PromotionType
  type_not: PromotionType
  type_in: [PromotionType!]
  type_not_in: [PromotionType!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PromotionWhereInput!]
  OR: [PromotionWhereInput!]
  NOT: [PromotionWhereInput!]
}

input PromotionWhereUniqueInput {
  id: ID
}

type PublishTimeline {
  startAt: DateTime!
  endAt: DateTime
}

type PublishTimelineConnection {
  pageInfo: PageInfo!
  edges: [PublishTimelineEdge]!
  aggregate: AggregatePublishTimeline!
}

input PublishTimelineCreateInput {
  startAt: DateTime!
  endAt: DateTime
}

input PublishTimelineCreateOneInput {
  create: PublishTimelineCreateInput
}

type PublishTimelineEdge {
  node: PublishTimeline!
  cursor: String!
}

enum PublishTimelineOrderByInput {
  startAt_ASC
  startAt_DESC
  endAt_ASC
  endAt_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PublishTimelinePreviousValues {
  startAt: DateTime!
  endAt: DateTime
}

type PublishTimelineSubscriptionPayload {
  mutation: MutationType!
  node: PublishTimeline
  updatedFields: [String!]
  previousValues: PublishTimelinePreviousValues
}

input PublishTimelineSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PublishTimelineWhereInput
  AND: [PublishTimelineSubscriptionWhereInput!]
  OR: [PublishTimelineSubscriptionWhereInput!]
  NOT: [PublishTimelineSubscriptionWhereInput!]
}

input PublishTimelineUpdateDataInput {
  startAt: DateTime
  endAt: DateTime
}

input PublishTimelineUpdateManyMutationInput {
  startAt: DateTime
  endAt: DateTime
}

input PublishTimelineUpdateOneInput {
  create: PublishTimelineCreateInput
  update: PublishTimelineUpdateDataInput
  upsert: PublishTimelineUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input PublishTimelineUpsertNestedInput {
  update: PublishTimelineUpdateDataInput!
  create: PublishTimelineCreateInput!
}

input PublishTimelineWhereInput {
  startAt: DateTime
  startAt_not: DateTime
  startAt_in: [DateTime!]
  startAt_not_in: [DateTime!]
  startAt_lt: DateTime
  startAt_lte: DateTime
  startAt_gt: DateTime
  startAt_gte: DateTime
  endAt: DateTime
  endAt_not: DateTime
  endAt_in: [DateTime!]
  endAt_not_in: [DateTime!]
  endAt_lt: DateTime
  endAt_lte: DateTime
  endAt_gt: DateTime
  endAt_gte: DateTime
  AND: [PublishTimelineWhereInput!]
  OR: [PublishTimelineWhereInput!]
  NOT: [PublishTimelineWhereInput!]
}

type Query {
  adsBanner(where: AdsBannerWhereUniqueInput!): AdsBanner
  adsBanners(where: AdsBannerWhereInput, orderBy: AdsBannerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AdsBanner]!
  adsBannersConnection(where: AdsBannerWhereInput, orderBy: AdsBannerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AdsBannerConnection!
  author(where: AuthorWhereUniqueInput!): Author
  authors(where: AuthorWhereInput, orderBy: AuthorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Author]!
  authorsConnection(where: AuthorWhereInput, orderBy: AuthorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AuthorConnection!
  behavior(where: BehaviorWhereUniqueInput!): Behavior
  behaviors(where: BehaviorWhereInput, orderBy: BehaviorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Behavior]!
  behaviorsConnection(where: BehaviorWhereInput, orderBy: BehaviorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BehaviorConnection!
  book(where: BookWhereUniqueInput!): Book
  books(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Book]!
  booksConnection(where: BookWhereInput, orderBy: BookOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookConnection!
  bookEpisode(where: BookEpisodeWhereUniqueInput!): BookEpisode
  bookEpisodes(where: BookEpisodeWhereInput, orderBy: BookEpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookEpisode]!
  bookEpisodesConnection(where: BookEpisodeWhereInput, orderBy: BookEpisodeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookEpisodeConnection!
  bookEpisodeContent(where: BookEpisodeContentWhereUniqueInput!): BookEpisodeContent
  bookEpisodeContents(where: BookEpisodeContentWhereInput, orderBy: BookEpisodeContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookEpisodeContent]!
  bookEpisodeContentsConnection(where: BookEpisodeContentWhereInput, orderBy: BookEpisodeContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookEpisodeContentConnection!
  bookEpisodeRecentRead(where: BookEpisodeRecentReadWhereUniqueInput!): BookEpisodeRecentRead
  bookEpisodeRecentReads(where: BookEpisodeRecentReadWhereInput, orderBy: BookEpisodeRecentReadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookEpisodeRecentRead]!
  bookEpisodeRecentReadsConnection(where: BookEpisodeRecentReadWhereInput, orderBy: BookEpisodeRecentReadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookEpisodeRecentReadConnection!
  bookEpisodeReviewPost(where: BookEpisodeReviewPostWhereUniqueInput!): BookEpisodeReviewPost
  bookEpisodeReviewPosts(where: BookEpisodeReviewPostWhereInput, orderBy: BookEpisodeReviewPostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookEpisodeReviewPost]!
  bookEpisodeReviewPostsConnection(where: BookEpisodeReviewPostWhereInput, orderBy: BookEpisodeReviewPostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookEpisodeReviewPostConnection!
  bookRecommended(where: BookRecommendedWhereUniqueInput!): BookRecommended
  bookRecommendeds(where: BookRecommendedWhereInput, orderBy: BookRecommendedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookRecommended]!
  bookRecommendedsConnection(where: BookRecommendedWhereInput, orderBy: BookRecommendedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookRecommendedConnection!
  bookVolume(where: BookVolumeWhereUniqueInput!): BookVolume
  bookVolumes(where: BookVolumeWhereInput, orderBy: BookVolumeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookVolume]!
  bookVolumesConnection(where: BookVolumeWhereInput, orderBy: BookVolumeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookVolumeConnection!
  category(where: CategoryWhereUniqueInput!): Category
  categories(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Category]!
  categoriesConnection(where: CategoryWhereInput, orderBy: CategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CategoryConnection!
  copyrightHolder(where: CopyrightHolderWhereUniqueInput!): CopyrightHolder
  copyrightHolders(where: CopyrightHolderWhereInput, orderBy: CopyrightHolderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CopyrightHolder]!
  copyrightHoldersConnection(where: CopyrightHolderWhereInput, orderBy: CopyrightHolderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CopyrightHolderConnection!
  dashbardDataCaches(where: DashbardDataCacheWhereInput, orderBy: DashbardDataCacheOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DashbardDataCache]!
  dashbardDataCachesConnection(where: DashbardDataCacheWhereInput, orderBy: DashbardDataCacheOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DashbardDataCacheConnection!
  document(where: DocumentWhereUniqueInput!): Document
  documents(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Document]!
  documentsConnection(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DocumentConnection!
  exchangeTier(where: ExchangeTierWhereUniqueInput!): ExchangeTier
  exchangeTiers(where: ExchangeTierWhereInput, orderBy: ExchangeTierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExchangeTier]!
  exchangeTiersConnection(where: ExchangeTierWhereInput, orderBy: ExchangeTierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExchangeTierConnection!
  exchangeTransaction(where: ExchangeTransactionWhereUniqueInput!): ExchangeTransaction
  exchangeTransactions(where: ExchangeTransactionWhereInput, orderBy: ExchangeTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExchangeTransaction]!
  exchangeTransactionsConnection(where: ExchangeTransactionWhereInput, orderBy: ExchangeTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExchangeTransactionConnection!
  exchangeTransactionStatusHistory(where: ExchangeTransactionStatusHistoryWhereUniqueInput!): ExchangeTransactionStatusHistory
  exchangeTransactionStatusHistories(where: ExchangeTransactionStatusHistoryWhereInput, orderBy: ExchangeTransactionStatusHistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExchangeTransactionStatusHistory]!
  exchangeTransactionStatusHistoriesConnection(where: ExchangeTransactionStatusHistoryWhereInput, orderBy: ExchangeTransactionStatusHistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExchangeTransactionStatusHistoryConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  history(where: HistoryWhereUniqueInput!): History
  histories(where: HistoryWhereInput, orderBy: HistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [History]!
  historiesConnection(where: HistoryWhereInput, orderBy: HistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HistoryConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  itemAsset(where: ItemAssetWhereUniqueInput!): ItemAsset
  itemAssets(where: ItemAssetWhereInput, orderBy: ItemAssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ItemAsset]!
  itemAssetsConnection(where: ItemAssetWhereInput, orderBy: ItemAssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemAssetConnection!
  migration(where: MigrationWhereUniqueInput!): Migration
  migrations(where: MigrationWhereInput, orderBy: MigrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Migration]!
  migrationsConnection(where: MigrationWhereInput, orderBy: MigrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MigrationConnection!
  pageView(where: PageViewWhereUniqueInput!): PageView
  pageViews(where: PageViewWhereInput, orderBy: PageViewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PageView]!
  pageViewsConnection(where: PageViewWhereInput, orderBy: PageViewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PageViewConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  price(where: PriceWhereUniqueInput!): Price
  prices(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price]!
  pricesConnection(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PriceConnection!
  promotion(where: PromotionWhereUniqueInput!): Promotion
  promotions(where: PromotionWhereInput, orderBy: PromotionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Promotion]!
  promotionsConnection(where: PromotionWhereInput, orderBy: PromotionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PromotionConnection!
  publishTimelines(where: PublishTimelineWhereInput, orderBy: PublishTimelineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PublishTimeline]!
  publishTimelinesConnection(where: PublishTimelineWhereInput, orderBy: PublishTimelineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PublishTimelineConnection!
  remoteConfig(where: RemoteConfigWhereUniqueInput!): RemoteConfig
  remoteConfigs(where: RemoteConfigWhereInput, orderBy: RemoteConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RemoteConfig]!
  remoteConfigsConnection(where: RemoteConfigWhereInput, orderBy: RemoteConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RemoteConfigConnection!
  revenueSharing(where: RevenueSharingWhereUniqueInput!): RevenueSharing
  revenueSharings(where: RevenueSharingWhereInput, orderBy: RevenueSharingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RevenueSharing]!
  revenueSharingsConnection(where: RevenueSharingWhereInput, orderBy: RevenueSharingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RevenueSharingConnection!
  shelf(where: ShelfWhereUniqueInput!): Shelf
  shelves(where: ShelfWhereInput, orderBy: ShelfOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Shelf]!
  shelvesConnection(where: ShelfWhereInput, orderBy: ShelfOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShelfConnection!
  systemConfig(where: SystemConfigWhereUniqueInput!): SystemConfig
  systemConfigs(where: SystemConfigWhereInput, orderBy: SystemConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SystemConfig]!
  systemConfigsConnection(where: SystemConfigWhereInput, orderBy: SystemConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SystemConfigConnection!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction]!
  transactionsConnection(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionConnection!
  translator(where: TranslatorWhereUniqueInput!): Translator
  translators(where: TranslatorWhereInput, orderBy: TranslatorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Translator]!
  translatorsConnection(where: TranslatorWhereInput, orderBy: TranslatorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TranslatorConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userAdmin(where: UserAdminWhereUniqueInput!): UserAdmin
  userAdmins(where: UserAdminWhereInput, orderBy: UserAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAdmin]!
  userAdminsConnection(where: UserAdminWhereInput, orderBy: UserAdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAdminConnection!
  userAdminPermission(where: UserAdminPermissionWhereUniqueInput!): UserAdminPermission
  userAdminPermissions(where: UserAdminPermissionWhereInput, orderBy: UserAdminPermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAdminPermission]!
  userAdminPermissionsConnection(where: UserAdminPermissionWhereInput, orderBy: UserAdminPermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAdminPermissionConnection!
  userAdminRole(where: UserAdminRoleWhereUniqueInput!): UserAdminRole
  userAdminRoles(where: UserAdminRoleWhereInput, orderBy: UserAdminRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAdminRole]!
  userAdminRolesConnection(where: UserAdminRoleWhereInput, orderBy: UserAdminRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAdminRoleConnection!
  vendor(where: VendorWhereUniqueInput!): Vendor
  vendors(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vendor]!
  vendorsConnection(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VendorConnection!
  vendorBillingInformation(where: VendorBillingInformationWhereUniqueInput!): VendorBillingInformation
  vendorBillingInformations(where: VendorBillingInformationWhereInput, orderBy: VendorBillingInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [VendorBillingInformation]!
  vendorBillingInformationsConnection(where: VendorBillingInformationWhereInput, orderBy: VendorBillingInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VendorBillingInformationConnection!
  vendorRevenue(where: VendorRevenueWhereUniqueInput!): VendorRevenue
  vendorRevenues(where: VendorRevenueWhereInput, orderBy: VendorRevenueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [VendorRevenue]!
  vendorRevenuesConnection(where: VendorRevenueWhereInput, orderBy: VendorRevenueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VendorRevenueConnection!
  node(id: ID!): Node
}

type RemoteConfig {
  id: ID!
  name: String
  landing: Boolean!
}

type RemoteConfigConnection {
  pageInfo: PageInfo!
  edges: [RemoteConfigEdge]!
  aggregate: AggregateRemoteConfig!
}

input RemoteConfigCreateInput {
  name: String
  landing: Boolean
}

type RemoteConfigEdge {
  node: RemoteConfig!
  cursor: String!
}

enum RemoteConfigOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  landing_ASC
  landing_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RemoteConfigPreviousValues {
  id: ID!
  name: String
  landing: Boolean!
}

type RemoteConfigSubscriptionPayload {
  mutation: MutationType!
  node: RemoteConfig
  updatedFields: [String!]
  previousValues: RemoteConfigPreviousValues
}

input RemoteConfigSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RemoteConfigWhereInput
  AND: [RemoteConfigSubscriptionWhereInput!]
  OR: [RemoteConfigSubscriptionWhereInput!]
  NOT: [RemoteConfigSubscriptionWhereInput!]
}

input RemoteConfigUpdateInput {
  name: String
  landing: Boolean
}

input RemoteConfigUpdateManyMutationInput {
  name: String
  landing: Boolean
}

input RemoteConfigWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  landing: Boolean
  landing_not: Boolean
  AND: [RemoteConfigWhereInput!]
  OR: [RemoteConfigWhereInput!]
  NOT: [RemoteConfigWhereInput!]
}

input RemoteConfigWhereUniqueInput {
  id: ID
}

type RevenueSharing {
  id: ID!
  vendor: Vendor!
  book: Book!
  commission: Float!
  status: RevenueSharingStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RevenueSharingConnection {
  pageInfo: PageInfo!
  edges: [RevenueSharingEdge]!
  aggregate: AggregateRevenueSharing!
}

input RevenueSharingCreateInput {
  vendor: VendorCreateOneInput!
  book: BookCreateOneInput!
  commission: Float!
  status: RevenueSharingStatus!
}

input RevenueSharingCreateOneInput {
  create: RevenueSharingCreateInput
  connect: RevenueSharingWhereUniqueInput
}

type RevenueSharingEdge {
  node: RevenueSharing!
  cursor: String!
}

enum RevenueSharingOrderByInput {
  id_ASC
  id_DESC
  commission_ASC
  commission_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RevenueSharingPreviousValues {
  id: ID!
  commission: Float!
  status: RevenueSharingStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum RevenueSharingStatus {
  Stop
  OnGoing
}

type RevenueSharingSubscriptionPayload {
  mutation: MutationType!
  node: RevenueSharing
  updatedFields: [String!]
  previousValues: RevenueSharingPreviousValues
}

input RevenueSharingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RevenueSharingWhereInput
  AND: [RevenueSharingSubscriptionWhereInput!]
  OR: [RevenueSharingSubscriptionWhereInput!]
  NOT: [RevenueSharingSubscriptionWhereInput!]
}

input RevenueSharingUpdateDataInput {
  vendor: VendorUpdateOneRequiredInput
  book: BookUpdateOneRequiredInput
  commission: Float
  status: RevenueSharingStatus
}

input RevenueSharingUpdateInput {
  vendor: VendorUpdateOneRequiredInput
  book: BookUpdateOneRequiredInput
  commission: Float
  status: RevenueSharingStatus
}

input RevenueSharingUpdateManyMutationInput {
  commission: Float
  status: RevenueSharingStatus
}

input RevenueSharingUpdateOneRequiredInput {
  create: RevenueSharingCreateInput
  update: RevenueSharingUpdateDataInput
  upsert: RevenueSharingUpsertNestedInput
  connect: RevenueSharingWhereUniqueInput
}

input RevenueSharingUpsertNestedInput {
  update: RevenueSharingUpdateDataInput!
  create: RevenueSharingCreateInput!
}

input RevenueSharingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  vendor: VendorWhereInput
  book: BookWhereInput
  commission: Float
  commission_not: Float
  commission_in: [Float!]
  commission_not_in: [Float!]
  commission_lt: Float
  commission_lte: Float
  commission_gt: Float
  commission_gte: Float
  status: RevenueSharingStatus
  status_not: RevenueSharingStatus
  status_in: [RevenueSharingStatus!]
  status_not_in: [RevenueSharingStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RevenueSharingWhereInput!]
  OR: [RevenueSharingWhereInput!]
  NOT: [RevenueSharingWhereInput!]
}

input RevenueSharingWhereUniqueInput {
  id: ID
}

enum ReviewPostStatus {
  Hide
  Publish
}

type Shelf {
  id: ID!
  type: ShelfType!
  user: User!
  book: Book
}

type ShelfConnection {
  pageInfo: PageInfo!
  edges: [ShelfEdge]!
  aggregate: AggregateShelf!
}

input ShelfCreateInput {
  type: ShelfType!
  user: UserCreateOneInput!
  book: BookCreateOneInput
}

type ShelfEdge {
  node: Shelf!
  cursor: String!
}

enum ShelfOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ShelfPreviousValues {
  id: ID!
  type: ShelfType!
}

type ShelfSubscriptionPayload {
  mutation: MutationType!
  node: Shelf
  updatedFields: [String!]
  previousValues: ShelfPreviousValues
}

input ShelfSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShelfWhereInput
  AND: [ShelfSubscriptionWhereInput!]
  OR: [ShelfSubscriptionWhereInput!]
  NOT: [ShelfSubscriptionWhereInput!]
}

enum ShelfType {
  BookPurchased
}

input ShelfUpdateInput {
  type: ShelfType
  user: UserUpdateOneRequiredInput
  book: BookUpdateOneInput
}

input ShelfUpdateManyMutationInput {
  type: ShelfType
}

input ShelfWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: ShelfType
  type_not: ShelfType
  type_in: [ShelfType!]
  type_not_in: [ShelfType!]
  user: UserWhereInput
  book: BookWhereInput
  AND: [ShelfWhereInput!]
  OR: [ShelfWhereInput!]
  NOT: [ShelfWhereInput!]
}

input ShelfWhereUniqueInput {
  id: ID
}

type Subscription {
  adsBanner(where: AdsBannerSubscriptionWhereInput): AdsBannerSubscriptionPayload
  author(where: AuthorSubscriptionWhereInput): AuthorSubscriptionPayload
  behavior(where: BehaviorSubscriptionWhereInput): BehaviorSubscriptionPayload
  book(where: BookSubscriptionWhereInput): BookSubscriptionPayload
  bookEpisode(where: BookEpisodeSubscriptionWhereInput): BookEpisodeSubscriptionPayload
  bookEpisodeContent(where: BookEpisodeContentSubscriptionWhereInput): BookEpisodeContentSubscriptionPayload
  bookEpisodeRecentRead(where: BookEpisodeRecentReadSubscriptionWhereInput): BookEpisodeRecentReadSubscriptionPayload
  bookEpisodeReviewPost(where: BookEpisodeReviewPostSubscriptionWhereInput): BookEpisodeReviewPostSubscriptionPayload
  bookRecommended(where: BookRecommendedSubscriptionWhereInput): BookRecommendedSubscriptionPayload
  bookVolume(where: BookVolumeSubscriptionWhereInput): BookVolumeSubscriptionPayload
  category(where: CategorySubscriptionWhereInput): CategorySubscriptionPayload
  copyrightHolder(where: CopyrightHolderSubscriptionWhereInput): CopyrightHolderSubscriptionPayload
  dashbardDataCache(where: DashbardDataCacheSubscriptionWhereInput): DashbardDataCacheSubscriptionPayload
  document(where: DocumentSubscriptionWhereInput): DocumentSubscriptionPayload
  exchangeTier(where: ExchangeTierSubscriptionWhereInput): ExchangeTierSubscriptionPayload
  exchangeTransaction(where: ExchangeTransactionSubscriptionWhereInput): ExchangeTransactionSubscriptionPayload
  exchangeTransactionStatusHistory(where: ExchangeTransactionStatusHistorySubscriptionWhereInput): ExchangeTransactionStatusHistorySubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  history(where: HistorySubscriptionWhereInput): HistorySubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  itemAsset(where: ItemAssetSubscriptionWhereInput): ItemAssetSubscriptionPayload
  migration(where: MigrationSubscriptionWhereInput): MigrationSubscriptionPayload
  pageView(where: PageViewSubscriptionWhereInput): PageViewSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  price(where: PriceSubscriptionWhereInput): PriceSubscriptionPayload
  promotion(where: PromotionSubscriptionWhereInput): PromotionSubscriptionPayload
  publishTimeline(where: PublishTimelineSubscriptionWhereInput): PublishTimelineSubscriptionPayload
  remoteConfig(where: RemoteConfigSubscriptionWhereInput): RemoteConfigSubscriptionPayload
  revenueSharing(where: RevenueSharingSubscriptionWhereInput): RevenueSharingSubscriptionPayload
  shelf(where: ShelfSubscriptionWhereInput): ShelfSubscriptionPayload
  systemConfig(where: SystemConfigSubscriptionWhereInput): SystemConfigSubscriptionPayload
  transaction(where: TransactionSubscriptionWhereInput): TransactionSubscriptionPayload
  translator(where: TranslatorSubscriptionWhereInput): TranslatorSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userAdmin(where: UserAdminSubscriptionWhereInput): UserAdminSubscriptionPayload
  userAdminPermission(where: UserAdminPermissionSubscriptionWhereInput): UserAdminPermissionSubscriptionPayload
  userAdminRole(where: UserAdminRoleSubscriptionWhereInput): UserAdminRoleSubscriptionPayload
  vendor(where: VendorSubscriptionWhereInput): VendorSubscriptionPayload
  vendorBillingInformation(where: VendorBillingInformationSubscriptionWhereInput): VendorBillingInformationSubscriptionPayload
  vendorRevenue(where: VendorRevenueSubscriptionWhereInput): VendorRevenueSubscriptionPayload
}

type SystemConfig {
  id: ID!
  name: String!
  value: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SystemConfigConnection {
  pageInfo: PageInfo!
  edges: [SystemConfigEdge]!
  aggregate: AggregateSystemConfig!
}

input SystemConfigCreateInput {
  name: String!
  value: String
}

type SystemConfigEdge {
  node: SystemConfig!
  cursor: String!
}

enum SystemConfigOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  value_ASC
  value_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SystemConfigPreviousValues {
  id: ID!
  name: String!
  value: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SystemConfigSubscriptionPayload {
  mutation: MutationType!
  node: SystemConfig
  updatedFields: [String!]
  previousValues: SystemConfigPreviousValues
}

input SystemConfigSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SystemConfigWhereInput
  AND: [SystemConfigSubscriptionWhereInput!]
  OR: [SystemConfigSubscriptionWhereInput!]
  NOT: [SystemConfigSubscriptionWhereInput!]
}

input SystemConfigUpdateInput {
  name: String
  value: String
}

input SystemConfigUpdateManyMutationInput {
  name: String
  value: String
}

input SystemConfigWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SystemConfigWhereInput!]
  OR: [SystemConfigWhereInput!]
  NOT: [SystemConfigWhereInput!]
}

input SystemConfigWhereUniqueInput {
  id: ID
  name: String
}

type Transaction {
  id: ID!
  user: User!
  type: TransactionType!
  currencyType: CurrencyType!
  amount: Float!
  exchangeTransaction: ExchangeTransaction
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  createdAt: DateTime!
  updatedAt: DateTime!
  vendorRevenue(where: VendorRevenueWhereInput, orderBy: VendorRevenueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [VendorRevenue!]
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]!
  aggregate: AggregateTransaction!
}

input TransactionCreateInput {
  user: UserCreateOneWithoutTransactionsInput!
  type: TransactionType!
  currencyType: CurrencyType!
  amount: Float!
  exchangeTransaction: ExchangeTransactionCreateOneInput
  items: ItemCreateManyWithoutTransactionInput
  vendorRevenue: VendorRevenueCreateManyWithoutTransactionInput
}

input TransactionCreateManyWithoutUserInput {
  create: [TransactionCreateWithoutUserInput!]
  connect: [TransactionWhereUniqueInput!]
}

input TransactionCreateOneWithoutItemsInput {
  create: TransactionCreateWithoutItemsInput
  connect: TransactionWhereUniqueInput
}

input TransactionCreateOneWithoutVendorRevenueInput {
  create: TransactionCreateWithoutVendorRevenueInput
  connect: TransactionWhereUniqueInput
}

input TransactionCreateWithoutItemsInput {
  user: UserCreateOneWithoutTransactionsInput!
  type: TransactionType!
  currencyType: CurrencyType!
  amount: Float!
  exchangeTransaction: ExchangeTransactionCreateOneInput
  vendorRevenue: VendorRevenueCreateManyWithoutTransactionInput
}

input TransactionCreateWithoutUserInput {
  type: TransactionType!
  currencyType: CurrencyType!
  amount: Float!
  exchangeTransaction: ExchangeTransactionCreateOneInput
  items: ItemCreateManyWithoutTransactionInput
  vendorRevenue: VendorRevenueCreateManyWithoutTransactionInput
}

input TransactionCreateWithoutVendorRevenueInput {
  user: UserCreateOneWithoutTransactionsInput!
  type: TransactionType!
  currencyType: CurrencyType!
  amount: Float!
  exchangeTransaction: ExchangeTransactionCreateOneInput
  items: ItemCreateManyWithoutTransactionInput
}

type TransactionEdge {
  node: Transaction!
  cursor: String!
}

enum TransactionOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  currencyType_ASC
  currencyType_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TransactionPreviousValues {
  id: ID!
  type: TransactionType!
  currencyType: CurrencyType!
  amount: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TransactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: TransactionType
  type_not: TransactionType
  type_in: [TransactionType!]
  type_not_in: [TransactionType!]
  currencyType: CurrencyType
  currencyType_not: CurrencyType
  currencyType_in: [CurrencyType!]
  currencyType_not_in: [CurrencyType!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TransactionScalarWhereInput!]
  OR: [TransactionScalarWhereInput!]
  NOT: [TransactionScalarWhereInput!]
}

type TransactionSubscriptionPayload {
  mutation: MutationType!
  node: Transaction
  updatedFields: [String!]
  previousValues: TransactionPreviousValues
}

input TransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TransactionWhereInput
  AND: [TransactionSubscriptionWhereInput!]
  OR: [TransactionSubscriptionWhereInput!]
  NOT: [TransactionSubscriptionWhereInput!]
}

enum TransactionType {
  Income
  Outcome
}

input TransactionUpdateInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  type: TransactionType
  currencyType: CurrencyType
  amount: Float
  exchangeTransaction: ExchangeTransactionUpdateOneInput
  items: ItemUpdateManyWithoutTransactionInput
  vendorRevenue: VendorRevenueUpdateManyWithoutTransactionInput
}

input TransactionUpdateManyDataInput {
  type: TransactionType
  currencyType: CurrencyType
  amount: Float
}

input TransactionUpdateManyMutationInput {
  type: TransactionType
  currencyType: CurrencyType
  amount: Float
}

input TransactionUpdateManyWithoutUserInput {
  create: [TransactionCreateWithoutUserInput!]
  delete: [TransactionWhereUniqueInput!]
  connect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  disconnect: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TransactionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TransactionScalarWhereInput!]
  updateMany: [TransactionUpdateManyWithWhereNestedInput!]
}

input TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput!
  data: TransactionUpdateManyDataInput!
}

input TransactionUpdateOneRequiredWithoutVendorRevenueInput {
  create: TransactionCreateWithoutVendorRevenueInput
  update: TransactionUpdateWithoutVendorRevenueDataInput
  upsert: TransactionUpsertWithoutVendorRevenueInput
  connect: TransactionWhereUniqueInput
}

input TransactionUpdateOneWithoutItemsInput {
  create: TransactionCreateWithoutItemsInput
  update: TransactionUpdateWithoutItemsDataInput
  upsert: TransactionUpsertWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: TransactionWhereUniqueInput
}

input TransactionUpdateWithoutItemsDataInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  type: TransactionType
  currencyType: CurrencyType
  amount: Float
  exchangeTransaction: ExchangeTransactionUpdateOneInput
  vendorRevenue: VendorRevenueUpdateManyWithoutTransactionInput
}

input TransactionUpdateWithoutUserDataInput {
  type: TransactionType
  currencyType: CurrencyType
  amount: Float
  exchangeTransaction: ExchangeTransactionUpdateOneInput
  items: ItemUpdateManyWithoutTransactionInput
  vendorRevenue: VendorRevenueUpdateManyWithoutTransactionInput
}

input TransactionUpdateWithoutVendorRevenueDataInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  type: TransactionType
  currencyType: CurrencyType
  amount: Float
  exchangeTransaction: ExchangeTransactionUpdateOneInput
  items: ItemUpdateManyWithoutTransactionInput
}

input TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput!
  data: TransactionUpdateWithoutUserDataInput!
}

input TransactionUpsertWithoutItemsInput {
  update: TransactionUpdateWithoutItemsDataInput!
  create: TransactionCreateWithoutItemsInput!
}

input TransactionUpsertWithoutVendorRevenueInput {
  update: TransactionUpdateWithoutVendorRevenueDataInput!
  create: TransactionCreateWithoutVendorRevenueInput!
}

input TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput!
  update: TransactionUpdateWithoutUserDataInput!
  create: TransactionCreateWithoutUserInput!
}

input TransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  type: TransactionType
  type_not: TransactionType
  type_in: [TransactionType!]
  type_not_in: [TransactionType!]
  currencyType: CurrencyType
  currencyType_not: CurrencyType
  currencyType_in: [CurrencyType!]
  currencyType_not_in: [CurrencyType!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  exchangeTransaction: ExchangeTransactionWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  vendorRevenue_every: VendorRevenueWhereInput
  vendorRevenue_some: VendorRevenueWhereInput
  vendorRevenue_none: VendorRevenueWhereInput
  AND: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
}

input TransactionWhereUniqueInput {
  id: ID
}

type Translator {
  id: ID!
  name: String!
  vendor: Vendor
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TranslatorConnection {
  pageInfo: PageInfo!
  edges: [TranslatorEdge]!
  aggregate: AggregateTranslator!
}

input TranslatorCreateInput {
  name: String!
  vendor: VendorCreateOneWithoutTranslatorsInput
}

input TranslatorCreateManyInput {
  create: [TranslatorCreateInput!]
  connect: [TranslatorWhereUniqueInput!]
}

input TranslatorCreateManyWithoutVendorInput {
  create: [TranslatorCreateWithoutVendorInput!]
  connect: [TranslatorWhereUniqueInput!]
}

input TranslatorCreateWithoutVendorInput {
  name: String!
}

type TranslatorEdge {
  node: Translator!
  cursor: String!
}

enum TranslatorOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TranslatorPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TranslatorScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TranslatorScalarWhereInput!]
  OR: [TranslatorScalarWhereInput!]
  NOT: [TranslatorScalarWhereInput!]
}

type TranslatorSubscriptionPayload {
  mutation: MutationType!
  node: Translator
  updatedFields: [String!]
  previousValues: TranslatorPreviousValues
}

input TranslatorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TranslatorWhereInput
  AND: [TranslatorSubscriptionWhereInput!]
  OR: [TranslatorSubscriptionWhereInput!]
  NOT: [TranslatorSubscriptionWhereInput!]
}

input TranslatorUpdateDataInput {
  name: String
  vendor: VendorUpdateOneWithoutTranslatorsInput
}

input TranslatorUpdateInput {
  name: String
  vendor: VendorUpdateOneWithoutTranslatorsInput
}

input TranslatorUpdateManyDataInput {
  name: String
}

input TranslatorUpdateManyInput {
  create: [TranslatorCreateInput!]
  update: [TranslatorUpdateWithWhereUniqueNestedInput!]
  upsert: [TranslatorUpsertWithWhereUniqueNestedInput!]
  delete: [TranslatorWhereUniqueInput!]
  connect: [TranslatorWhereUniqueInput!]
  set: [TranslatorWhereUniqueInput!]
  disconnect: [TranslatorWhereUniqueInput!]
  deleteMany: [TranslatorScalarWhereInput!]
  updateMany: [TranslatorUpdateManyWithWhereNestedInput!]
}

input TranslatorUpdateManyMutationInput {
  name: String
}

input TranslatorUpdateManyWithoutVendorInput {
  create: [TranslatorCreateWithoutVendorInput!]
  delete: [TranslatorWhereUniqueInput!]
  connect: [TranslatorWhereUniqueInput!]
  set: [TranslatorWhereUniqueInput!]
  disconnect: [TranslatorWhereUniqueInput!]
  update: [TranslatorUpdateWithWhereUniqueWithoutVendorInput!]
  upsert: [TranslatorUpsertWithWhereUniqueWithoutVendorInput!]
  deleteMany: [TranslatorScalarWhereInput!]
  updateMany: [TranslatorUpdateManyWithWhereNestedInput!]
}

input TranslatorUpdateManyWithWhereNestedInput {
  where: TranslatorScalarWhereInput!
  data: TranslatorUpdateManyDataInput!
}

input TranslatorUpdateWithoutVendorDataInput {
  name: String
}

input TranslatorUpdateWithWhereUniqueNestedInput {
  where: TranslatorWhereUniqueInput!
  data: TranslatorUpdateDataInput!
}

input TranslatorUpdateWithWhereUniqueWithoutVendorInput {
  where: TranslatorWhereUniqueInput!
  data: TranslatorUpdateWithoutVendorDataInput!
}

input TranslatorUpsertWithWhereUniqueNestedInput {
  where: TranslatorWhereUniqueInput!
  update: TranslatorUpdateDataInput!
  create: TranslatorCreateInput!
}

input TranslatorUpsertWithWhereUniqueWithoutVendorInput {
  where: TranslatorWhereUniqueInput!
  update: TranslatorUpdateWithoutVendorDataInput!
  create: TranslatorCreateWithoutVendorInput!
}

input TranslatorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  vendor: VendorWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TranslatorWhereInput!]
  OR: [TranslatorWhereInput!]
  NOT: [TranslatorWhereInput!]
}

input TranslatorWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  userID: ID!
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender!
  defaultProfilePicture: String
  createdAt: DateTime!
  updatedAt: DateTime!
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction!]
  exchangeTransactions(where: ExchangeTransactionWhereInput, orderBy: ExchangeTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExchangeTransaction!]
}

type UserAdmin {
  id: ID!
  email: String
  hashedPassword: String
  roles(where: UserAdminRoleWhereInput, orderBy: UserAdminRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAdminRole!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAdminConnection {
  pageInfo: PageInfo!
  edges: [UserAdminEdge]!
  aggregate: AggregateUserAdmin!
}

input UserAdminCreateInput {
  email: String
  hashedPassword: String
  roles: UserAdminRoleCreateManyInput
}

type UserAdminEdge {
  node: UserAdmin!
  cursor: String!
}

enum UserAdminOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  hashedPassword_ASC
  hashedPassword_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserAdminPermission {
  id: ID!
  type: String!
  resource: String
}

type UserAdminPermissionConnection {
  pageInfo: PageInfo!
  edges: [UserAdminPermissionEdge]!
  aggregate: AggregateUserAdminPermission!
}

input UserAdminPermissionCreateInput {
  type: String!
  resource: String
}

input UserAdminPermissionCreateManyInput {
  create: [UserAdminPermissionCreateInput!]
  connect: [UserAdminPermissionWhereUniqueInput!]
}

type UserAdminPermissionEdge {
  node: UserAdminPermission!
  cursor: String!
}

enum UserAdminPermissionOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  resource_ASC
  resource_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserAdminPermissionPreviousValues {
  id: ID!
  type: String!
  resource: String
}

input UserAdminPermissionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  resource: String
  resource_not: String
  resource_in: [String!]
  resource_not_in: [String!]
  resource_lt: String
  resource_lte: String
  resource_gt: String
  resource_gte: String
  resource_contains: String
  resource_not_contains: String
  resource_starts_with: String
  resource_not_starts_with: String
  resource_ends_with: String
  resource_not_ends_with: String
  AND: [UserAdminPermissionScalarWhereInput!]
  OR: [UserAdminPermissionScalarWhereInput!]
  NOT: [UserAdminPermissionScalarWhereInput!]
}

type UserAdminPermissionSubscriptionPayload {
  mutation: MutationType!
  node: UserAdminPermission
  updatedFields: [String!]
  previousValues: UserAdminPermissionPreviousValues
}

input UserAdminPermissionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserAdminPermissionWhereInput
  AND: [UserAdminPermissionSubscriptionWhereInput!]
  OR: [UserAdminPermissionSubscriptionWhereInput!]
  NOT: [UserAdminPermissionSubscriptionWhereInput!]
}

input UserAdminPermissionUpdateDataInput {
  type: String
  resource: String
}

input UserAdminPermissionUpdateInput {
  type: String
  resource: String
}

input UserAdminPermissionUpdateManyDataInput {
  type: String
  resource: String
}

input UserAdminPermissionUpdateManyInput {
  create: [UserAdminPermissionCreateInput!]
  update: [UserAdminPermissionUpdateWithWhereUniqueNestedInput!]
  upsert: [UserAdminPermissionUpsertWithWhereUniqueNestedInput!]
  delete: [UserAdminPermissionWhereUniqueInput!]
  connect: [UserAdminPermissionWhereUniqueInput!]
  set: [UserAdminPermissionWhereUniqueInput!]
  disconnect: [UserAdminPermissionWhereUniqueInput!]
  deleteMany: [UserAdminPermissionScalarWhereInput!]
  updateMany: [UserAdminPermissionUpdateManyWithWhereNestedInput!]
}

input UserAdminPermissionUpdateManyMutationInput {
  type: String
  resource: String
}

input UserAdminPermissionUpdateManyWithWhereNestedInput {
  where: UserAdminPermissionScalarWhereInput!
  data: UserAdminPermissionUpdateManyDataInput!
}

input UserAdminPermissionUpdateWithWhereUniqueNestedInput {
  where: UserAdminPermissionWhereUniqueInput!
  data: UserAdminPermissionUpdateDataInput!
}

input UserAdminPermissionUpsertWithWhereUniqueNestedInput {
  where: UserAdminPermissionWhereUniqueInput!
  update: UserAdminPermissionUpdateDataInput!
  create: UserAdminPermissionCreateInput!
}

input UserAdminPermissionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  resource: String
  resource_not: String
  resource_in: [String!]
  resource_not_in: [String!]
  resource_lt: String
  resource_lte: String
  resource_gt: String
  resource_gte: String
  resource_contains: String
  resource_not_contains: String
  resource_starts_with: String
  resource_not_starts_with: String
  resource_ends_with: String
  resource_not_ends_with: String
  AND: [UserAdminPermissionWhereInput!]
  OR: [UserAdminPermissionWhereInput!]
  NOT: [UserAdminPermissionWhereInput!]
}

input UserAdminPermissionWhereUniqueInput {
  id: ID
}

type UserAdminPreviousValues {
  id: ID!
  email: String
  hashedPassword: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAdminRole {
  id: ID!
  name: String!
  permissions(where: UserAdminPermissionWhereInput, orderBy: UserAdminPermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAdminPermission!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAdminRoleConnection {
  pageInfo: PageInfo!
  edges: [UserAdminRoleEdge]!
  aggregate: AggregateUserAdminRole!
}

input UserAdminRoleCreateInput {
  name: String!
  permissions: UserAdminPermissionCreateManyInput
}

input UserAdminRoleCreateManyInput {
  create: [UserAdminRoleCreateInput!]
  connect: [UserAdminRoleWhereUniqueInput!]
}

type UserAdminRoleEdge {
  node: UserAdminRole!
  cursor: String!
}

enum UserAdminRoleOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserAdminRolePreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserAdminRoleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserAdminRoleScalarWhereInput!]
  OR: [UserAdminRoleScalarWhereInput!]
  NOT: [UserAdminRoleScalarWhereInput!]
}

type UserAdminRoleSubscriptionPayload {
  mutation: MutationType!
  node: UserAdminRole
  updatedFields: [String!]
  previousValues: UserAdminRolePreviousValues
}

input UserAdminRoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserAdminRoleWhereInput
  AND: [UserAdminRoleSubscriptionWhereInput!]
  OR: [UserAdminRoleSubscriptionWhereInput!]
  NOT: [UserAdminRoleSubscriptionWhereInput!]
}

input UserAdminRoleUpdateDataInput {
  name: String
  permissions: UserAdminPermissionUpdateManyInput
}

input UserAdminRoleUpdateInput {
  name: String
  permissions: UserAdminPermissionUpdateManyInput
}

input UserAdminRoleUpdateManyDataInput {
  name: String
}

input UserAdminRoleUpdateManyInput {
  create: [UserAdminRoleCreateInput!]
  update: [UserAdminRoleUpdateWithWhereUniqueNestedInput!]
  upsert: [UserAdminRoleUpsertWithWhereUniqueNestedInput!]
  delete: [UserAdminRoleWhereUniqueInput!]
  connect: [UserAdminRoleWhereUniqueInput!]
  set: [UserAdminRoleWhereUniqueInput!]
  disconnect: [UserAdminRoleWhereUniqueInput!]
  deleteMany: [UserAdminRoleScalarWhereInput!]
  updateMany: [UserAdminRoleUpdateManyWithWhereNestedInput!]
}

input UserAdminRoleUpdateManyMutationInput {
  name: String
}

input UserAdminRoleUpdateManyWithWhereNestedInput {
  where: UserAdminRoleScalarWhereInput!
  data: UserAdminRoleUpdateManyDataInput!
}

input UserAdminRoleUpdateWithWhereUniqueNestedInput {
  where: UserAdminRoleWhereUniqueInput!
  data: UserAdminRoleUpdateDataInput!
}

input UserAdminRoleUpsertWithWhereUniqueNestedInput {
  where: UserAdminRoleWhereUniqueInput!
  update: UserAdminRoleUpdateDataInput!
  create: UserAdminRoleCreateInput!
}

input UserAdminRoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  permissions_every: UserAdminPermissionWhereInput
  permissions_some: UserAdminPermissionWhereInput
  permissions_none: UserAdminPermissionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserAdminRoleWhereInput!]
  OR: [UserAdminRoleWhereInput!]
  NOT: [UserAdminRoleWhereInput!]
}

input UserAdminRoleWhereUniqueInput {
  id: ID
  name: String
}

type UserAdminSubscriptionPayload {
  mutation: MutationType!
  node: UserAdmin
  updatedFields: [String!]
  previousValues: UserAdminPreviousValues
}

input UserAdminSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserAdminWhereInput
  AND: [UserAdminSubscriptionWhereInput!]
  OR: [UserAdminSubscriptionWhereInput!]
  NOT: [UserAdminSubscriptionWhereInput!]
}

input UserAdminUpdateInput {
  email: String
  hashedPassword: String
  roles: UserAdminRoleUpdateManyInput
}

input UserAdminUpdateManyMutationInput {
  email: String
  hashedPassword: String
}

input UserAdminWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  hashedPassword: String
  hashedPassword_not: String
  hashedPassword_in: [String!]
  hashedPassword_not_in: [String!]
  hashedPassword_lt: String
  hashedPassword_lte: String
  hashedPassword_gt: String
  hashedPassword_gte: String
  hashedPassword_contains: String
  hashedPassword_not_contains: String
  hashedPassword_starts_with: String
  hashedPassword_not_starts_with: String
  hashedPassword_ends_with: String
  hashedPassword_not_ends_with: String
  roles_every: UserAdminRoleWhereInput
  roles_some: UserAdminRoleWhereInput
  roles_none: UserAdminRoleWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserAdminWhereInput!]
  OR: [UserAdminWhereInput!]
  NOT: [UserAdminWhereInput!]
}

input UserAdminWhereUniqueInput {
  id: ID
  email: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  userID: ID!
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender
  defaultProfilePicture: String
  transactions: TransactionCreateManyWithoutUserInput
  exchangeTransactions: ExchangeTransactionCreateManyWithoutUserInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutExchangeTransactionsInput {
  create: UserCreateWithoutExchangeTransactionsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTransactionsInput {
  create: UserCreateWithoutTransactionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutExchangeTransactionsInput {
  userID: ID!
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender
  defaultProfilePicture: String
  transactions: TransactionCreateManyWithoutUserInput
}

input UserCreateWithoutTransactionsInput {
  userID: ID!
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender
  defaultProfilePicture: String
  exchangeTransactions: ExchangeTransactionCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  userID_ASC
  userID_DESC
  displayName_ASC
  displayName_DESC
  email_ASC
  email_DESC
  fullName_ASC
  fullName_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  birthday_ASC
  birthday_DESC
  gender_ASC
  gender_DESC
  defaultProfilePicture_ASC
  defaultProfilePicture_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  userID: ID!
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender!
  defaultProfilePicture: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  userID: ID
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender
  defaultProfilePicture: String
  transactions: TransactionUpdateManyWithoutUserInput
  exchangeTransactions: ExchangeTransactionUpdateManyWithoutUserInput
}

input UserUpdateInput {
  userID: ID
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender
  defaultProfilePicture: String
  transactions: TransactionUpdateManyWithoutUserInput
  exchangeTransactions: ExchangeTransactionUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  userID: ID
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender
  defaultProfilePicture: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutExchangeTransactionsInput {
  create: UserCreateWithoutExchangeTransactionsInput
  update: UserUpdateWithoutExchangeTransactionsDataInput
  upsert: UserUpsertWithoutExchangeTransactionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutTransactionsInput {
  create: UserCreateWithoutTransactionsInput
  update: UserUpdateWithoutTransactionsDataInput
  upsert: UserUpsertWithoutTransactionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutExchangeTransactionsDataInput {
  userID: ID
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender
  defaultProfilePicture: String
  transactions: TransactionUpdateManyWithoutUserInput
}

input UserUpdateWithoutTransactionsDataInput {
  userID: ID
  displayName: String
  email: String
  fullName: String
  phoneNumber: String
  birthday: String
  gender: Gender
  defaultProfilePicture: String
  exchangeTransactions: ExchangeTransactionUpdateManyWithoutUserInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutExchangeTransactionsInput {
  update: UserUpdateWithoutExchangeTransactionsDataInput!
  create: UserCreateWithoutExchangeTransactionsInput!
}

input UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput!
  create: UserCreateWithoutTransactionsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userID: ID
  userID_not: ID
  userID_in: [ID!]
  userID_not_in: [ID!]
  userID_lt: ID
  userID_lte: ID
  userID_gt: ID
  userID_gte: ID
  userID_contains: ID
  userID_not_contains: ID
  userID_starts_with: ID
  userID_not_starts_with: ID
  userID_ends_with: ID
  userID_not_ends_with: ID
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  birthday: String
  birthday_not: String
  birthday_in: [String!]
  birthday_not_in: [String!]
  birthday_lt: String
  birthday_lte: String
  birthday_gt: String
  birthday_gte: String
  birthday_contains: String
  birthday_not_contains: String
  birthday_starts_with: String
  birthday_not_starts_with: String
  birthday_ends_with: String
  birthday_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  defaultProfilePicture: String
  defaultProfilePicture_not: String
  defaultProfilePicture_in: [String!]
  defaultProfilePicture_not_in: [String!]
  defaultProfilePicture_lt: String
  defaultProfilePicture_lte: String
  defaultProfilePicture_gt: String
  defaultProfilePicture_gte: String
  defaultProfilePicture_contains: String
  defaultProfilePicture_not_contains: String
  defaultProfilePicture_starts_with: String
  defaultProfilePicture_not_starts_with: String
  defaultProfilePicture_ends_with: String
  defaultProfilePicture_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  transactions_every: TransactionWhereInput
  transactions_some: TransactionWhereInput
  transactions_none: TransactionWhereInput
  exchangeTransactions_every: ExchangeTransactionWhereInput
  exchangeTransactions_some: ExchangeTransactionWhereInput
  exchangeTransactions_none: ExchangeTransactionWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  userID: ID
}

type Vendor {
  id: ID!
  type: VendorType!
  authors(where: AuthorWhereInput, orderBy: AuthorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Author!]
  translators(where: TranslatorWhereInput, orderBy: TranslatorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Translator!]
  copyrightHolders(where: CopyrightHolderWhereInput, orderBy: CopyrightHolderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CopyrightHolder!]
  createdAt: DateTime!
  updatedAt: DateTime!
  documents(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Document!]
  billingInformation: VendorBillingInformation!
  phoneNumber: String
  email: String
}

type VendorBillingInformation {
  id: ID!
  billingType: VendorBillingType!
  companyName: String
  branchId: String
  taxID: String!
  firstName: String!
  lastName: String!
  bank: String
  bookBankNumber: String
  address: String!
  province: String
  zipCode: String
}

type VendorBillingInformationConnection {
  pageInfo: PageInfo!
  edges: [VendorBillingInformationEdge]!
  aggregate: AggregateVendorBillingInformation!
}

input VendorBillingInformationCreateInput {
  billingType: VendorBillingType!
  companyName: String
  branchId: String
  taxID: String!
  firstName: String!
  lastName: String!
  bank: String
  bookBankNumber: String
  address: String!
  province: String
  zipCode: String
}

input VendorBillingInformationCreateOneInput {
  create: VendorBillingInformationCreateInput
  connect: VendorBillingInformationWhereUniqueInput
}

type VendorBillingInformationEdge {
  node: VendorBillingInformation!
  cursor: String!
}

enum VendorBillingInformationOrderByInput {
  id_ASC
  id_DESC
  billingType_ASC
  billingType_DESC
  companyName_ASC
  companyName_DESC
  branchId_ASC
  branchId_DESC
  taxID_ASC
  taxID_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  bank_ASC
  bank_DESC
  bookBankNumber_ASC
  bookBankNumber_DESC
  address_ASC
  address_DESC
  province_ASC
  province_DESC
  zipCode_ASC
  zipCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type VendorBillingInformationPreviousValues {
  id: ID!
  billingType: VendorBillingType!
  companyName: String
  branchId: String
  taxID: String!
  firstName: String!
  lastName: String!
  bank: String
  bookBankNumber: String
  address: String!
  province: String
  zipCode: String
}

type VendorBillingInformationSubscriptionPayload {
  mutation: MutationType!
  node: VendorBillingInformation
  updatedFields: [String!]
  previousValues: VendorBillingInformationPreviousValues
}

input VendorBillingInformationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VendorBillingInformationWhereInput
  AND: [VendorBillingInformationSubscriptionWhereInput!]
  OR: [VendorBillingInformationSubscriptionWhereInput!]
  NOT: [VendorBillingInformationSubscriptionWhereInput!]
}

input VendorBillingInformationUpdateDataInput {
  billingType: VendorBillingType
  companyName: String
  branchId: String
  taxID: String
  firstName: String
  lastName: String
  bank: String
  bookBankNumber: String
  address: String
  province: String
  zipCode: String
}

input VendorBillingInformationUpdateInput {
  billingType: VendorBillingType
  companyName: String
  branchId: String
  taxID: String
  firstName: String
  lastName: String
  bank: String
  bookBankNumber: String
  address: String
  province: String
  zipCode: String
}

input VendorBillingInformationUpdateManyMutationInput {
  billingType: VendorBillingType
  companyName: String
  branchId: String
  taxID: String
  firstName: String
  lastName: String
  bank: String
  bookBankNumber: String
  address: String
  province: String
  zipCode: String
}

input VendorBillingInformationUpdateOneRequiredInput {
  create: VendorBillingInformationCreateInput
  update: VendorBillingInformationUpdateDataInput
  upsert: VendorBillingInformationUpsertNestedInput
  connect: VendorBillingInformationWhereUniqueInput
}

input VendorBillingInformationUpsertNestedInput {
  update: VendorBillingInformationUpdateDataInput!
  create: VendorBillingInformationCreateInput!
}

input VendorBillingInformationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  billingType: VendorBillingType
  billingType_not: VendorBillingType
  billingType_in: [VendorBillingType!]
  billingType_not_in: [VendorBillingType!]
  companyName: String
  companyName_not: String
  companyName_in: [String!]
  companyName_not_in: [String!]
  companyName_lt: String
  companyName_lte: String
  companyName_gt: String
  companyName_gte: String
  companyName_contains: String
  companyName_not_contains: String
  companyName_starts_with: String
  companyName_not_starts_with: String
  companyName_ends_with: String
  companyName_not_ends_with: String
  branchId: String
  branchId_not: String
  branchId_in: [String!]
  branchId_not_in: [String!]
  branchId_lt: String
  branchId_lte: String
  branchId_gt: String
  branchId_gte: String
  branchId_contains: String
  branchId_not_contains: String
  branchId_starts_with: String
  branchId_not_starts_with: String
  branchId_ends_with: String
  branchId_not_ends_with: String
  taxID: String
  taxID_not: String
  taxID_in: [String!]
  taxID_not_in: [String!]
  taxID_lt: String
  taxID_lte: String
  taxID_gt: String
  taxID_gte: String
  taxID_contains: String
  taxID_not_contains: String
  taxID_starts_with: String
  taxID_not_starts_with: String
  taxID_ends_with: String
  taxID_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  bank: String
  bank_not: String
  bank_in: [String!]
  bank_not_in: [String!]
  bank_lt: String
  bank_lte: String
  bank_gt: String
  bank_gte: String
  bank_contains: String
  bank_not_contains: String
  bank_starts_with: String
  bank_not_starts_with: String
  bank_ends_with: String
  bank_not_ends_with: String
  bookBankNumber: String
  bookBankNumber_not: String
  bookBankNumber_in: [String!]
  bookBankNumber_not_in: [String!]
  bookBankNumber_lt: String
  bookBankNumber_lte: String
  bookBankNumber_gt: String
  bookBankNumber_gte: String
  bookBankNumber_contains: String
  bookBankNumber_not_contains: String
  bookBankNumber_starts_with: String
  bookBankNumber_not_starts_with: String
  bookBankNumber_ends_with: String
  bookBankNumber_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  province: String
  province_not: String
  province_in: [String!]
  province_not_in: [String!]
  province_lt: String
  province_lte: String
  province_gt: String
  province_gte: String
  province_contains: String
  province_not_contains: String
  province_starts_with: String
  province_not_starts_with: String
  province_ends_with: String
  province_not_ends_with: String
  zipCode: String
  zipCode_not: String
  zipCode_in: [String!]
  zipCode_not_in: [String!]
  zipCode_lt: String
  zipCode_lte: String
  zipCode_gt: String
  zipCode_gte: String
  zipCode_contains: String
  zipCode_not_contains: String
  zipCode_starts_with: String
  zipCode_not_starts_with: String
  zipCode_ends_with: String
  zipCode_not_ends_with: String
  AND: [VendorBillingInformationWhereInput!]
  OR: [VendorBillingInformationWhereInput!]
  NOT: [VendorBillingInformationWhereInput!]
}

input VendorBillingInformationWhereUniqueInput {
  id: ID
}

enum VendorBillingType {
  Company
  Individual
}

type VendorConnection {
  pageInfo: PageInfo!
  edges: [VendorEdge]!
  aggregate: AggregateVendor!
}

input VendorCreateInput {
  type: VendorType!
  authors: AuthorCreateManyWithoutVendorInput
  translators: TranslatorCreateManyWithoutVendorInput
  copyrightHolders: CopyrightHolderCreateManyWithoutVendorInput
  documents: DocumentCreateManyInput
  billingInformation: VendorBillingInformationCreateOneInput!
  phoneNumber: String
  email: String
}

input VendorCreateOneInput {
  create: VendorCreateInput
  connect: VendorWhereUniqueInput
}

input VendorCreateOneWithoutAuthorsInput {
  create: VendorCreateWithoutAuthorsInput
  connect: VendorWhereUniqueInput
}

input VendorCreateOneWithoutCopyrightHoldersInput {
  create: VendorCreateWithoutCopyrightHoldersInput
  connect: VendorWhereUniqueInput
}

input VendorCreateOneWithoutTranslatorsInput {
  create: VendorCreateWithoutTranslatorsInput
  connect: VendorWhereUniqueInput
}

input VendorCreateWithoutAuthorsInput {
  type: VendorType!
  translators: TranslatorCreateManyWithoutVendorInput
  copyrightHolders: CopyrightHolderCreateManyWithoutVendorInput
  documents: DocumentCreateManyInput
  billingInformation: VendorBillingInformationCreateOneInput!
  phoneNumber: String
  email: String
}

input VendorCreateWithoutCopyrightHoldersInput {
  type: VendorType!
  authors: AuthorCreateManyWithoutVendorInput
  translators: TranslatorCreateManyWithoutVendorInput
  documents: DocumentCreateManyInput
  billingInformation: VendorBillingInformationCreateOneInput!
  phoneNumber: String
  email: String
}

input VendorCreateWithoutTranslatorsInput {
  type: VendorType!
  authors: AuthorCreateManyWithoutVendorInput
  copyrightHolders: CopyrightHolderCreateManyWithoutVendorInput
  documents: DocumentCreateManyInput
  billingInformation: VendorBillingInformationCreateOneInput!
  phoneNumber: String
  email: String
}

type VendorEdge {
  node: Vendor!
  cursor: String!
}

enum VendorOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  email_ASC
  email_DESC
}

type VendorPreviousValues {
  id: ID!
  type: VendorType!
  createdAt: DateTime!
  updatedAt: DateTime!
  phoneNumber: String
  email: String
}

type VendorRevenue {
  id: ID!
  weight: Int!
  revenueSharing: RevenueSharing!
  transaction: Transaction!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type VendorRevenueConnection {
  pageInfo: PageInfo!
  edges: [VendorRevenueEdge]!
  aggregate: AggregateVendorRevenue!
}

input VendorRevenueCreateInput {
  weight: Int!
  revenueSharing: RevenueSharingCreateOneInput!
  transaction: TransactionCreateOneWithoutVendorRevenueInput!
}

input VendorRevenueCreateManyWithoutTransactionInput {
  create: [VendorRevenueCreateWithoutTransactionInput!]
  connect: [VendorRevenueWhereUniqueInput!]
}

input VendorRevenueCreateWithoutTransactionInput {
  weight: Int!
  revenueSharing: RevenueSharingCreateOneInput!
}

type VendorRevenueEdge {
  node: VendorRevenue!
  cursor: String!
}

enum VendorRevenueOrderByInput {
  id_ASC
  id_DESC
  weight_ASC
  weight_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type VendorRevenuePreviousValues {
  id: ID!
  weight: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input VendorRevenueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [VendorRevenueScalarWhereInput!]
  OR: [VendorRevenueScalarWhereInput!]
  NOT: [VendorRevenueScalarWhereInput!]
}

type VendorRevenueSubscriptionPayload {
  mutation: MutationType!
  node: VendorRevenue
  updatedFields: [String!]
  previousValues: VendorRevenuePreviousValues
}

input VendorRevenueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VendorRevenueWhereInput
  AND: [VendorRevenueSubscriptionWhereInput!]
  OR: [VendorRevenueSubscriptionWhereInput!]
  NOT: [VendorRevenueSubscriptionWhereInput!]
}

input VendorRevenueUpdateInput {
  weight: Int
  revenueSharing: RevenueSharingUpdateOneRequiredInput
  transaction: TransactionUpdateOneRequiredWithoutVendorRevenueInput
}

input VendorRevenueUpdateManyDataInput {
  weight: Int
}

input VendorRevenueUpdateManyMutationInput {
  weight: Int
}

input VendorRevenueUpdateManyWithoutTransactionInput {
  create: [VendorRevenueCreateWithoutTransactionInput!]
  delete: [VendorRevenueWhereUniqueInput!]
  connect: [VendorRevenueWhereUniqueInput!]
  set: [VendorRevenueWhereUniqueInput!]
  disconnect: [VendorRevenueWhereUniqueInput!]
  update: [VendorRevenueUpdateWithWhereUniqueWithoutTransactionInput!]
  upsert: [VendorRevenueUpsertWithWhereUniqueWithoutTransactionInput!]
  deleteMany: [VendorRevenueScalarWhereInput!]
  updateMany: [VendorRevenueUpdateManyWithWhereNestedInput!]
}

input VendorRevenueUpdateManyWithWhereNestedInput {
  where: VendorRevenueScalarWhereInput!
  data: VendorRevenueUpdateManyDataInput!
}

input VendorRevenueUpdateWithoutTransactionDataInput {
  weight: Int
  revenueSharing: RevenueSharingUpdateOneRequiredInput
}

input VendorRevenueUpdateWithWhereUniqueWithoutTransactionInput {
  where: VendorRevenueWhereUniqueInput!
  data: VendorRevenueUpdateWithoutTransactionDataInput!
}

input VendorRevenueUpsertWithWhereUniqueWithoutTransactionInput {
  where: VendorRevenueWhereUniqueInput!
  update: VendorRevenueUpdateWithoutTransactionDataInput!
  create: VendorRevenueCreateWithoutTransactionInput!
}

input VendorRevenueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  revenueSharing: RevenueSharingWhereInput
  transaction: TransactionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [VendorRevenueWhereInput!]
  OR: [VendorRevenueWhereInput!]
  NOT: [VendorRevenueWhereInput!]
}

input VendorRevenueWhereUniqueInput {
  id: ID
}

type VendorSubscriptionPayload {
  mutation: MutationType!
  node: Vendor
  updatedFields: [String!]
  previousValues: VendorPreviousValues
}

input VendorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VendorWhereInput
  AND: [VendorSubscriptionWhereInput!]
  OR: [VendorSubscriptionWhereInput!]
  NOT: [VendorSubscriptionWhereInput!]
}

enum VendorType {
  SelfPublishing
  Publisher
}

input VendorUpdateDataInput {
  type: VendorType
  authors: AuthorUpdateManyWithoutVendorInput
  translators: TranslatorUpdateManyWithoutVendorInput
  copyrightHolders: CopyrightHolderUpdateManyWithoutVendorInput
  documents: DocumentUpdateManyInput
  billingInformation: VendorBillingInformationUpdateOneRequiredInput
  phoneNumber: String
  email: String
}

input VendorUpdateInput {
  type: VendorType
  authors: AuthorUpdateManyWithoutVendorInput
  translators: TranslatorUpdateManyWithoutVendorInput
  copyrightHolders: CopyrightHolderUpdateManyWithoutVendorInput
  documents: DocumentUpdateManyInput
  billingInformation: VendorBillingInformationUpdateOneRequiredInput
  phoneNumber: String
  email: String
}

input VendorUpdateManyMutationInput {
  type: VendorType
  phoneNumber: String
  email: String
}

input VendorUpdateOneInput {
  create: VendorCreateInput
  update: VendorUpdateDataInput
  upsert: VendorUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneRequiredInput {
  create: VendorCreateInput
  update: VendorUpdateDataInput
  upsert: VendorUpsertNestedInput
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneWithoutAuthorsInput {
  create: VendorCreateWithoutAuthorsInput
  update: VendorUpdateWithoutAuthorsDataInput
  upsert: VendorUpsertWithoutAuthorsInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneWithoutCopyrightHoldersInput {
  create: VendorCreateWithoutCopyrightHoldersInput
  update: VendorUpdateWithoutCopyrightHoldersDataInput
  upsert: VendorUpsertWithoutCopyrightHoldersInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateOneWithoutTranslatorsInput {
  create: VendorCreateWithoutTranslatorsInput
  update: VendorUpdateWithoutTranslatorsDataInput
  upsert: VendorUpsertWithoutTranslatorsInput
  delete: Boolean
  disconnect: Boolean
  connect: VendorWhereUniqueInput
}

input VendorUpdateWithoutAuthorsDataInput {
  type: VendorType
  translators: TranslatorUpdateManyWithoutVendorInput
  copyrightHolders: CopyrightHolderUpdateManyWithoutVendorInput
  documents: DocumentUpdateManyInput
  billingInformation: VendorBillingInformationUpdateOneRequiredInput
  phoneNumber: String
  email: String
}

input VendorUpdateWithoutCopyrightHoldersDataInput {
  type: VendorType
  authors: AuthorUpdateManyWithoutVendorInput
  translators: TranslatorUpdateManyWithoutVendorInput
  documents: DocumentUpdateManyInput
  billingInformation: VendorBillingInformationUpdateOneRequiredInput
  phoneNumber: String
  email: String
}

input VendorUpdateWithoutTranslatorsDataInput {
  type: VendorType
  authors: AuthorUpdateManyWithoutVendorInput
  copyrightHolders: CopyrightHolderUpdateManyWithoutVendorInput
  documents: DocumentUpdateManyInput
  billingInformation: VendorBillingInformationUpdateOneRequiredInput
  phoneNumber: String
  email: String
}

input VendorUpsertNestedInput {
  update: VendorUpdateDataInput!
  create: VendorCreateInput!
}

input VendorUpsertWithoutAuthorsInput {
  update: VendorUpdateWithoutAuthorsDataInput!
  create: VendorCreateWithoutAuthorsInput!
}

input VendorUpsertWithoutCopyrightHoldersInput {
  update: VendorUpdateWithoutCopyrightHoldersDataInput!
  create: VendorCreateWithoutCopyrightHoldersInput!
}

input VendorUpsertWithoutTranslatorsInput {
  update: VendorUpdateWithoutTranslatorsDataInput!
  create: VendorCreateWithoutTranslatorsInput!
}

input VendorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: VendorType
  type_not: VendorType
  type_in: [VendorType!]
  type_not_in: [VendorType!]
  authors_every: AuthorWhereInput
  authors_some: AuthorWhereInput
  authors_none: AuthorWhereInput
  translators_every: TranslatorWhereInput
  translators_some: TranslatorWhereInput
  translators_none: TranslatorWhereInput
  copyrightHolders_every: CopyrightHolderWhereInput
  copyrightHolders_some: CopyrightHolderWhereInput
  copyrightHolders_none: CopyrightHolderWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  documents_every: DocumentWhereInput
  documents_some: DocumentWhereInput
  documents_none: DocumentWhereInput
  billingInformation: VendorBillingInformationWhereInput
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  AND: [VendorWhereInput!]
  OR: [VendorWhereInput!]
  NOT: [VendorWhereInput!]
}

input VendorWhereUniqueInput {
  id: ID
}
`