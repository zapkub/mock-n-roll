// Code generated by Prisma (prisma@1.27.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  adsBanner: (where?: AdsBannerWhereInput) => Promise<boolean>;
  author: (where?: AuthorWhereInput) => Promise<boolean>;
  behavior: (where?: BehaviorWhereInput) => Promise<boolean>;
  book: (where?: BookWhereInput) => Promise<boolean>;
  bookEpisode: (where?: BookEpisodeWhereInput) => Promise<boolean>;
  bookEpisodeContent: (
    where?: BookEpisodeContentWhereInput
  ) => Promise<boolean>;
  bookEpisodeRecentRead: (
    where?: BookEpisodeRecentReadWhereInput
  ) => Promise<boolean>;
  bookEpisodeReviewPost: (
    where?: BookEpisodeReviewPostWhereInput
  ) => Promise<boolean>;
  bookRecommended: (where?: BookRecommendedWhereInput) => Promise<boolean>;
  bookVolume: (where?: BookVolumeWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  copyrightHolder: (where?: CopyrightHolderWhereInput) => Promise<boolean>;
  dashbardDataCache: (where?: DashbardDataCacheWhereInput) => Promise<boolean>;
  document: (where?: DocumentWhereInput) => Promise<boolean>;
  exchangeTier: (where?: ExchangeTierWhereInput) => Promise<boolean>;
  exchangeTransaction: (
    where?: ExchangeTransactionWhereInput
  ) => Promise<boolean>;
  exchangeTransactionStatusHistory: (
    where?: ExchangeTransactionStatusHistoryWhereInput
  ) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  history: (where?: HistoryWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  itemAsset: (where?: ItemAssetWhereInput) => Promise<boolean>;
  migration: (where?: MigrationWhereInput) => Promise<boolean>;
  pageView: (where?: PageViewWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  price: (where?: PriceWhereInput) => Promise<boolean>;
  promotion: (where?: PromotionWhereInput) => Promise<boolean>;
  publishTimeline: (where?: PublishTimelineWhereInput) => Promise<boolean>;
  remoteConfig: (where?: RemoteConfigWhereInput) => Promise<boolean>;
  revenueSharing: (where?: RevenueSharingWhereInput) => Promise<boolean>;
  shelf: (where?: ShelfWhereInput) => Promise<boolean>;
  systemConfig: (where?: SystemConfigWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  translator: (where?: TranslatorWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userAdmin: (where?: UserAdminWhereInput) => Promise<boolean>;
  userAdminPermission: (
    where?: UserAdminPermissionWhereInput
  ) => Promise<boolean>;
  userAdminRole: (where?: UserAdminRoleWhereInput) => Promise<boolean>;
  vendor: (where?: VendorWhereInput) => Promise<boolean>;
  vendorBillingInformation: (
    where?: VendorBillingInformationWhereInput
  ) => Promise<boolean>;
  vendorRevenue: (where?: VendorRevenueWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  adsBanner: (where: AdsBannerWhereUniqueInput) => AdsBannerPromise;
  adsBanners: (
    args?: {
      where?: AdsBannerWhereInput;
      orderBy?: AdsBannerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AdsBanner>;
  adsBannersConnection: (
    args?: {
      where?: AdsBannerWhereInput;
      orderBy?: AdsBannerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AdsBannerConnectionPromise;
  author: (where: AuthorWhereUniqueInput) => AuthorPromise;
  authors: (
    args?: {
      where?: AuthorWhereInput;
      orderBy?: AuthorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Author>;
  authorsConnection: (
    args?: {
      where?: AuthorWhereInput;
      orderBy?: AuthorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AuthorConnectionPromise;
  behavior: (where: BehaviorWhereUniqueInput) => BehaviorPromise;
  behaviors: (
    args?: {
      where?: BehaviorWhereInput;
      orderBy?: BehaviorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Behavior>;
  behaviorsConnection: (
    args?: {
      where?: BehaviorWhereInput;
      orderBy?: BehaviorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BehaviorConnectionPromise;
  book: (where: BookWhereUniqueInput) => BookPromise;
  books: (
    args?: {
      where?: BookWhereInput;
      orderBy?: BookOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Book>;
  booksConnection: (
    args?: {
      where?: BookWhereInput;
      orderBy?: BookOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookConnectionPromise;
  bookEpisode: (where: BookEpisodeWhereUniqueInput) => BookEpisodePromise;
  bookEpisodes: (
    args?: {
      where?: BookEpisodeWhereInput;
      orderBy?: BookEpisodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookEpisode>;
  bookEpisodesConnection: (
    args?: {
      where?: BookEpisodeWhereInput;
      orderBy?: BookEpisodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookEpisodeConnectionPromise;
  bookEpisodeContent: (
    where: BookEpisodeContentWhereUniqueInput
  ) => BookEpisodeContentPromise;
  bookEpisodeContents: (
    args?: {
      where?: BookEpisodeContentWhereInput;
      orderBy?: BookEpisodeContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookEpisodeContent>;
  bookEpisodeContentsConnection: (
    args?: {
      where?: BookEpisodeContentWhereInput;
      orderBy?: BookEpisodeContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookEpisodeContentConnectionPromise;
  bookEpisodeRecentRead: (
    where: BookEpisodeRecentReadWhereUniqueInput
  ) => BookEpisodeRecentReadPromise;
  bookEpisodeRecentReads: (
    args?: {
      where?: BookEpisodeRecentReadWhereInput;
      orderBy?: BookEpisodeRecentReadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookEpisodeRecentRead>;
  bookEpisodeRecentReadsConnection: (
    args?: {
      where?: BookEpisodeRecentReadWhereInput;
      orderBy?: BookEpisodeRecentReadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookEpisodeRecentReadConnectionPromise;
  bookEpisodeReviewPost: (
    where: BookEpisodeReviewPostWhereUniqueInput
  ) => BookEpisodeReviewPostPromise;
  bookEpisodeReviewPosts: (
    args?: {
      where?: BookEpisodeReviewPostWhereInput;
      orderBy?: BookEpisodeReviewPostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookEpisodeReviewPost>;
  bookEpisodeReviewPostsConnection: (
    args?: {
      where?: BookEpisodeReviewPostWhereInput;
      orderBy?: BookEpisodeReviewPostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookEpisodeReviewPostConnectionPromise;
  bookRecommended: (
    where: BookRecommendedWhereUniqueInput
  ) => BookRecommendedPromise;
  bookRecommendeds: (
    args?: {
      where?: BookRecommendedWhereInput;
      orderBy?: BookRecommendedOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookRecommended>;
  bookRecommendedsConnection: (
    args?: {
      where?: BookRecommendedWhereInput;
      orderBy?: BookRecommendedOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookRecommendedConnectionPromise;
  bookVolume: (where: BookVolumeWhereUniqueInput) => BookVolumePromise;
  bookVolumes: (
    args?: {
      where?: BookVolumeWhereInput;
      orderBy?: BookVolumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BookVolume>;
  bookVolumesConnection: (
    args?: {
      where?: BookVolumeWhereInput;
      orderBy?: BookVolumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BookVolumeConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryPromise;
  categories: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Category>;
  categoriesConnection: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CategoryConnectionPromise;
  copyrightHolder: (
    where: CopyrightHolderWhereUniqueInput
  ) => CopyrightHolderPromise;
  copyrightHolders: (
    args?: {
      where?: CopyrightHolderWhereInput;
      orderBy?: CopyrightHolderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CopyrightHolder>;
  copyrightHoldersConnection: (
    args?: {
      where?: CopyrightHolderWhereInput;
      orderBy?: CopyrightHolderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CopyrightHolderConnectionPromise;
  dashbardDataCaches: (
    args?: {
      where?: DashbardDataCacheWhereInput;
      orderBy?: DashbardDataCacheOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DashbardDataCache>;
  dashbardDataCachesConnection: (
    args?: {
      where?: DashbardDataCacheWhereInput;
      orderBy?: DashbardDataCacheOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DashbardDataCacheConnectionPromise;
  document: (where: DocumentWhereUniqueInput) => DocumentPromise;
  documents: (
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Document>;
  documentsConnection: (
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DocumentConnectionPromise;
  exchangeTier: (where: ExchangeTierWhereUniqueInput) => ExchangeTierPromise;
  exchangeTiers: (
    args?: {
      where?: ExchangeTierWhereInput;
      orderBy?: ExchangeTierOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExchangeTier>;
  exchangeTiersConnection: (
    args?: {
      where?: ExchangeTierWhereInput;
      orderBy?: ExchangeTierOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExchangeTierConnectionPromise;
  exchangeTransaction: (
    where: ExchangeTransactionWhereUniqueInput
  ) => ExchangeTransactionPromise;
  exchangeTransactions: (
    args?: {
      where?: ExchangeTransactionWhereInput;
      orderBy?: ExchangeTransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExchangeTransaction>;
  exchangeTransactionsConnection: (
    args?: {
      where?: ExchangeTransactionWhereInput;
      orderBy?: ExchangeTransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExchangeTransactionConnectionPromise;
  exchangeTransactionStatusHistory: (
    where: ExchangeTransactionStatusHistoryWhereUniqueInput
  ) => ExchangeTransactionStatusHistoryPromise;
  exchangeTransactionStatusHistories: (
    args?: {
      where?: ExchangeTransactionStatusHistoryWhereInput;
      orderBy?: ExchangeTransactionStatusHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExchangeTransactionStatusHistory>;
  exchangeTransactionStatusHistoriesConnection: (
    args?: {
      where?: ExchangeTransactionStatusHistoryWhereInput;
      orderBy?: ExchangeTransactionStatusHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExchangeTransactionStatusHistoryConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<File>;
  filesConnection: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FileConnectionPromise;
  history: (where: HistoryWhereUniqueInput) => HistoryPromise;
  histories: (
    args?: {
      where?: HistoryWhereInput;
      orderBy?: HistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<History>;
  historiesConnection: (
    args?: {
      where?: HistoryWhereInput;
      orderBy?: HistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HistoryConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImagePromise;
  images: (
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Image>;
  imagesConnection: (
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ImageConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemPromise;
  items: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Item>;
  itemsConnection: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ItemConnectionPromise;
  itemAsset: (where: ItemAssetWhereUniqueInput) => ItemAssetPromise;
  itemAssets: (
    args?: {
      where?: ItemAssetWhereInput;
      orderBy?: ItemAssetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ItemAsset>;
  itemAssetsConnection: (
    args?: {
      where?: ItemAssetWhereInput;
      orderBy?: ItemAssetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ItemAssetConnectionPromise;
  migration: (where: MigrationWhereUniqueInput) => MigrationPromise;
  migrations: (
    args?: {
      where?: MigrationWhereInput;
      orderBy?: MigrationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Migration>;
  migrationsConnection: (
    args?: {
      where?: MigrationWhereInput;
      orderBy?: MigrationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MigrationConnectionPromise;
  pageView: (where: PageViewWhereUniqueInput) => PageViewPromise;
  pageViews: (
    args?: {
      where?: PageViewWhereInput;
      orderBy?: PageViewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PageView>;
  pageViewsConnection: (
    args?: {
      where?: PageViewWhereInput;
      orderBy?: PageViewOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PageViewConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  price: (where: PriceWhereUniqueInput) => PricePromise;
  prices: (
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Price>;
  pricesConnection: (
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PriceConnectionPromise;
  promotion: (where: PromotionWhereUniqueInput) => PromotionPromise;
  promotions: (
    args?: {
      where?: PromotionWhereInput;
      orderBy?: PromotionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Promotion>;
  promotionsConnection: (
    args?: {
      where?: PromotionWhereInput;
      orderBy?: PromotionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PromotionConnectionPromise;
  publishTimelines: (
    args?: {
      where?: PublishTimelineWhereInput;
      orderBy?: PublishTimelineOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PublishTimeline>;
  publishTimelinesConnection: (
    args?: {
      where?: PublishTimelineWhereInput;
      orderBy?: PublishTimelineOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PublishTimelineConnectionPromise;
  remoteConfig: (where: RemoteConfigWhereUniqueInput) => RemoteConfigPromise;
  remoteConfigs: (
    args?: {
      where?: RemoteConfigWhereInput;
      orderBy?: RemoteConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RemoteConfig>;
  remoteConfigsConnection: (
    args?: {
      where?: RemoteConfigWhereInput;
      orderBy?: RemoteConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RemoteConfigConnectionPromise;
  revenueSharing: (
    where: RevenueSharingWhereUniqueInput
  ) => RevenueSharingPromise;
  revenueSharings: (
    args?: {
      where?: RevenueSharingWhereInput;
      orderBy?: RevenueSharingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RevenueSharing>;
  revenueSharingsConnection: (
    args?: {
      where?: RevenueSharingWhereInput;
      orderBy?: RevenueSharingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RevenueSharingConnectionPromise;
  shelf: (where: ShelfWhereUniqueInput) => ShelfPromise;
  shelves: (
    args?: {
      where?: ShelfWhereInput;
      orderBy?: ShelfOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Shelf>;
  shelvesConnection: (
    args?: {
      where?: ShelfWhereInput;
      orderBy?: ShelfOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ShelfConnectionPromise;
  systemConfig: (where: SystemConfigWhereUniqueInput) => SystemConfigPromise;
  systemConfigs: (
    args?: {
      where?: SystemConfigWhereInput;
      orderBy?: SystemConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SystemConfig>;
  systemConfigsConnection: (
    args?: {
      where?: SystemConfigWhereInput;
      orderBy?: SystemConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SystemConfigConnectionPromise;
  transaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  transactions: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Transaction>;
  transactionsConnection: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransactionConnectionPromise;
  translator: (where: TranslatorWhereUniqueInput) => TranslatorPromise;
  translators: (
    args?: {
      where?: TranslatorWhereInput;
      orderBy?: TranslatorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Translator>;
  translatorsConnection: (
    args?: {
      where?: TranslatorWhereInput;
      orderBy?: TranslatorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TranslatorConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userAdmin: (where: UserAdminWhereUniqueInput) => UserAdminPromise;
  userAdmins: (
    args?: {
      where?: UserAdminWhereInput;
      orderBy?: UserAdminOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserAdmin>;
  userAdminsConnection: (
    args?: {
      where?: UserAdminWhereInput;
      orderBy?: UserAdminOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserAdminConnectionPromise;
  userAdminPermission: (
    where: UserAdminPermissionWhereUniqueInput
  ) => UserAdminPermissionPromise;
  userAdminPermissions: (
    args?: {
      where?: UserAdminPermissionWhereInput;
      orderBy?: UserAdminPermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserAdminPermission>;
  userAdminPermissionsConnection: (
    args?: {
      where?: UserAdminPermissionWhereInput;
      orderBy?: UserAdminPermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserAdminPermissionConnectionPromise;
  userAdminRole: (where: UserAdminRoleWhereUniqueInput) => UserAdminRolePromise;
  userAdminRoles: (
    args?: {
      where?: UserAdminRoleWhereInput;
      orderBy?: UserAdminRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserAdminRole>;
  userAdminRolesConnection: (
    args?: {
      where?: UserAdminRoleWhereInput;
      orderBy?: UserAdminRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserAdminRoleConnectionPromise;
  vendor: (where: VendorWhereUniqueInput) => VendorPromise;
  vendors: (
    args?: {
      where?: VendorWhereInput;
      orderBy?: VendorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Vendor>;
  vendorsConnection: (
    args?: {
      where?: VendorWhereInput;
      orderBy?: VendorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VendorConnectionPromise;
  vendorBillingInformation: (
    where: VendorBillingInformationWhereUniqueInput
  ) => VendorBillingInformationPromise;
  vendorBillingInformations: (
    args?: {
      where?: VendorBillingInformationWhereInput;
      orderBy?: VendorBillingInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<VendorBillingInformation>;
  vendorBillingInformationsConnection: (
    args?: {
      where?: VendorBillingInformationWhereInput;
      orderBy?: VendorBillingInformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VendorBillingInformationConnectionPromise;
  vendorRevenue: (where: VendorRevenueWhereUniqueInput) => VendorRevenuePromise;
  vendorRevenues: (
    args?: {
      where?: VendorRevenueWhereInput;
      orderBy?: VendorRevenueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<VendorRevenue>;
  vendorRevenuesConnection: (
    args?: {
      where?: VendorRevenueWhereInput;
      orderBy?: VendorRevenueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VendorRevenueConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAdsBanner: (data: AdsBannerCreateInput) => AdsBannerPromise;
  updateAdsBanner: (
    args: { data: AdsBannerUpdateInput; where: AdsBannerWhereUniqueInput }
  ) => AdsBannerPromise;
  updateManyAdsBanners: (
    args: {
      data: AdsBannerUpdateManyMutationInput;
      where?: AdsBannerWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAdsBanner: (
    args: {
      where: AdsBannerWhereUniqueInput;
      create: AdsBannerCreateInput;
      update: AdsBannerUpdateInput;
    }
  ) => AdsBannerPromise;
  deleteAdsBanner: (where: AdsBannerWhereUniqueInput) => AdsBannerPromise;
  deleteManyAdsBanners: (where?: AdsBannerWhereInput) => BatchPayloadPromise;
  createAuthor: (data: AuthorCreateInput) => AuthorPromise;
  updateAuthor: (
    args: { data: AuthorUpdateInput; where: AuthorWhereUniqueInput }
  ) => AuthorPromise;
  updateManyAuthors: (
    args: { data: AuthorUpdateManyMutationInput; where?: AuthorWhereInput }
  ) => BatchPayloadPromise;
  upsertAuthor: (
    args: {
      where: AuthorWhereUniqueInput;
      create: AuthorCreateInput;
      update: AuthorUpdateInput;
    }
  ) => AuthorPromise;
  deleteAuthor: (where: AuthorWhereUniqueInput) => AuthorPromise;
  deleteManyAuthors: (where?: AuthorWhereInput) => BatchPayloadPromise;
  createBehavior: (data: BehaviorCreateInput) => BehaviorPromise;
  updateBehavior: (
    args: { data: BehaviorUpdateInput; where: BehaviorWhereUniqueInput }
  ) => BehaviorPromise;
  updateManyBehaviors: (
    args: { data: BehaviorUpdateManyMutationInput; where?: BehaviorWhereInput }
  ) => BatchPayloadPromise;
  upsertBehavior: (
    args: {
      where: BehaviorWhereUniqueInput;
      create: BehaviorCreateInput;
      update: BehaviorUpdateInput;
    }
  ) => BehaviorPromise;
  deleteBehavior: (where: BehaviorWhereUniqueInput) => BehaviorPromise;
  deleteManyBehaviors: (where?: BehaviorWhereInput) => BatchPayloadPromise;
  createBook: (data: BookCreateInput) => BookPromise;
  updateBook: (
    args: { data: BookUpdateInput; where: BookWhereUniqueInput }
  ) => BookPromise;
  updateManyBooks: (
    args: { data: BookUpdateManyMutationInput; where?: BookWhereInput }
  ) => BatchPayloadPromise;
  upsertBook: (
    args: {
      where: BookWhereUniqueInput;
      create: BookCreateInput;
      update: BookUpdateInput;
    }
  ) => BookPromise;
  deleteBook: (where: BookWhereUniqueInput) => BookPromise;
  deleteManyBooks: (where?: BookWhereInput) => BatchPayloadPromise;
  createBookEpisode: (data: BookEpisodeCreateInput) => BookEpisodePromise;
  updateBookEpisode: (
    args: { data: BookEpisodeUpdateInput; where: BookEpisodeWhereUniqueInput }
  ) => BookEpisodePromise;
  updateManyBookEpisodes: (
    args: {
      data: BookEpisodeUpdateManyMutationInput;
      where?: BookEpisodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBookEpisode: (
    args: {
      where: BookEpisodeWhereUniqueInput;
      create: BookEpisodeCreateInput;
      update: BookEpisodeUpdateInput;
    }
  ) => BookEpisodePromise;
  deleteBookEpisode: (where: BookEpisodeWhereUniqueInput) => BookEpisodePromise;
  deleteManyBookEpisodes: (
    where?: BookEpisodeWhereInput
  ) => BatchPayloadPromise;
  createBookEpisodeContent: (
    data: BookEpisodeContentCreateInput
  ) => BookEpisodeContentPromise;
  updateBookEpisodeContent: (
    args: {
      data: BookEpisodeContentUpdateInput;
      where: BookEpisodeContentWhereUniqueInput;
    }
  ) => BookEpisodeContentPromise;
  updateManyBookEpisodeContents: (
    args: {
      data: BookEpisodeContentUpdateManyMutationInput;
      where?: BookEpisodeContentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBookEpisodeContent: (
    args: {
      where: BookEpisodeContentWhereUniqueInput;
      create: BookEpisodeContentCreateInput;
      update: BookEpisodeContentUpdateInput;
    }
  ) => BookEpisodeContentPromise;
  deleteBookEpisodeContent: (
    where: BookEpisodeContentWhereUniqueInput
  ) => BookEpisodeContentPromise;
  deleteManyBookEpisodeContents: (
    where?: BookEpisodeContentWhereInput
  ) => BatchPayloadPromise;
  createBookEpisodeRecentRead: (
    data: BookEpisodeRecentReadCreateInput
  ) => BookEpisodeRecentReadPromise;
  updateBookEpisodeRecentRead: (
    args: {
      data: BookEpisodeRecentReadUpdateInput;
      where: BookEpisodeRecentReadWhereUniqueInput;
    }
  ) => BookEpisodeRecentReadPromise;
  updateManyBookEpisodeRecentReads: (
    args: {
      data: BookEpisodeRecentReadUpdateManyMutationInput;
      where?: BookEpisodeRecentReadWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBookEpisodeRecentRead: (
    args: {
      where: BookEpisodeRecentReadWhereUniqueInput;
      create: BookEpisodeRecentReadCreateInput;
      update: BookEpisodeRecentReadUpdateInput;
    }
  ) => BookEpisodeRecentReadPromise;
  deleteBookEpisodeRecentRead: (
    where: BookEpisodeRecentReadWhereUniqueInput
  ) => BookEpisodeRecentReadPromise;
  deleteManyBookEpisodeRecentReads: (
    where?: BookEpisodeRecentReadWhereInput
  ) => BatchPayloadPromise;
  createBookEpisodeReviewPost: (
    data: BookEpisodeReviewPostCreateInput
  ) => BookEpisodeReviewPostPromise;
  updateBookEpisodeReviewPost: (
    args: {
      data: BookEpisodeReviewPostUpdateInput;
      where: BookEpisodeReviewPostWhereUniqueInput;
    }
  ) => BookEpisodeReviewPostPromise;
  updateManyBookEpisodeReviewPosts: (
    args: {
      data: BookEpisodeReviewPostUpdateManyMutationInput;
      where?: BookEpisodeReviewPostWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBookEpisodeReviewPost: (
    args: {
      where: BookEpisodeReviewPostWhereUniqueInput;
      create: BookEpisodeReviewPostCreateInput;
      update: BookEpisodeReviewPostUpdateInput;
    }
  ) => BookEpisodeReviewPostPromise;
  deleteBookEpisodeReviewPost: (
    where: BookEpisodeReviewPostWhereUniqueInput
  ) => BookEpisodeReviewPostPromise;
  deleteManyBookEpisodeReviewPosts: (
    where?: BookEpisodeReviewPostWhereInput
  ) => BatchPayloadPromise;
  createBookRecommended: (
    data: BookRecommendedCreateInput
  ) => BookRecommendedPromise;
  updateBookRecommended: (
    args: {
      data: BookRecommendedUpdateInput;
      where: BookRecommendedWhereUniqueInput;
    }
  ) => BookRecommendedPromise;
  updateManyBookRecommendeds: (
    args: {
      data: BookRecommendedUpdateManyMutationInput;
      where?: BookRecommendedWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBookRecommended: (
    args: {
      where: BookRecommendedWhereUniqueInput;
      create: BookRecommendedCreateInput;
      update: BookRecommendedUpdateInput;
    }
  ) => BookRecommendedPromise;
  deleteBookRecommended: (
    where: BookRecommendedWhereUniqueInput
  ) => BookRecommendedPromise;
  deleteManyBookRecommendeds: (
    where?: BookRecommendedWhereInput
  ) => BatchPayloadPromise;
  createBookVolume: (data: BookVolumeCreateInput) => BookVolumePromise;
  updateBookVolume: (
    args: { data: BookVolumeUpdateInput; where: BookVolumeWhereUniqueInput }
  ) => BookVolumePromise;
  updateManyBookVolumes: (
    args: {
      data: BookVolumeUpdateManyMutationInput;
      where?: BookVolumeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBookVolume: (
    args: {
      where: BookVolumeWhereUniqueInput;
      create: BookVolumeCreateInput;
      update: BookVolumeUpdateInput;
    }
  ) => BookVolumePromise;
  deleteBookVolume: (where: BookVolumeWhereUniqueInput) => BookVolumePromise;
  deleteManyBookVolumes: (where?: BookVolumeWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (
    args: { data: CategoryUpdateInput; where: CategoryWhereUniqueInput }
  ) => CategoryPromise;
  updateManyCategories: (
    args: { data: CategoryUpdateManyMutationInput; where?: CategoryWhereInput }
  ) => BatchPayloadPromise;
  upsertCategory: (
    args: {
      where: CategoryWhereUniqueInput;
      create: CategoryCreateInput;
      update: CategoryUpdateInput;
    }
  ) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createCopyrightHolder: (
    data: CopyrightHolderCreateInput
  ) => CopyrightHolderPromise;
  updateCopyrightHolder: (
    args: {
      data: CopyrightHolderUpdateInput;
      where: CopyrightHolderWhereUniqueInput;
    }
  ) => CopyrightHolderPromise;
  updateManyCopyrightHolders: (
    args: {
      data: CopyrightHolderUpdateManyMutationInput;
      where?: CopyrightHolderWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCopyrightHolder: (
    args: {
      where: CopyrightHolderWhereUniqueInput;
      create: CopyrightHolderCreateInput;
      update: CopyrightHolderUpdateInput;
    }
  ) => CopyrightHolderPromise;
  deleteCopyrightHolder: (
    where: CopyrightHolderWhereUniqueInput
  ) => CopyrightHolderPromise;
  deleteManyCopyrightHolders: (
    where?: CopyrightHolderWhereInput
  ) => BatchPayloadPromise;
  createDashbardDataCache: (
    data: DashbardDataCacheCreateInput
  ) => DashbardDataCachePromise;
  updateManyDashbardDataCaches: (
    args: {
      data: DashbardDataCacheUpdateManyMutationInput;
      where?: DashbardDataCacheWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyDashbardDataCaches: (
    where?: DashbardDataCacheWhereInput
  ) => BatchPayloadPromise;
  createDocument: (data: DocumentCreateInput) => DocumentPromise;
  updateDocument: (
    args: { data: DocumentUpdateInput; where: DocumentWhereUniqueInput }
  ) => DocumentPromise;
  updateManyDocuments: (
    args: { data: DocumentUpdateManyMutationInput; where?: DocumentWhereInput }
  ) => BatchPayloadPromise;
  upsertDocument: (
    args: {
      where: DocumentWhereUniqueInput;
      create: DocumentCreateInput;
      update: DocumentUpdateInput;
    }
  ) => DocumentPromise;
  deleteDocument: (where: DocumentWhereUniqueInput) => DocumentPromise;
  deleteManyDocuments: (where?: DocumentWhereInput) => BatchPayloadPromise;
  createExchangeTier: (data: ExchangeTierCreateInput) => ExchangeTierPromise;
  updateExchangeTier: (
    args: { data: ExchangeTierUpdateInput; where: ExchangeTierWhereUniqueInput }
  ) => ExchangeTierPromise;
  updateManyExchangeTiers: (
    args: {
      data: ExchangeTierUpdateManyMutationInput;
      where?: ExchangeTierWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExchangeTier: (
    args: {
      where: ExchangeTierWhereUniqueInput;
      create: ExchangeTierCreateInput;
      update: ExchangeTierUpdateInput;
    }
  ) => ExchangeTierPromise;
  deleteExchangeTier: (
    where: ExchangeTierWhereUniqueInput
  ) => ExchangeTierPromise;
  deleteManyExchangeTiers: (
    where?: ExchangeTierWhereInput
  ) => BatchPayloadPromise;
  createExchangeTransaction: (
    data: ExchangeTransactionCreateInput
  ) => ExchangeTransactionPromise;
  updateExchangeTransaction: (
    args: {
      data: ExchangeTransactionUpdateInput;
      where: ExchangeTransactionWhereUniqueInput;
    }
  ) => ExchangeTransactionPromise;
  updateManyExchangeTransactions: (
    args: {
      data: ExchangeTransactionUpdateManyMutationInput;
      where?: ExchangeTransactionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExchangeTransaction: (
    args: {
      where: ExchangeTransactionWhereUniqueInput;
      create: ExchangeTransactionCreateInput;
      update: ExchangeTransactionUpdateInput;
    }
  ) => ExchangeTransactionPromise;
  deleteExchangeTransaction: (
    where: ExchangeTransactionWhereUniqueInput
  ) => ExchangeTransactionPromise;
  deleteManyExchangeTransactions: (
    where?: ExchangeTransactionWhereInput
  ) => BatchPayloadPromise;
  createExchangeTransactionStatusHistory: (
    data: ExchangeTransactionStatusHistoryCreateInput
  ) => ExchangeTransactionStatusHistoryPromise;
  updateExchangeTransactionStatusHistory: (
    args: {
      data: ExchangeTransactionStatusHistoryUpdateInput;
      where: ExchangeTransactionStatusHistoryWhereUniqueInput;
    }
  ) => ExchangeTransactionStatusHistoryPromise;
  updateManyExchangeTransactionStatusHistories: (
    args: {
      data: ExchangeTransactionStatusHistoryUpdateManyMutationInput;
      where?: ExchangeTransactionStatusHistoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExchangeTransactionStatusHistory: (
    args: {
      where: ExchangeTransactionStatusHistoryWhereUniqueInput;
      create: ExchangeTransactionStatusHistoryCreateInput;
      update: ExchangeTransactionStatusHistoryUpdateInput;
    }
  ) => ExchangeTransactionStatusHistoryPromise;
  deleteExchangeTransactionStatusHistory: (
    where: ExchangeTransactionStatusHistoryWhereUniqueInput
  ) => ExchangeTransactionStatusHistoryPromise;
  deleteManyExchangeTransactionStatusHistories: (
    where?: ExchangeTransactionStatusHistoryWhereInput
  ) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (
    args: { data: FileUpdateInput; where: FileWhereUniqueInput }
  ) => FilePromise;
  updateManyFiles: (
    args: { data: FileUpdateManyMutationInput; where?: FileWhereInput }
  ) => BatchPayloadPromise;
  upsertFile: (
    args: {
      where: FileWhereUniqueInput;
      create: FileCreateInput;
      update: FileUpdateInput;
    }
  ) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createHistory: (data: HistoryCreateInput) => HistoryPromise;
  updateHistory: (
    args: { data: HistoryUpdateInput; where: HistoryWhereUniqueInput }
  ) => HistoryPromise;
  updateManyHistories: (
    args: { data: HistoryUpdateManyMutationInput; where?: HistoryWhereInput }
  ) => BatchPayloadPromise;
  upsertHistory: (
    args: {
      where: HistoryWhereUniqueInput;
      create: HistoryCreateInput;
      update: HistoryUpdateInput;
    }
  ) => HistoryPromise;
  deleteHistory: (where: HistoryWhereUniqueInput) => HistoryPromise;
  deleteManyHistories: (where?: HistoryWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (
    args: { data: ImageUpdateInput; where: ImageWhereUniqueInput }
  ) => ImagePromise;
  updateManyImages: (
    args: { data: ImageUpdateManyMutationInput; where?: ImageWhereInput }
  ) => BatchPayloadPromise;
  upsertImage: (
    args: {
      where: ImageWhereUniqueInput;
      create: ImageCreateInput;
      update: ImageUpdateInput;
    }
  ) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (
    args: { data: ItemUpdateInput; where: ItemWhereUniqueInput }
  ) => ItemPromise;
  updateManyItems: (
    args: { data: ItemUpdateManyMutationInput; where?: ItemWhereInput }
  ) => BatchPayloadPromise;
  upsertItem: (
    args: {
      where: ItemWhereUniqueInput;
      create: ItemCreateInput;
      update: ItemUpdateInput;
    }
  ) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createItemAsset: (data: ItemAssetCreateInput) => ItemAssetPromise;
  updateItemAsset: (
    args: { data: ItemAssetUpdateInput; where: ItemAssetWhereUniqueInput }
  ) => ItemAssetPromise;
  updateManyItemAssets: (
    args: {
      data: ItemAssetUpdateManyMutationInput;
      where?: ItemAssetWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertItemAsset: (
    args: {
      where: ItemAssetWhereUniqueInput;
      create: ItemAssetCreateInput;
      update: ItemAssetUpdateInput;
    }
  ) => ItemAssetPromise;
  deleteItemAsset: (where: ItemAssetWhereUniqueInput) => ItemAssetPromise;
  deleteManyItemAssets: (where?: ItemAssetWhereInput) => BatchPayloadPromise;
  createMigration: (data: MigrationCreateInput) => MigrationPromise;
  updateMigration: (
    args: { data: MigrationUpdateInput; where: MigrationWhereUniqueInput }
  ) => MigrationPromise;
  updateManyMigrations: (
    args: {
      data: MigrationUpdateManyMutationInput;
      where?: MigrationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMigration: (
    args: {
      where: MigrationWhereUniqueInput;
      create: MigrationCreateInput;
      update: MigrationUpdateInput;
    }
  ) => MigrationPromise;
  deleteMigration: (where: MigrationWhereUniqueInput) => MigrationPromise;
  deleteManyMigrations: (where?: MigrationWhereInput) => BatchPayloadPromise;
  createPageView: (data: PageViewCreateInput) => PageViewPromise;
  updatePageView: (
    args: { data: PageViewUpdateInput; where: PageViewWhereUniqueInput }
  ) => PageViewPromise;
  updateManyPageViews: (
    args: { data: PageViewUpdateManyMutationInput; where?: PageViewWhereInput }
  ) => BatchPayloadPromise;
  upsertPageView: (
    args: {
      where: PageViewWhereUniqueInput;
      create: PageViewCreateInput;
      update: PageViewUpdateInput;
    }
  ) => PageViewPromise;
  deletePageView: (where: PageViewWhereUniqueInput) => PageViewPromise;
  deleteManyPageViews: (where?: PageViewWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createPrice: (data: PriceCreateInput) => PricePromise;
  updatePrice: (
    args: { data: PriceUpdateInput; where: PriceWhereUniqueInput }
  ) => PricePromise;
  updateManyPrices: (
    args: { data: PriceUpdateManyMutationInput; where?: PriceWhereInput }
  ) => BatchPayloadPromise;
  upsertPrice: (
    args: {
      where: PriceWhereUniqueInput;
      create: PriceCreateInput;
      update: PriceUpdateInput;
    }
  ) => PricePromise;
  deletePrice: (where: PriceWhereUniqueInput) => PricePromise;
  deleteManyPrices: (where?: PriceWhereInput) => BatchPayloadPromise;
  createPromotion: (data: PromotionCreateInput) => PromotionPromise;
  updatePromotion: (
    args: { data: PromotionUpdateInput; where: PromotionWhereUniqueInput }
  ) => PromotionPromise;
  updateManyPromotions: (
    args: {
      data: PromotionUpdateManyMutationInput;
      where?: PromotionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPromotion: (
    args: {
      where: PromotionWhereUniqueInput;
      create: PromotionCreateInput;
      update: PromotionUpdateInput;
    }
  ) => PromotionPromise;
  deletePromotion: (where: PromotionWhereUniqueInput) => PromotionPromise;
  deleteManyPromotions: (where?: PromotionWhereInput) => BatchPayloadPromise;
  createPublishTimeline: (
    data: PublishTimelineCreateInput
  ) => PublishTimelinePromise;
  updateManyPublishTimelines: (
    args: {
      data: PublishTimelineUpdateManyMutationInput;
      where?: PublishTimelineWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyPublishTimelines: (
    where?: PublishTimelineWhereInput
  ) => BatchPayloadPromise;
  createRemoteConfig: (data: RemoteConfigCreateInput) => RemoteConfigPromise;
  updateRemoteConfig: (
    args: { data: RemoteConfigUpdateInput; where: RemoteConfigWhereUniqueInput }
  ) => RemoteConfigPromise;
  updateManyRemoteConfigs: (
    args: {
      data: RemoteConfigUpdateManyMutationInput;
      where?: RemoteConfigWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRemoteConfig: (
    args: {
      where: RemoteConfigWhereUniqueInput;
      create: RemoteConfigCreateInput;
      update: RemoteConfigUpdateInput;
    }
  ) => RemoteConfigPromise;
  deleteRemoteConfig: (
    where: RemoteConfigWhereUniqueInput
  ) => RemoteConfigPromise;
  deleteManyRemoteConfigs: (
    where?: RemoteConfigWhereInput
  ) => BatchPayloadPromise;
  createRevenueSharing: (
    data: RevenueSharingCreateInput
  ) => RevenueSharingPromise;
  updateRevenueSharing: (
    args: {
      data: RevenueSharingUpdateInput;
      where: RevenueSharingWhereUniqueInput;
    }
  ) => RevenueSharingPromise;
  updateManyRevenueSharings: (
    args: {
      data: RevenueSharingUpdateManyMutationInput;
      where?: RevenueSharingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRevenueSharing: (
    args: {
      where: RevenueSharingWhereUniqueInput;
      create: RevenueSharingCreateInput;
      update: RevenueSharingUpdateInput;
    }
  ) => RevenueSharingPromise;
  deleteRevenueSharing: (
    where: RevenueSharingWhereUniqueInput
  ) => RevenueSharingPromise;
  deleteManyRevenueSharings: (
    where?: RevenueSharingWhereInput
  ) => BatchPayloadPromise;
  createShelf: (data: ShelfCreateInput) => ShelfPromise;
  updateShelf: (
    args: { data: ShelfUpdateInput; where: ShelfWhereUniqueInput }
  ) => ShelfPromise;
  updateManyShelves: (
    args: { data: ShelfUpdateManyMutationInput; where?: ShelfWhereInput }
  ) => BatchPayloadPromise;
  upsertShelf: (
    args: {
      where: ShelfWhereUniqueInput;
      create: ShelfCreateInput;
      update: ShelfUpdateInput;
    }
  ) => ShelfPromise;
  deleteShelf: (where: ShelfWhereUniqueInput) => ShelfPromise;
  deleteManyShelves: (where?: ShelfWhereInput) => BatchPayloadPromise;
  createSystemConfig: (data: SystemConfigCreateInput) => SystemConfigPromise;
  updateSystemConfig: (
    args: { data: SystemConfigUpdateInput; where: SystemConfigWhereUniqueInput }
  ) => SystemConfigPromise;
  updateManySystemConfigs: (
    args: {
      data: SystemConfigUpdateManyMutationInput;
      where?: SystemConfigWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSystemConfig: (
    args: {
      where: SystemConfigWhereUniqueInput;
      create: SystemConfigCreateInput;
      update: SystemConfigUpdateInput;
    }
  ) => SystemConfigPromise;
  deleteSystemConfig: (
    where: SystemConfigWhereUniqueInput
  ) => SystemConfigPromise;
  deleteManySystemConfigs: (
    where?: SystemConfigWhereInput
  ) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (
    args: { data: TransactionUpdateInput; where: TransactionWhereUniqueInput }
  ) => TransactionPromise;
  updateManyTransactions: (
    args: {
      data: TransactionUpdateManyMutationInput;
      where?: TransactionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTransaction: (
    args: {
      where: TransactionWhereUniqueInput;
      create: TransactionCreateInput;
      update: TransactionUpdateInput;
    }
  ) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createTranslator: (data: TranslatorCreateInput) => TranslatorPromise;
  updateTranslator: (
    args: { data: TranslatorUpdateInput; where: TranslatorWhereUniqueInput }
  ) => TranslatorPromise;
  updateManyTranslators: (
    args: {
      data: TranslatorUpdateManyMutationInput;
      where?: TranslatorWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTranslator: (
    args: {
      where: TranslatorWhereUniqueInput;
      create: TranslatorCreateInput;
      update: TranslatorUpdateInput;
    }
  ) => TranslatorPromise;
  deleteTranslator: (where: TranslatorWhereUniqueInput) => TranslatorPromise;
  deleteManyTranslators: (where?: TranslatorWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserAdmin: (data: UserAdminCreateInput) => UserAdminPromise;
  updateUserAdmin: (
    args: { data: UserAdminUpdateInput; where: UserAdminWhereUniqueInput }
  ) => UserAdminPromise;
  updateManyUserAdmins: (
    args: {
      data: UserAdminUpdateManyMutationInput;
      where?: UserAdminWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserAdmin: (
    args: {
      where: UserAdminWhereUniqueInput;
      create: UserAdminCreateInput;
      update: UserAdminUpdateInput;
    }
  ) => UserAdminPromise;
  deleteUserAdmin: (where: UserAdminWhereUniqueInput) => UserAdminPromise;
  deleteManyUserAdmins: (where?: UserAdminWhereInput) => BatchPayloadPromise;
  createUserAdminPermission: (
    data: UserAdminPermissionCreateInput
  ) => UserAdminPermissionPromise;
  updateUserAdminPermission: (
    args: {
      data: UserAdminPermissionUpdateInput;
      where: UserAdminPermissionWhereUniqueInput;
    }
  ) => UserAdminPermissionPromise;
  updateManyUserAdminPermissions: (
    args: {
      data: UserAdminPermissionUpdateManyMutationInput;
      where?: UserAdminPermissionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserAdminPermission: (
    args: {
      where: UserAdminPermissionWhereUniqueInput;
      create: UserAdminPermissionCreateInput;
      update: UserAdminPermissionUpdateInput;
    }
  ) => UserAdminPermissionPromise;
  deleteUserAdminPermission: (
    where: UserAdminPermissionWhereUniqueInput
  ) => UserAdminPermissionPromise;
  deleteManyUserAdminPermissions: (
    where?: UserAdminPermissionWhereInput
  ) => BatchPayloadPromise;
  createUserAdminRole: (data: UserAdminRoleCreateInput) => UserAdminRolePromise;
  updateUserAdminRole: (
    args: {
      data: UserAdminRoleUpdateInput;
      where: UserAdminRoleWhereUniqueInput;
    }
  ) => UserAdminRolePromise;
  updateManyUserAdminRoles: (
    args: {
      data: UserAdminRoleUpdateManyMutationInput;
      where?: UserAdminRoleWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserAdminRole: (
    args: {
      where: UserAdminRoleWhereUniqueInput;
      create: UserAdminRoleCreateInput;
      update: UserAdminRoleUpdateInput;
    }
  ) => UserAdminRolePromise;
  deleteUserAdminRole: (
    where: UserAdminRoleWhereUniqueInput
  ) => UserAdminRolePromise;
  deleteManyUserAdminRoles: (
    where?: UserAdminRoleWhereInput
  ) => BatchPayloadPromise;
  createVendor: (data: VendorCreateInput) => VendorPromise;
  updateVendor: (
    args: { data: VendorUpdateInput; where: VendorWhereUniqueInput }
  ) => VendorPromise;
  updateManyVendors: (
    args: { data: VendorUpdateManyMutationInput; where?: VendorWhereInput }
  ) => BatchPayloadPromise;
  upsertVendor: (
    args: {
      where: VendorWhereUniqueInput;
      create: VendorCreateInput;
      update: VendorUpdateInput;
    }
  ) => VendorPromise;
  deleteVendor: (where: VendorWhereUniqueInput) => VendorPromise;
  deleteManyVendors: (where?: VendorWhereInput) => BatchPayloadPromise;
  createVendorBillingInformation: (
    data: VendorBillingInformationCreateInput
  ) => VendorBillingInformationPromise;
  updateVendorBillingInformation: (
    args: {
      data: VendorBillingInformationUpdateInput;
      where: VendorBillingInformationWhereUniqueInput;
    }
  ) => VendorBillingInformationPromise;
  updateManyVendorBillingInformations: (
    args: {
      data: VendorBillingInformationUpdateManyMutationInput;
      where?: VendorBillingInformationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVendorBillingInformation: (
    args: {
      where: VendorBillingInformationWhereUniqueInput;
      create: VendorBillingInformationCreateInput;
      update: VendorBillingInformationUpdateInput;
    }
  ) => VendorBillingInformationPromise;
  deleteVendorBillingInformation: (
    where: VendorBillingInformationWhereUniqueInput
  ) => VendorBillingInformationPromise;
  deleteManyVendorBillingInformations: (
    where?: VendorBillingInformationWhereInput
  ) => BatchPayloadPromise;
  createVendorRevenue: (data: VendorRevenueCreateInput) => VendorRevenuePromise;
  updateVendorRevenue: (
    args: {
      data: VendorRevenueUpdateInput;
      where: VendorRevenueWhereUniqueInput;
    }
  ) => VendorRevenuePromise;
  updateManyVendorRevenues: (
    args: {
      data: VendorRevenueUpdateManyMutationInput;
      where?: VendorRevenueWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVendorRevenue: (
    args: {
      where: VendorRevenueWhereUniqueInput;
      create: VendorRevenueCreateInput;
      update: VendorRevenueUpdateInput;
    }
  ) => VendorRevenuePromise;
  deleteVendorRevenue: (
    where: VendorRevenueWhereUniqueInput
  ) => VendorRevenuePromise;
  deleteManyVendorRevenues: (
    where?: VendorRevenueWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  adsBanner: (
    where?: AdsBannerSubscriptionWhereInput
  ) => AdsBannerSubscriptionPayloadSubscription;
  author: (
    where?: AuthorSubscriptionWhereInput
  ) => AuthorSubscriptionPayloadSubscription;
  behavior: (
    where?: BehaviorSubscriptionWhereInput
  ) => BehaviorSubscriptionPayloadSubscription;
  book: (
    where?: BookSubscriptionWhereInput
  ) => BookSubscriptionPayloadSubscription;
  bookEpisode: (
    where?: BookEpisodeSubscriptionWhereInput
  ) => BookEpisodeSubscriptionPayloadSubscription;
  bookEpisodeContent: (
    where?: BookEpisodeContentSubscriptionWhereInput
  ) => BookEpisodeContentSubscriptionPayloadSubscription;
  bookEpisodeRecentRead: (
    where?: BookEpisodeRecentReadSubscriptionWhereInput
  ) => BookEpisodeRecentReadSubscriptionPayloadSubscription;
  bookEpisodeReviewPost: (
    where?: BookEpisodeReviewPostSubscriptionWhereInput
  ) => BookEpisodeReviewPostSubscriptionPayloadSubscription;
  bookRecommended: (
    where?: BookRecommendedSubscriptionWhereInput
  ) => BookRecommendedSubscriptionPayloadSubscription;
  bookVolume: (
    where?: BookVolumeSubscriptionWhereInput
  ) => BookVolumeSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  copyrightHolder: (
    where?: CopyrightHolderSubscriptionWhereInput
  ) => CopyrightHolderSubscriptionPayloadSubscription;
  dashbardDataCache: (
    where?: DashbardDataCacheSubscriptionWhereInput
  ) => DashbardDataCacheSubscriptionPayloadSubscription;
  document: (
    where?: DocumentSubscriptionWhereInput
  ) => DocumentSubscriptionPayloadSubscription;
  exchangeTier: (
    where?: ExchangeTierSubscriptionWhereInput
  ) => ExchangeTierSubscriptionPayloadSubscription;
  exchangeTransaction: (
    where?: ExchangeTransactionSubscriptionWhereInput
  ) => ExchangeTransactionSubscriptionPayloadSubscription;
  exchangeTransactionStatusHistory: (
    where?: ExchangeTransactionStatusHistorySubscriptionWhereInput
  ) => ExchangeTransactionStatusHistorySubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  history: (
    where?: HistorySubscriptionWhereInput
  ) => HistorySubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  itemAsset: (
    where?: ItemAssetSubscriptionWhereInput
  ) => ItemAssetSubscriptionPayloadSubscription;
  migration: (
    where?: MigrationSubscriptionWhereInput
  ) => MigrationSubscriptionPayloadSubscription;
  pageView: (
    where?: PageViewSubscriptionWhereInput
  ) => PageViewSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  price: (
    where?: PriceSubscriptionWhereInput
  ) => PriceSubscriptionPayloadSubscription;
  promotion: (
    where?: PromotionSubscriptionWhereInput
  ) => PromotionSubscriptionPayloadSubscription;
  publishTimeline: (
    where?: PublishTimelineSubscriptionWhereInput
  ) => PublishTimelineSubscriptionPayloadSubscription;
  remoteConfig: (
    where?: RemoteConfigSubscriptionWhereInput
  ) => RemoteConfigSubscriptionPayloadSubscription;
  revenueSharing: (
    where?: RevenueSharingSubscriptionWhereInput
  ) => RevenueSharingSubscriptionPayloadSubscription;
  shelf: (
    where?: ShelfSubscriptionWhereInput
  ) => ShelfSubscriptionPayloadSubscription;
  systemConfig: (
    where?: SystemConfigSubscriptionWhereInput
  ) => SystemConfigSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  translator: (
    where?: TranslatorSubscriptionWhereInput
  ) => TranslatorSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userAdmin: (
    where?: UserAdminSubscriptionWhereInput
  ) => UserAdminSubscriptionPayloadSubscription;
  userAdminPermission: (
    where?: UserAdminPermissionSubscriptionWhereInput
  ) => UserAdminPermissionSubscriptionPayloadSubscription;
  userAdminRole: (
    where?: UserAdminRoleSubscriptionWhereInput
  ) => UserAdminRoleSubscriptionPayloadSubscription;
  vendor: (
    where?: VendorSubscriptionWhereInput
  ) => VendorSubscriptionPayloadSubscription;
  vendorBillingInformation: (
    where?: VendorBillingInformationSubscriptionWhereInput
  ) => VendorBillingInformationSubscriptionPayloadSubscription;
  vendorRevenue: (
    where?: VendorRevenueSubscriptionWhereInput
  ) => VendorRevenueSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AdsBannerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "order_ASC"
  | "order_DESC"
  | "altTag_ASC"
  | "altTag_DESC"
  | "backgroundColor_ASC"
  | "backgroundColor_DESC"
  | "url_ASC"
  | "url_DESC"
  | "page_ASC"
  | "page_DESC"
  | "position_ASC"
  | "position_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VendorType = "SelfPublishing" | "Publisher";

export type DocumentType =
  | "Other"
  | "CitizenID"
  | "PassportID"
  | "CertificateVATRegistration"
  | "CertificateCompanyRegistration";

export type VendorBillingType = "Company" | "Individual";

export type AuthorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TranslatorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CopyrightHolderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DocumentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Gender = "Male" | "Female" | "Unknown";

export type ExchangeType = "CreditCard" | "WebPay" | "LinePay" | "TrueWallet";

export type CurrencyType = "Reeeed";

export type PromotionUnit = "Percent" | "Baht" | "Reeeed";

export type PromotionType = "TopUp" | "Discount";

export type ExchangeTransactionType = "Init" | "Pending" | "Success" | "Failed";

export type TransactionType = "Income" | "Outcome";

export type PostType = "BookEpisodeReview";

export type ReviewPostStatus = "Hide" | "Publish";

export type RevenueSharingStatus = "Stop" | "OnGoing";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "currencyType_ASC"
  | "currencyType_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PromotionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "unit_ASC"
  | "unit_DESC"
  | "type_ASC"
  | "type_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExchangeTransactionStatusHistoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "message_ASC"
  | "message_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "expireAt_ASC"
  | "expireAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VendorRevenueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookVolumeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "title_ASC"
  | "title_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookEpisodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "publishedAt_ASC"
  | "publishedAt_DESC"
  | "isUnlisted_ASC"
  | "isUnlisted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "metaTitle_ASC"
  | "metaTitle_DESC"
  | "metaDescription_ASC"
  | "metaDescription_DESC"
  | "metaKeyword_ASC"
  | "metaKeyword_DESC";

export type PriceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "currencyType_ASC"
  | "currencyType_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "archiveAt_ASC"
  | "archiveAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookEpisodeContentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "draft_ASC"
  | "draft_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookEpisodeReviewPostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rating_ASC"
  | "rating_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExchangeTransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "orderID_ASC"
  | "orderID_DESC"
  | "currentStatus_ASC"
  | "currentStatus_DESC"
  | "payload_ASC"
  | "payload_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "refCode_ASC"
  | "refCode_DESC";

export type BehaviorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ip_ASC"
  | "ip_DESC"
  | "action_ASC"
  | "action_DESC"
  | "payload_ASC"
  | "payload_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "introduction_ASC"
  | "introduction_DESC"
  | "synopsis_ASC"
  | "synopsis_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "publishedAt_ASC"
  | "publishedAt_DESC"
  | "isUnlisted_ASC"
  | "isUnlisted_DESC"
  | "metaTitle_ASC"
  | "metaTitle_DESC"
  | "metaDescription_ASC"
  | "metaDescription_DESC"
  | "metaKeyword_ASC"
  | "metaKeyword_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookEpisodeRecentReadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "offsetKey_ASC"
  | "offsetKey_DESC"
  | "offsetRatio_ASC"
  | "offsetRatio_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookRecommendedOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DashbardDataCacheOrderByInput =
  | "queryName_ASC"
  | "queryName_DESC"
  | "arguments_ASC"
  | "arguments_DESC"
  | "result_ASC"
  | "result_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "id_ASC"
  | "id_DESC";

export type ExchangeTierOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "name_ASC"
  | "name_DESC"
  | "currencyType_ASC"
  | "currencyType_DESC"
  | "income_ASC"
  | "income_DESC"
  | "outcome_ASC"
  | "outcome_DESC"
  | "isDefault_ASC"
  | "isDefault_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "path_ASC"
  | "path_DESC"
  | "fileName_ASC"
  | "fileName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HistoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "payload_ASC"
  | "payload_DESC"
  | "mutationName_ASC"
  | "mutationName_DESC"
  | "updateBy_ASC"
  | "updateBy_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "small_ASC"
  | "small_DESC"
  | "medium_ASC"
  | "medium_DESC"
  | "large_ASC"
  | "large_DESC"
  | "fileName_ASC"
  | "fileName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ItemAssetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "assetType_ASC"
  | "assetType_DESC"
  | "assetID_ASC"
  | "assetID_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MigrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "num_ASC"
  | "num_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PageViewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "count_ASC"
  | "count_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type PostOrderByInput =
  | "type_ASC"
  | "type_DESC"
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PublishTimelineOrderByInput =
  | "startAt_ASC"
  | "startAt_DESC"
  | "endAt_ASC"
  | "endAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RemoteConfigOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "landing_ASC"
  | "landing_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RevenueSharingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "commission_ASC"
  | "commission_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShelfType = "BookPurchased";

export type ShelfOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SystemConfigOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userID_ASC"
  | "userID_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "fullName_ASC"
  | "fullName_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "defaultProfilePicture_ASC"
  | "defaultProfilePicture_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserAdminRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserAdminPermissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "resource_ASC"
  | "resource_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserAdminOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "hashedPassword_ASC"
  | "hashedPassword_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VendorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "email_ASC"
  | "email_DESC";

export type VendorBillingInformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "billingType_ASC"
  | "billingType_DESC"
  | "companyName_ASC"
  | "companyName_DESC"
  | "branchId_ASC"
  | "branchId_DESC"
  | "taxID_ASC"
  | "taxID_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "bank_ASC"
  | "bank_DESC"
  | "bookBankNumber_ASC"
  | "bookBankNumber_DESC"
  | "address_ASC"
  | "address_DESC"
  | "province_ASC"
  | "province_DESC"
  | "zipCode_ASC"
  | "zipCode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AdsBannerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AdsBannerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  image?: ImageWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  order?: Float;
  order_not?: Float;
  order_in?: Float[] | Float;
  order_not_in?: Float[] | Float;
  order_lt?: Float;
  order_lte?: Float;
  order_gt?: Float;
  order_gte?: Float;
  altTag?: String;
  altTag_not?: String;
  altTag_in?: String[] | String;
  altTag_not_in?: String[] | String;
  altTag_lt?: String;
  altTag_lte?: String;
  altTag_gt?: String;
  altTag_gte?: String;
  altTag_contains?: String;
  altTag_not_contains?: String;
  altTag_starts_with?: String;
  altTag_not_starts_with?: String;
  altTag_ends_with?: String;
  altTag_not_ends_with?: String;
  backgroundColor?: String;
  backgroundColor_not?: String;
  backgroundColor_in?: String[] | String;
  backgroundColor_not_in?: String[] | String;
  backgroundColor_lt?: String;
  backgroundColor_lte?: String;
  backgroundColor_gt?: String;
  backgroundColor_gte?: String;
  backgroundColor_contains?: String;
  backgroundColor_not_contains?: String;
  backgroundColor_starts_with?: String;
  backgroundColor_not_starts_with?: String;
  backgroundColor_ends_with?: String;
  backgroundColor_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  page?: String;
  page_not?: String;
  page_in?: String[] | String;
  page_not_in?: String[] | String;
  page_lt?: String;
  page_lte?: String;
  page_gt?: String;
  page_gte?: String;
  page_contains?: String;
  page_not_contains?: String;
  page_starts_with?: String;
  page_not_starts_with?: String;
  page_ends_with?: String;
  page_not_ends_with?: String;
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  publishTimeline?: PublishTimelineWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AdsBannerWhereInput[] | AdsBannerWhereInput;
  OR?: AdsBannerWhereInput[] | AdsBannerWhereInput;
  NOT?: AdsBannerWhereInput[] | AdsBannerWhereInput;
}

export interface ImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  small?: String;
  small_not?: String;
  small_in?: String[] | String;
  small_not_in?: String[] | String;
  small_lt?: String;
  small_lte?: String;
  small_gt?: String;
  small_gte?: String;
  small_contains?: String;
  small_not_contains?: String;
  small_starts_with?: String;
  small_not_starts_with?: String;
  small_ends_with?: String;
  small_not_ends_with?: String;
  medium?: String;
  medium_not?: String;
  medium_in?: String[] | String;
  medium_not_in?: String[] | String;
  medium_lt?: String;
  medium_lte?: String;
  medium_gt?: String;
  medium_gte?: String;
  medium_contains?: String;
  medium_not_contains?: String;
  medium_starts_with?: String;
  medium_not_starts_with?: String;
  medium_ends_with?: String;
  medium_not_ends_with?: String;
  large?: String;
  large_not?: String;
  large_in?: String[] | String;
  large_not_in?: String[] | String;
  large_lt?: String;
  large_lte?: String;
  large_gt?: String;
  large_gte?: String;
  large_contains?: String;
  large_not_contains?: String;
  large_starts_with?: String;
  large_not_starts_with?: String;
  large_ends_with?: String;
  large_not_ends_with?: String;
  fileName?: String;
  fileName_not?: String;
  fileName_in?: String[] | String;
  fileName_not_in?: String[] | String;
  fileName_lt?: String;
  fileName_lte?: String;
  fileName_gt?: String;
  fileName_gte?: String;
  fileName_contains?: String;
  fileName_not_contains?: String;
  fileName_starts_with?: String;
  fileName_not_starts_with?: String;
  fileName_ends_with?: String;
  fileName_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ImageWhereInput[] | ImageWhereInput;
  OR?: ImageWhereInput[] | ImageWhereInput;
  NOT?: ImageWhereInput[] | ImageWhereInput;
}

export interface PublishTimelineWhereInput {
  startAt?: DateTimeInput;
  startAt_not?: DateTimeInput;
  startAt_in?: DateTimeInput[] | DateTimeInput;
  startAt_not_in?: DateTimeInput[] | DateTimeInput;
  startAt_lt?: DateTimeInput;
  startAt_lte?: DateTimeInput;
  startAt_gt?: DateTimeInput;
  startAt_gte?: DateTimeInput;
  endAt?: DateTimeInput;
  endAt_not?: DateTimeInput;
  endAt_in?: DateTimeInput[] | DateTimeInput;
  endAt_not_in?: DateTimeInput[] | DateTimeInput;
  endAt_lt?: DateTimeInput;
  endAt_lte?: DateTimeInput;
  endAt_gt?: DateTimeInput;
  endAt_gte?: DateTimeInput;
  AND?: PublishTimelineWhereInput[] | PublishTimelineWhereInput;
  OR?: PublishTimelineWhereInput[] | PublishTimelineWhereInput;
  NOT?: PublishTimelineWhereInput[] | PublishTimelineWhereInput;
}

export type AuthorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AuthorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  vendor?: VendorWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AuthorWhereInput[] | AuthorWhereInput;
  OR?: AuthorWhereInput[] | AuthorWhereInput;
  NOT?: AuthorWhereInput[] | AuthorWhereInput;
}

export interface VendorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: VendorType;
  type_not?: VendorType;
  type_in?: VendorType[] | VendorType;
  type_not_in?: VendorType[] | VendorType;
  authors_every?: AuthorWhereInput;
  authors_some?: AuthorWhereInput;
  authors_none?: AuthorWhereInput;
  translators_every?: TranslatorWhereInput;
  translators_some?: TranslatorWhereInput;
  translators_none?: TranslatorWhereInput;
  copyrightHolders_every?: CopyrightHolderWhereInput;
  copyrightHolders_some?: CopyrightHolderWhereInput;
  copyrightHolders_none?: CopyrightHolderWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  documents_every?: DocumentWhereInput;
  documents_some?: DocumentWhereInput;
  documents_none?: DocumentWhereInput;
  billingInformation?: VendorBillingInformationWhereInput;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  AND?: VendorWhereInput[] | VendorWhereInput;
  OR?: VendorWhereInput[] | VendorWhereInput;
  NOT?: VendorWhereInput[] | VendorWhereInput;
}

export interface TranslatorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  vendor?: VendorWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TranslatorWhereInput[] | TranslatorWhereInput;
  OR?: TranslatorWhereInput[] | TranslatorWhereInput;
  NOT?: TranslatorWhereInput[] | TranslatorWhereInput;
}

export interface CopyrightHolderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  vendor?: VendorWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CopyrightHolderWhereInput[] | CopyrightHolderWhereInput;
  OR?: CopyrightHolderWhereInput[] | CopyrightHolderWhereInput;
  NOT?: CopyrightHolderWhereInput[] | CopyrightHolderWhereInput;
}

export interface DocumentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  file?: FileWhereInput;
  image?: ImageWhereInput;
  type?: DocumentType;
  type_not?: DocumentType;
  type_in?: DocumentType[] | DocumentType;
  type_not_in?: DocumentType[] | DocumentType;
  AND?: DocumentWhereInput[] | DocumentWhereInput;
  OR?: DocumentWhereInput[] | DocumentWhereInput;
  NOT?: DocumentWhereInput[] | DocumentWhereInput;
}

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  fileName?: String;
  fileName_not?: String;
  fileName_in?: String[] | String;
  fileName_not_in?: String[] | String;
  fileName_lt?: String;
  fileName_lte?: String;
  fileName_gt?: String;
  fileName_gte?: String;
  fileName_contains?: String;
  fileName_not_contains?: String;
  fileName_starts_with?: String;
  fileName_not_starts_with?: String;
  fileName_ends_with?: String;
  fileName_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export interface VendorBillingInformationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  billingType?: VendorBillingType;
  billingType_not?: VendorBillingType;
  billingType_in?: VendorBillingType[] | VendorBillingType;
  billingType_not_in?: VendorBillingType[] | VendorBillingType;
  companyName?: String;
  companyName_not?: String;
  companyName_in?: String[] | String;
  companyName_not_in?: String[] | String;
  companyName_lt?: String;
  companyName_lte?: String;
  companyName_gt?: String;
  companyName_gte?: String;
  companyName_contains?: String;
  companyName_not_contains?: String;
  companyName_starts_with?: String;
  companyName_not_starts_with?: String;
  companyName_ends_with?: String;
  companyName_not_ends_with?: String;
  branchId?: String;
  branchId_not?: String;
  branchId_in?: String[] | String;
  branchId_not_in?: String[] | String;
  branchId_lt?: String;
  branchId_lte?: String;
  branchId_gt?: String;
  branchId_gte?: String;
  branchId_contains?: String;
  branchId_not_contains?: String;
  branchId_starts_with?: String;
  branchId_not_starts_with?: String;
  branchId_ends_with?: String;
  branchId_not_ends_with?: String;
  taxID?: String;
  taxID_not?: String;
  taxID_in?: String[] | String;
  taxID_not_in?: String[] | String;
  taxID_lt?: String;
  taxID_lte?: String;
  taxID_gt?: String;
  taxID_gte?: String;
  taxID_contains?: String;
  taxID_not_contains?: String;
  taxID_starts_with?: String;
  taxID_not_starts_with?: String;
  taxID_ends_with?: String;
  taxID_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  bank?: String;
  bank_not?: String;
  bank_in?: String[] | String;
  bank_not_in?: String[] | String;
  bank_lt?: String;
  bank_lte?: String;
  bank_gt?: String;
  bank_gte?: String;
  bank_contains?: String;
  bank_not_contains?: String;
  bank_starts_with?: String;
  bank_not_starts_with?: String;
  bank_ends_with?: String;
  bank_not_ends_with?: String;
  bookBankNumber?: String;
  bookBankNumber_not?: String;
  bookBankNumber_in?: String[] | String;
  bookBankNumber_not_in?: String[] | String;
  bookBankNumber_lt?: String;
  bookBankNumber_lte?: String;
  bookBankNumber_gt?: String;
  bookBankNumber_gte?: String;
  bookBankNumber_contains?: String;
  bookBankNumber_not_contains?: String;
  bookBankNumber_starts_with?: String;
  bookBankNumber_not_starts_with?: String;
  bookBankNumber_ends_with?: String;
  bookBankNumber_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  province?: String;
  province_not?: String;
  province_in?: String[] | String;
  province_not_in?: String[] | String;
  province_lt?: String;
  province_lte?: String;
  province_gt?: String;
  province_gte?: String;
  province_contains?: String;
  province_not_contains?: String;
  province_starts_with?: String;
  province_not_starts_with?: String;
  province_ends_with?: String;
  province_not_ends_with?: String;
  zipCode?: String;
  zipCode_not?: String;
  zipCode_in?: String[] | String;
  zipCode_not_in?: String[] | String;
  zipCode_lt?: String;
  zipCode_lte?: String;
  zipCode_gt?: String;
  zipCode_gte?: String;
  zipCode_contains?: String;
  zipCode_not_contains?: String;
  zipCode_starts_with?: String;
  zipCode_not_starts_with?: String;
  zipCode_ends_with?: String;
  zipCode_not_ends_with?: String;
  AND?:
    | VendorBillingInformationWhereInput[]
    | VendorBillingInformationWhereInput;
  OR?:
    | VendorBillingInformationWhereInput[]
    | VendorBillingInformationWhereInput;
  NOT?:
    | VendorBillingInformationWhereInput[]
    | VendorBillingInformationWhereInput;
}

export type BehaviorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TransactionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  currencyType?: CurrencyType;
  currencyType_not?: CurrencyType;
  currencyType_in?: CurrencyType[] | CurrencyType;
  currencyType_not_in?: CurrencyType[] | CurrencyType;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  exchangeTransaction?: ExchangeTransactionWhereInput;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  vendorRevenue_every?: VendorRevenueWhereInput;
  vendorRevenue_some?: VendorRevenueWhereInput;
  vendorRevenue_none?: VendorRevenueWhereInput;
  AND?: TransactionWhereInput[] | TransactionWhereInput;
  OR?: TransactionWhereInput[] | TransactionWhereInput;
  NOT?: TransactionWhereInput[] | TransactionWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userID?: ID_Input;
  userID_not?: ID_Input;
  userID_in?: ID_Input[] | ID_Input;
  userID_not_in?: ID_Input[] | ID_Input;
  userID_lt?: ID_Input;
  userID_lte?: ID_Input;
  userID_gt?: ID_Input;
  userID_gte?: ID_Input;
  userID_contains?: ID_Input;
  userID_not_contains?: ID_Input;
  userID_starts_with?: ID_Input;
  userID_not_starts_with?: ID_Input;
  userID_ends_with?: ID_Input;
  userID_not_ends_with?: ID_Input;
  displayName?: String;
  displayName_not?: String;
  displayName_in?: String[] | String;
  displayName_not_in?: String[] | String;
  displayName_lt?: String;
  displayName_lte?: String;
  displayName_gt?: String;
  displayName_gte?: String;
  displayName_contains?: String;
  displayName_not_contains?: String;
  displayName_starts_with?: String;
  displayName_not_starts_with?: String;
  displayName_ends_with?: String;
  displayName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  fullName?: String;
  fullName_not?: String;
  fullName_in?: String[] | String;
  fullName_not_in?: String[] | String;
  fullName_lt?: String;
  fullName_lte?: String;
  fullName_gt?: String;
  fullName_gte?: String;
  fullName_contains?: String;
  fullName_not_contains?: String;
  fullName_starts_with?: String;
  fullName_not_starts_with?: String;
  fullName_ends_with?: String;
  fullName_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  birthday?: String;
  birthday_not?: String;
  birthday_in?: String[] | String;
  birthday_not_in?: String[] | String;
  birthday_lt?: String;
  birthday_lte?: String;
  birthday_gt?: String;
  birthday_gte?: String;
  birthday_contains?: String;
  birthday_not_contains?: String;
  birthday_starts_with?: String;
  birthday_not_starts_with?: String;
  birthday_ends_with?: String;
  birthday_not_ends_with?: String;
  gender?: Gender;
  gender_not?: Gender;
  gender_in?: Gender[] | Gender;
  gender_not_in?: Gender[] | Gender;
  defaultProfilePicture?: String;
  defaultProfilePicture_not?: String;
  defaultProfilePicture_in?: String[] | String;
  defaultProfilePicture_not_in?: String[] | String;
  defaultProfilePicture_lt?: String;
  defaultProfilePicture_lte?: String;
  defaultProfilePicture_gt?: String;
  defaultProfilePicture_gte?: String;
  defaultProfilePicture_contains?: String;
  defaultProfilePicture_not_contains?: String;
  defaultProfilePicture_starts_with?: String;
  defaultProfilePicture_not_starts_with?: String;
  defaultProfilePicture_ends_with?: String;
  defaultProfilePicture_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  transactions_every?: TransactionWhereInput;
  transactions_some?: TransactionWhereInput;
  transactions_none?: TransactionWhereInput;
  exchangeTransactions_every?: ExchangeTransactionWhereInput;
  exchangeTransactions_some?: ExchangeTransactionWhereInput;
  exchangeTransactions_none?: ExchangeTransactionWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ExchangeTransactionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  orderID?: String;
  orderID_not?: String;
  orderID_in?: String[] | String;
  orderID_not_in?: String[] | String;
  orderID_lt?: String;
  orderID_lte?: String;
  orderID_gt?: String;
  orderID_gte?: String;
  orderID_contains?: String;
  orderID_not_contains?: String;
  orderID_starts_with?: String;
  orderID_not_starts_with?: String;
  orderID_ends_with?: String;
  orderID_not_ends_with?: String;
  user?: UserWhereInput;
  tier?: ExchangeTierWhereInput;
  status_every?: ExchangeTransactionStatusHistoryWhereInput;
  status_some?: ExchangeTransactionStatusHistoryWhereInput;
  status_none?: ExchangeTransactionStatusHistoryWhereInput;
  currentStatus?: ExchangeTransactionType;
  currentStatus_not?: ExchangeTransactionType;
  currentStatus_in?: ExchangeTransactionType[] | ExchangeTransactionType;
  currentStatus_not_in?: ExchangeTransactionType[] | ExchangeTransactionType;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  refCode?: String;
  refCode_not?: String;
  refCode_in?: String[] | String;
  refCode_not_in?: String[] | String;
  refCode_lt?: String;
  refCode_lte?: String;
  refCode_gt?: String;
  refCode_gte?: String;
  refCode_contains?: String;
  refCode_not_contains?: String;
  refCode_starts_with?: String;
  refCode_not_starts_with?: String;
  refCode_ends_with?: String;
  refCode_not_ends_with?: String;
  AND?: ExchangeTransactionWhereInput[] | ExchangeTransactionWhereInput;
  OR?: ExchangeTransactionWhereInput[] | ExchangeTransactionWhereInput;
  NOT?: ExchangeTransactionWhereInput[] | ExchangeTransactionWhereInput;
}

export interface ExchangeTierWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: ExchangeType;
  type_not?: ExchangeType;
  type_in?: ExchangeType[] | ExchangeType;
  type_not_in?: ExchangeType[] | ExchangeType;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  currencyType?: CurrencyType;
  currencyType_not?: CurrencyType;
  currencyType_in?: CurrencyType[] | CurrencyType;
  currencyType_not_in?: CurrencyType[] | CurrencyType;
  income?: Float;
  income_not?: Float;
  income_in?: Float[] | Float;
  income_not_in?: Float[] | Float;
  income_lt?: Float;
  income_lte?: Float;
  income_gt?: Float;
  income_gte?: Float;
  outcome?: Float;
  outcome_not?: Float;
  outcome_in?: Float[] | Float;
  outcome_not_in?: Float[] | Float;
  outcome_lt?: Float;
  outcome_lte?: Float;
  outcome_gt?: Float;
  outcome_gte?: Float;
  promotions_every?: PromotionWhereInput;
  promotions_some?: PromotionWhereInput;
  promotions_none?: PromotionWhereInput;
  isDefault?: Boolean;
  isDefault_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  publishTimeline?: PublishTimelineWhereInput;
  AND?: ExchangeTierWhereInput[] | ExchangeTierWhereInput;
  OR?: ExchangeTierWhereInput[] | ExchangeTierWhereInput;
  NOT?: ExchangeTierWhereInput[] | ExchangeTierWhereInput;
}

export interface PromotionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  unit?: PromotionUnit;
  unit_not?: PromotionUnit;
  unit_in?: PromotionUnit[] | PromotionUnit;
  unit_not_in?: PromotionUnit[] | PromotionUnit;
  type?: PromotionType;
  type_not?: PromotionType;
  type_in?: PromotionType[] | PromotionType;
  type_not_in?: PromotionType[] | PromotionType;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PromotionWhereInput[] | PromotionWhereInput;
  OR?: PromotionWhereInput[] | PromotionWhereInput;
  NOT?: PromotionWhereInput[] | PromotionWhereInput;
}

export interface ExchangeTransactionStatusHistoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: ExchangeTransactionType;
  status_not?: ExchangeTransactionType;
  status_in?: ExchangeTransactionType[] | ExchangeTransactionType;
  status_not_in?: ExchangeTransactionType[] | ExchangeTransactionType;
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  AND?:
    | ExchangeTransactionStatusHistoryWhereInput[]
    | ExchangeTransactionStatusHistoryWhereInput;
  OR?:
    | ExchangeTransactionStatusHistoryWhereInput[]
    | ExchangeTransactionStatusHistoryWhereInput;
  NOT?:
    | ExchangeTransactionStatusHistoryWhereInput[]
    | ExchangeTransactionStatusHistoryWhereInput;
}

export interface ItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  asset?: ItemAssetWhereInput;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  expireAt?: DateTimeInput;
  expireAt_not?: DateTimeInput;
  expireAt_in?: DateTimeInput[] | DateTimeInput;
  expireAt_not_in?: DateTimeInput[] | DateTimeInput;
  expireAt_lt?: DateTimeInput;
  expireAt_lte?: DateTimeInput;
  expireAt_gt?: DateTimeInput;
  expireAt_gte?: DateTimeInput;
  transaction?: TransactionWhereInput;
  AND?: ItemWhereInput[] | ItemWhereInput;
  OR?: ItemWhereInput[] | ItemWhereInput;
  NOT?: ItemWhereInput[] | ItemWhereInput;
}

export interface ItemAssetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  assetType?: String;
  assetType_not?: String;
  assetType_in?: String[] | String;
  assetType_not_in?: String[] | String;
  assetType_lt?: String;
  assetType_lte?: String;
  assetType_gt?: String;
  assetType_gte?: String;
  assetType_contains?: String;
  assetType_not_contains?: String;
  assetType_starts_with?: String;
  assetType_not_starts_with?: String;
  assetType_ends_with?: String;
  assetType_not_ends_with?: String;
  assetID?: ID_Input;
  assetID_not?: ID_Input;
  assetID_in?: ID_Input[] | ID_Input;
  assetID_not_in?: ID_Input[] | ID_Input;
  assetID_lt?: ID_Input;
  assetID_lte?: ID_Input;
  assetID_gt?: ID_Input;
  assetID_gte?: ID_Input;
  assetID_contains?: ID_Input;
  assetID_not_contains?: ID_Input;
  assetID_starts_with?: ID_Input;
  assetID_not_starts_with?: ID_Input;
  assetID_ends_with?: ID_Input;
  assetID_not_ends_with?: ID_Input;
  item?: ItemWhereInput;
  AND?: ItemAssetWhereInput[] | ItemAssetWhereInput;
  OR?: ItemAssetWhereInput[] | ItemAssetWhereInput;
  NOT?: ItemAssetWhereInput[] | ItemAssetWhereInput;
}

export interface VendorRevenueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  weight?: Int;
  weight_not?: Int;
  weight_in?: Int[] | Int;
  weight_not_in?: Int[] | Int;
  weight_lt?: Int;
  weight_lte?: Int;
  weight_gt?: Int;
  weight_gte?: Int;
  revenueSharing?: RevenueSharingWhereInput;
  transaction?: TransactionWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: VendorRevenueWhereInput[] | VendorRevenueWhereInput;
  OR?: VendorRevenueWhereInput[] | VendorRevenueWhereInput;
  NOT?: VendorRevenueWhereInput[] | VendorRevenueWhereInput;
}

export interface RevenueSharingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  vendor?: VendorWhereInput;
  book?: BookWhereInput;
  commission?: Float;
  commission_not?: Float;
  commission_in?: Float[] | Float;
  commission_not_in?: Float[] | Float;
  commission_lt?: Float;
  commission_lte?: Float;
  commission_gt?: Float;
  commission_gte?: Float;
  status?: RevenueSharingStatus;
  status_not?: RevenueSharingStatus;
  status_in?: RevenueSharingStatus[] | RevenueSharingStatus;
  status_not_in?: RevenueSharingStatus[] | RevenueSharingStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RevenueSharingWhereInput[] | RevenueSharingWhereInput;
  OR?: RevenueSharingWhereInput[] | RevenueSharingWhereInput;
  NOT?: RevenueSharingWhereInput[] | RevenueSharingWhereInput;
}

export interface BookWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  synopsis?: String;
  synopsis_not?: String;
  synopsis_in?: String[] | String;
  synopsis_not_in?: String[] | String;
  synopsis_lt?: String;
  synopsis_lte?: String;
  synopsis_gt?: String;
  synopsis_gte?: String;
  synopsis_contains?: String;
  synopsis_not_contains?: String;
  synopsis_starts_with?: String;
  synopsis_not_starts_with?: String;
  synopsis_ends_with?: String;
  synopsis_not_ends_with?: String;
  thumbnail?: ImageWhereInput;
  copyrightHolder?: CopyrightHolderWhereInput;
  authors_every?: AuthorWhereInput;
  authors_some?: AuthorWhereInput;
  authors_none?: AuthorWhereInput;
  mainCategory?: CategoryWhereInput;
  secondaryCategory?: CategoryWhereInput;
  translators_every?: TranslatorWhereInput;
  translators_some?: TranslatorWhereInput;
  translators_none?: TranslatorWhereInput;
  volumes_every?: BookVolumeWhereInput;
  volumes_some?: BookVolumeWhereInput;
  volumes_none?: BookVolumeWhereInput;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  publishedAt?: DateTimeInput;
  publishedAt_not?: DateTimeInput;
  publishedAt_in?: DateTimeInput[] | DateTimeInput;
  publishedAt_not_in?: DateTimeInput[] | DateTimeInput;
  publishedAt_lt?: DateTimeInput;
  publishedAt_lte?: DateTimeInput;
  publishedAt_gt?: DateTimeInput;
  publishedAt_gte?: DateTimeInput;
  publishTimeline?: PublishTimelineWhereInput;
  isUnlisted?: Boolean;
  isUnlisted_not?: Boolean;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  metaKeyword?: String;
  metaKeyword_not?: String;
  metaKeyword_in?: String[] | String;
  metaKeyword_not_in?: String[] | String;
  metaKeyword_lt?: String;
  metaKeyword_lte?: String;
  metaKeyword_gt?: String;
  metaKeyword_gte?: String;
  metaKeyword_contains?: String;
  metaKeyword_not_contains?: String;
  metaKeyword_starts_with?: String;
  metaKeyword_not_starts_with?: String;
  metaKeyword_ends_with?: String;
  metaKeyword_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BookWhereInput[] | BookWhereInput;
  OR?: BookWhereInput[] | BookWhereInput;
  NOT?: BookWhereInput[] | BookWhereInput;
}

export interface CategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CategoryWhereInput[] | CategoryWhereInput;
  OR?: CategoryWhereInput[] | CategoryWhereInput;
  NOT?: CategoryWhereInput[] | CategoryWhereInput;
}

export interface BookVolumeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  book?: BookWhereInput;
  episodes_every?: BookEpisodeWhereInput;
  episodes_some?: BookEpisodeWhereInput;
  episodes_none?: BookEpisodeWhereInput;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BookVolumeWhereInput[] | BookVolumeWhereInput;
  OR?: BookVolumeWhereInput[] | BookVolumeWhereInput;
  NOT?: BookVolumeWhereInput[] | BookVolumeWhereInput;
}

export interface BookEpisodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  authors_every?: AuthorWhereInput;
  authors_some?: AuthorWhereInput;
  authors_none?: AuthorWhereInput;
  translators_every?: TranslatorWhereInput;
  translators_some?: TranslatorWhereInput;
  translators_none?: TranslatorWhereInput;
  prices_every?: PriceWhereInput;
  prices_some?: PriceWhereInput;
  prices_none?: PriceWhereInput;
  priceHistory_every?: PriceWhereInput;
  priceHistory_some?: PriceWhereInput;
  priceHistory_none?: PriceWhereInput;
  publishContent?: BookEpisodeContentWhereInput;
  draftContent?: BookEpisodeContentWhereInput;
  revisionContents_every?: BookEpisodeContentWhereInput;
  revisionContents_some?: BookEpisodeContentWhereInput;
  revisionContents_none?: BookEpisodeContentWhereInput;
  volume?: BookVolumeWhereInput;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  publishedAt?: DateTimeInput;
  publishedAt_not?: DateTimeInput;
  publishedAt_in?: DateTimeInput[] | DateTimeInput;
  publishedAt_not_in?: DateTimeInput[] | DateTimeInput;
  publishedAt_lt?: DateTimeInput;
  publishedAt_lte?: DateTimeInput;
  publishedAt_gt?: DateTimeInput;
  publishedAt_gte?: DateTimeInput;
  vendor?: VendorWhereInput;
  publishTimeline?: PublishTimelineWhereInput;
  isUnlisted?: Boolean;
  isUnlisted_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  pageView?: PageViewWhereInput;
  reviews_every?: BookEpisodeReviewPostWhereInput;
  reviews_some?: BookEpisodeReviewPostWhereInput;
  reviews_none?: BookEpisodeReviewPostWhereInput;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  metaKeyword?: String;
  metaKeyword_not?: String;
  metaKeyword_in?: String[] | String;
  metaKeyword_not_in?: String[] | String;
  metaKeyword_lt?: String;
  metaKeyword_lte?: String;
  metaKeyword_gt?: String;
  metaKeyword_gte?: String;
  metaKeyword_contains?: String;
  metaKeyword_not_contains?: String;
  metaKeyword_starts_with?: String;
  metaKeyword_not_starts_with?: String;
  metaKeyword_ends_with?: String;
  metaKeyword_not_ends_with?: String;
  AND?: BookEpisodeWhereInput[] | BookEpisodeWhereInput;
  OR?: BookEpisodeWhereInput[] | BookEpisodeWhereInput;
  NOT?: BookEpisodeWhereInput[] | BookEpisodeWhereInput;
}

export interface PriceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  currencyType?: CurrencyType;
  currencyType_not?: CurrencyType;
  currencyType_in?: CurrencyType[] | CurrencyType;
  currencyType_not_in?: CurrencyType[] | CurrencyType;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  archiveAt?: DateTimeInput;
  archiveAt_not?: DateTimeInput;
  archiveAt_in?: DateTimeInput[] | DateTimeInput;
  archiveAt_not_in?: DateTimeInput[] | DateTimeInput;
  archiveAt_lt?: DateTimeInput;
  archiveAt_lte?: DateTimeInput;
  archiveAt_gt?: DateTimeInput;
  archiveAt_gte?: DateTimeInput;
  AND?: PriceWhereInput[] | PriceWhereInput;
  OR?: PriceWhereInput[] | PriceWhereInput;
  NOT?: PriceWhereInput[] | PriceWhereInput;
}

export interface BookEpisodeContentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: BookEpisodeContentWhereInput[] | BookEpisodeContentWhereInput;
  OR?: BookEpisodeContentWhereInput[] | BookEpisodeContentWhereInput;
  NOT?: BookEpisodeContentWhereInput[] | BookEpisodeContentWhereInput;
}

export interface PageViewWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  episode?: BookEpisodeWhereInput;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PageViewWhereInput[] | PageViewWhereInput;
  OR?: PageViewWhereInput[] | PageViewWhereInput;
  NOT?: PageViewWhereInput[] | PageViewWhereInput;
}

export interface BookEpisodeReviewPostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  episode?: BookEpisodeWhereInput;
  rating?: Int;
  rating_not?: Int;
  rating_in?: Int[] | Int;
  rating_not_in?: Int[] | Int;
  rating_lt?: Int;
  rating_lte?: Int;
  rating_gt?: Int;
  rating_gte?: Int;
  post?: PostWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BookEpisodeReviewPostWhereInput[] | BookEpisodeReviewPostWhereInput;
  OR?: BookEpisodeReviewPostWhereInput[] | BookEpisodeReviewPostWhereInput;
  NOT?: BookEpisodeReviewPostWhereInput[] | BookEpisodeReviewPostWhereInput;
}

export interface PostWhereInput {
  type?: PostType;
  type_not?: PostType;
  type_in?: PostType[] | PostType;
  type_not_in?: PostType[] | PostType;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  status?: ReviewPostStatus;
  status_not?: ReviewPostStatus;
  status_in?: ReviewPostStatus[] | ReviewPostStatus;
  status_not_in?: ReviewPostStatus[] | ReviewPostStatus;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface BehaviorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  ip?: String;
  ip_not?: String;
  ip_in?: String[] | String;
  ip_not_in?: String[] | String;
  ip_lt?: String;
  ip_lte?: String;
  ip_gt?: String;
  ip_gte?: String;
  ip_contains?: String;
  ip_not_contains?: String;
  ip_starts_with?: String;
  ip_not_starts_with?: String;
  ip_ends_with?: String;
  ip_not_ends_with?: String;
  action?: String;
  action_not?: String;
  action_in?: String[] | String;
  action_not_in?: String[] | String;
  action_lt?: String;
  action_lte?: String;
  action_gt?: String;
  action_gte?: String;
  action_contains?: String;
  action_not_contains?: String;
  action_starts_with?: String;
  action_not_starts_with?: String;
  action_ends_with?: String;
  action_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: BehaviorWhereInput[] | BehaviorWhereInput;
  OR?: BehaviorWhereInput[] | BehaviorWhereInput;
  NOT?: BehaviorWhereInput[] | BehaviorWhereInput;
}

export type BookWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BookEpisodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BookEpisodeContentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BookEpisodeRecentReadWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BookEpisodeRecentReadWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  episode?: BookEpisodeWhereInput;
  offsetKey?: String;
  offsetKey_not?: String;
  offsetKey_in?: String[] | String;
  offsetKey_not_in?: String[] | String;
  offsetKey_lt?: String;
  offsetKey_lte?: String;
  offsetKey_gt?: String;
  offsetKey_gte?: String;
  offsetKey_contains?: String;
  offsetKey_not_contains?: String;
  offsetKey_starts_with?: String;
  offsetKey_not_starts_with?: String;
  offsetKey_ends_with?: String;
  offsetKey_not_ends_with?: String;
  offsetRatio?: Float;
  offsetRatio_not?: Float;
  offsetRatio_in?: Float[] | Float;
  offsetRatio_not_in?: Float[] | Float;
  offsetRatio_lt?: Float;
  offsetRatio_lte?: Float;
  offsetRatio_gt?: Float;
  offsetRatio_gte?: Float;
  AND?: BookEpisodeRecentReadWhereInput[] | BookEpisodeRecentReadWhereInput;
  OR?: BookEpisodeRecentReadWhereInput[] | BookEpisodeRecentReadWhereInput;
  NOT?: BookEpisodeRecentReadWhereInput[] | BookEpisodeRecentReadWhereInput;
}

export type BookEpisodeReviewPostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BookRecommendedWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BookRecommendedWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  book?: BookWhereInput;
  weight?: Int;
  weight_not?: Int;
  weight_in?: Int[] | Int;
  weight_not_in?: Int[] | Int;
  weight_lt?: Int;
  weight_lte?: Int;
  weight_gt?: Int;
  weight_gte?: Int;
  publishTimeline?: PublishTimelineWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BookRecommendedWhereInput[] | BookRecommendedWhereInput;
  OR?: BookRecommendedWhereInput[] | BookRecommendedWhereInput;
  NOT?: BookRecommendedWhereInput[] | BookRecommendedWhereInput;
}

export type BookVolumeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export type CopyrightHolderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DashbardDataCacheWhereInput {
  queryName?: String;
  queryName_not?: String;
  queryName_in?: String[] | String;
  queryName_not_in?: String[] | String;
  queryName_lt?: String;
  queryName_lte?: String;
  queryName_gt?: String;
  queryName_gte?: String;
  queryName_contains?: String;
  queryName_not_contains?: String;
  queryName_starts_with?: String;
  queryName_not_starts_with?: String;
  queryName_ends_with?: String;
  queryName_not_ends_with?: String;
  arguments?: String;
  arguments_not?: String;
  arguments_in?: String[] | String;
  arguments_not_in?: String[] | String;
  arguments_lt?: String;
  arguments_lte?: String;
  arguments_gt?: String;
  arguments_gte?: String;
  arguments_contains?: String;
  arguments_not_contains?: String;
  arguments_starts_with?: String;
  arguments_not_starts_with?: String;
  arguments_ends_with?: String;
  arguments_not_ends_with?: String;
  result?: String;
  result_not?: String;
  result_in?: String[] | String;
  result_not_in?: String[] | String;
  result_lt?: String;
  result_lte?: String;
  result_gt?: String;
  result_gte?: String;
  result_contains?: String;
  result_not_contains?: String;
  result_starts_with?: String;
  result_not_starts_with?: String;
  result_ends_with?: String;
  result_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: DashbardDataCacheWhereInput[] | DashbardDataCacheWhereInput;
  OR?: DashbardDataCacheWhereInput[] | DashbardDataCacheWhereInput;
  NOT?: DashbardDataCacheWhereInput[] | DashbardDataCacheWhereInput;
}

export type DocumentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ExchangeTierWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ExchangeTransactionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ExchangeTransactionStatusHistoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type HistoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HistoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  mutationName?: String;
  mutationName_not?: String;
  mutationName_in?: String[] | String;
  mutationName_not_in?: String[] | String;
  mutationName_lt?: String;
  mutationName_lte?: String;
  mutationName_gt?: String;
  mutationName_gte?: String;
  mutationName_contains?: String;
  mutationName_not_contains?: String;
  mutationName_starts_with?: String;
  mutationName_not_starts_with?: String;
  mutationName_ends_with?: String;
  mutationName_not_ends_with?: String;
  updateBy?: String;
  updateBy_not?: String;
  updateBy_in?: String[] | String;
  updateBy_not_in?: String[] | String;
  updateBy_lt?: String;
  updateBy_lte?: String;
  updateBy_gt?: String;
  updateBy_gte?: String;
  updateBy_contains?: String;
  updateBy_not_contains?: String;
  updateBy_starts_with?: String;
  updateBy_not_starts_with?: String;
  updateBy_ends_with?: String;
  updateBy_not_ends_with?: String;
  AND?: HistoryWhereInput[] | HistoryWhereInput;
  OR?: HistoryWhereInput[] | HistoryWhereInput;
  NOT?: HistoryWhereInput[] | HistoryWhereInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ItemAssetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type MigrationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  num?: Int;
}>;

export interface MigrationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  num?: Int;
  num_not?: Int;
  num_in?: Int[] | Int;
  num_not_in?: Int[] | Int;
  num_lt?: Int;
  num_lte?: Int;
  num_gt?: Int;
  num_gte?: Int;
  AND?: MigrationWhereInput[] | MigrationWhereInput;
  OR?: MigrationWhereInput[] | MigrationWhereInput;
  NOT?: MigrationWhereInput[] | MigrationWhereInput;
}

export type PageViewWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PriceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PromotionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type RemoteConfigWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface RemoteConfigWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  landing?: Boolean;
  landing_not?: Boolean;
  AND?: RemoteConfigWhereInput[] | RemoteConfigWhereInput;
  OR?: RemoteConfigWhereInput[] | RemoteConfigWhereInput;
  NOT?: RemoteConfigWhereInput[] | RemoteConfigWhereInput;
}

export type RevenueSharingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ShelfWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ShelfWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: ShelfType;
  type_not?: ShelfType;
  type_in?: ShelfType[] | ShelfType;
  type_not_in?: ShelfType[] | ShelfType;
  user?: UserWhereInput;
  book?: BookWhereInput;
  AND?: ShelfWhereInput[] | ShelfWhereInput;
  OR?: ShelfWhereInput[] | ShelfWhereInput;
  NOT?: ShelfWhereInput[] | ShelfWhereInput;
}

export type SystemConfigWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface SystemConfigWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SystemConfigWhereInput[] | SystemConfigWhereInput;
  OR?: SystemConfigWhereInput[] | SystemConfigWhereInput;
  NOT?: SystemConfigWhereInput[] | SystemConfigWhereInput;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TranslatorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  userID?: ID_Input;
}>;

export type UserAdminWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserAdminRoleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  permissions_every?: UserAdminPermissionWhereInput;
  permissions_some?: UserAdminPermissionWhereInput;
  permissions_none?: UserAdminPermissionWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserAdminRoleWhereInput[] | UserAdminRoleWhereInput;
  OR?: UserAdminRoleWhereInput[] | UserAdminRoleWhereInput;
  NOT?: UserAdminRoleWhereInput[] | UserAdminRoleWhereInput;
}

export interface UserAdminPermissionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  resource?: String;
  resource_not?: String;
  resource_in?: String[] | String;
  resource_not_in?: String[] | String;
  resource_lt?: String;
  resource_lte?: String;
  resource_gt?: String;
  resource_gte?: String;
  resource_contains?: String;
  resource_not_contains?: String;
  resource_starts_with?: String;
  resource_not_starts_with?: String;
  resource_ends_with?: String;
  resource_not_ends_with?: String;
  AND?: UserAdminPermissionWhereInput[] | UserAdminPermissionWhereInput;
  OR?: UserAdminPermissionWhereInput[] | UserAdminPermissionWhereInput;
  NOT?: UserAdminPermissionWhereInput[] | UserAdminPermissionWhereInput;
}

export interface UserAdminWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  hashedPassword?: String;
  hashedPassword_not?: String;
  hashedPassword_in?: String[] | String;
  hashedPassword_not_in?: String[] | String;
  hashedPassword_lt?: String;
  hashedPassword_lte?: String;
  hashedPassword_gt?: String;
  hashedPassword_gte?: String;
  hashedPassword_contains?: String;
  hashedPassword_not_contains?: String;
  hashedPassword_starts_with?: String;
  hashedPassword_not_starts_with?: String;
  hashedPassword_ends_with?: String;
  hashedPassword_not_ends_with?: String;
  roles_every?: UserAdminRoleWhereInput;
  roles_some?: UserAdminRoleWhereInput;
  roles_none?: UserAdminRoleWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserAdminWhereInput[] | UserAdminWhereInput;
  OR?: UserAdminWhereInput[] | UserAdminWhereInput;
  NOT?: UserAdminWhereInput[] | UserAdminWhereInput;
}

export type UserAdminPermissionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserAdminRoleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export type VendorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type VendorBillingInformationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type VendorRevenueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AdsBannerCreateInput {
  image?: ImageCreateOneInput;
  name?: String;
  order?: Float;
  altTag?: String;
  backgroundColor?: String;
  url?: String;
  page?: String;
  position?: String;
  publishTimeline?: PublishTimelineCreateOneInput;
}

export interface ImageCreateOneInput {
  create?: ImageCreateInput;
  connect?: ImageWhereUniqueInput;
}

export interface ImageCreateInput {
  small: String;
  medium: String;
  large: String;
  fileName: String;
}

export interface PublishTimelineCreateOneInput {
  create?: PublishTimelineCreateInput;
}

export interface PublishTimelineCreateInput {
  startAt: DateTimeInput;
  endAt?: DateTimeInput;
}

export interface AdsBannerUpdateInput {
  image?: ImageUpdateOneInput;
  name?: String;
  order?: Float;
  altTag?: String;
  backgroundColor?: String;
  url?: String;
  page?: String;
  position?: String;
  publishTimeline?: PublishTimelineUpdateOneInput;
}

export interface ImageUpdateOneInput {
  create?: ImageCreateInput;
  update?: ImageUpdateDataInput;
  upsert?: ImageUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ImageWhereUniqueInput;
}

export interface ImageUpdateDataInput {
  small?: String;
  medium?: String;
  large?: String;
  fileName?: String;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface PublishTimelineUpdateOneInput {
  create?: PublishTimelineCreateInput;
  update?: PublishTimelineUpdateDataInput;
  upsert?: PublishTimelineUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface PublishTimelineUpdateDataInput {
  startAt?: DateTimeInput;
  endAt?: DateTimeInput;
}

export interface PublishTimelineUpsertNestedInput {
  update: PublishTimelineUpdateDataInput;
  create: PublishTimelineCreateInput;
}

export interface AdsBannerUpdateManyMutationInput {
  name?: String;
  order?: Float;
  altTag?: String;
  backgroundColor?: String;
  url?: String;
  page?: String;
  position?: String;
}

export interface AuthorCreateInput {
  name: String;
  vendor?: VendorCreateOneWithoutAuthorsInput;
}

export interface VendorCreateOneWithoutAuthorsInput {
  create?: VendorCreateWithoutAuthorsInput;
  connect?: VendorWhereUniqueInput;
}

export interface VendorCreateWithoutAuthorsInput {
  type: VendorType;
  translators?: TranslatorCreateManyWithoutVendorInput;
  copyrightHolders?: CopyrightHolderCreateManyWithoutVendorInput;
  documents?: DocumentCreateManyInput;
  billingInformation: VendorBillingInformationCreateOneInput;
  phoneNumber?: String;
  email?: String;
}

export interface TranslatorCreateManyWithoutVendorInput {
  create?:
    | TranslatorCreateWithoutVendorInput[]
    | TranslatorCreateWithoutVendorInput;
  connect?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
}

export interface TranslatorCreateWithoutVendorInput {
  name: String;
}

export interface CopyrightHolderCreateManyWithoutVendorInput {
  create?:
    | CopyrightHolderCreateWithoutVendorInput[]
    | CopyrightHolderCreateWithoutVendorInput;
  connect?: CopyrightHolderWhereUniqueInput[] | CopyrightHolderWhereUniqueInput;
}

export interface CopyrightHolderCreateWithoutVendorInput {
  name: String;
}

export interface DocumentCreateManyInput {
  create?: DocumentCreateInput[] | DocumentCreateInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
}

export interface DocumentCreateInput {
  file?: FileCreateOneInput;
  image?: ImageCreateOneInput;
  type: DocumentType;
}

export interface FileCreateOneInput {
  create?: FileCreateInput;
  connect?: FileWhereUniqueInput;
}

export interface FileCreateInput {
  path: String;
  fileName: String;
}

export interface VendorBillingInformationCreateOneInput {
  create?: VendorBillingInformationCreateInput;
  connect?: VendorBillingInformationWhereUniqueInput;
}

export interface VendorBillingInformationCreateInput {
  billingType: VendorBillingType;
  companyName?: String;
  branchId?: String;
  taxID: String;
  firstName: String;
  lastName: String;
  bank?: String;
  bookBankNumber?: String;
  address: String;
  province?: String;
  zipCode?: String;
}

export interface AuthorUpdateInput {
  name?: String;
  vendor?: VendorUpdateOneWithoutAuthorsInput;
}

export interface VendorUpdateOneWithoutAuthorsInput {
  create?: VendorCreateWithoutAuthorsInput;
  update?: VendorUpdateWithoutAuthorsDataInput;
  upsert?: VendorUpsertWithoutAuthorsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VendorWhereUniqueInput;
}

export interface VendorUpdateWithoutAuthorsDataInput {
  type?: VendorType;
  translators?: TranslatorUpdateManyWithoutVendorInput;
  copyrightHolders?: CopyrightHolderUpdateManyWithoutVendorInput;
  documents?: DocumentUpdateManyInput;
  billingInformation?: VendorBillingInformationUpdateOneRequiredInput;
  phoneNumber?: String;
  email?: String;
}

export interface TranslatorUpdateManyWithoutVendorInput {
  create?:
    | TranslatorCreateWithoutVendorInput[]
    | TranslatorCreateWithoutVendorInput;
  delete?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
  connect?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
  set?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
  disconnect?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
  update?:
    | TranslatorUpdateWithWhereUniqueWithoutVendorInput[]
    | TranslatorUpdateWithWhereUniqueWithoutVendorInput;
  upsert?:
    | TranslatorUpsertWithWhereUniqueWithoutVendorInput[]
    | TranslatorUpsertWithWhereUniqueWithoutVendorInput;
  deleteMany?: TranslatorScalarWhereInput[] | TranslatorScalarWhereInput;
  updateMany?:
    | TranslatorUpdateManyWithWhereNestedInput[]
    | TranslatorUpdateManyWithWhereNestedInput;
}

export interface TranslatorUpdateWithWhereUniqueWithoutVendorInput {
  where: TranslatorWhereUniqueInput;
  data: TranslatorUpdateWithoutVendorDataInput;
}

export interface TranslatorUpdateWithoutVendorDataInput {
  name?: String;
}

export interface TranslatorUpsertWithWhereUniqueWithoutVendorInput {
  where: TranslatorWhereUniqueInput;
  update: TranslatorUpdateWithoutVendorDataInput;
  create: TranslatorCreateWithoutVendorInput;
}

export interface TranslatorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TranslatorScalarWhereInput[] | TranslatorScalarWhereInput;
  OR?: TranslatorScalarWhereInput[] | TranslatorScalarWhereInput;
  NOT?: TranslatorScalarWhereInput[] | TranslatorScalarWhereInput;
}

export interface TranslatorUpdateManyWithWhereNestedInput {
  where: TranslatorScalarWhereInput;
  data: TranslatorUpdateManyDataInput;
}

export interface TranslatorUpdateManyDataInput {
  name?: String;
}

export interface CopyrightHolderUpdateManyWithoutVendorInput {
  create?:
    | CopyrightHolderCreateWithoutVendorInput[]
    | CopyrightHolderCreateWithoutVendorInput;
  delete?: CopyrightHolderWhereUniqueInput[] | CopyrightHolderWhereUniqueInput;
  connect?: CopyrightHolderWhereUniqueInput[] | CopyrightHolderWhereUniqueInput;
  set?: CopyrightHolderWhereUniqueInput[] | CopyrightHolderWhereUniqueInput;
  disconnect?:
    | CopyrightHolderWhereUniqueInput[]
    | CopyrightHolderWhereUniqueInput;
  update?:
    | CopyrightHolderUpdateWithWhereUniqueWithoutVendorInput[]
    | CopyrightHolderUpdateWithWhereUniqueWithoutVendorInput;
  upsert?:
    | CopyrightHolderUpsertWithWhereUniqueWithoutVendorInput[]
    | CopyrightHolderUpsertWithWhereUniqueWithoutVendorInput;
  deleteMany?:
    | CopyrightHolderScalarWhereInput[]
    | CopyrightHolderScalarWhereInput;
  updateMany?:
    | CopyrightHolderUpdateManyWithWhereNestedInput[]
    | CopyrightHolderUpdateManyWithWhereNestedInput;
}

export interface CopyrightHolderUpdateWithWhereUniqueWithoutVendorInput {
  where: CopyrightHolderWhereUniqueInput;
  data: CopyrightHolderUpdateWithoutVendorDataInput;
}

export interface CopyrightHolderUpdateWithoutVendorDataInput {
  name?: String;
}

export interface CopyrightHolderUpsertWithWhereUniqueWithoutVendorInput {
  where: CopyrightHolderWhereUniqueInput;
  update: CopyrightHolderUpdateWithoutVendorDataInput;
  create: CopyrightHolderCreateWithoutVendorInput;
}

export interface CopyrightHolderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CopyrightHolderScalarWhereInput[] | CopyrightHolderScalarWhereInput;
  OR?: CopyrightHolderScalarWhereInput[] | CopyrightHolderScalarWhereInput;
  NOT?: CopyrightHolderScalarWhereInput[] | CopyrightHolderScalarWhereInput;
}

export interface CopyrightHolderUpdateManyWithWhereNestedInput {
  where: CopyrightHolderScalarWhereInput;
  data: CopyrightHolderUpdateManyDataInput;
}

export interface CopyrightHolderUpdateManyDataInput {
  name?: String;
}

export interface DocumentUpdateManyInput {
  create?: DocumentCreateInput[] | DocumentCreateInput;
  update?:
    | DocumentUpdateWithWhereUniqueNestedInput[]
    | DocumentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DocumentUpsertWithWhereUniqueNestedInput[]
    | DocumentUpsertWithWhereUniqueNestedInput;
  delete?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  connect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  set?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  disconnect?: DocumentWhereUniqueInput[] | DocumentWhereUniqueInput;
  deleteMany?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
  updateMany?:
    | DocumentUpdateManyWithWhereNestedInput[]
    | DocumentUpdateManyWithWhereNestedInput;
}

export interface DocumentUpdateWithWhereUniqueNestedInput {
  where: DocumentWhereUniqueInput;
  data: DocumentUpdateDataInput;
}

export interface DocumentUpdateDataInput {
  file?: FileUpdateOneInput;
  image?: ImageUpdateOneInput;
  type?: DocumentType;
}

export interface FileUpdateOneInput {
  create?: FileCreateInput;
  update?: FileUpdateDataInput;
  upsert?: FileUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FileWhereUniqueInput;
}

export interface FileUpdateDataInput {
  path?: String;
  fileName?: String;
}

export interface FileUpsertNestedInput {
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface DocumentUpsertWithWhereUniqueNestedInput {
  where: DocumentWhereUniqueInput;
  update: DocumentUpdateDataInput;
  create: DocumentCreateInput;
}

export interface DocumentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: DocumentType;
  type_not?: DocumentType;
  type_in?: DocumentType[] | DocumentType;
  type_not_in?: DocumentType[] | DocumentType;
  AND?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
  OR?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
  NOT?: DocumentScalarWhereInput[] | DocumentScalarWhereInput;
}

export interface DocumentUpdateManyWithWhereNestedInput {
  where: DocumentScalarWhereInput;
  data: DocumentUpdateManyDataInput;
}

export interface DocumentUpdateManyDataInput {
  type?: DocumentType;
}

export interface VendorBillingInformationUpdateOneRequiredInput {
  create?: VendorBillingInformationCreateInput;
  update?: VendorBillingInformationUpdateDataInput;
  upsert?: VendorBillingInformationUpsertNestedInput;
  connect?: VendorBillingInformationWhereUniqueInput;
}

export interface VendorBillingInformationUpdateDataInput {
  billingType?: VendorBillingType;
  companyName?: String;
  branchId?: String;
  taxID?: String;
  firstName?: String;
  lastName?: String;
  bank?: String;
  bookBankNumber?: String;
  address?: String;
  province?: String;
  zipCode?: String;
}

export interface VendorBillingInformationUpsertNestedInput {
  update: VendorBillingInformationUpdateDataInput;
  create: VendorBillingInformationCreateInput;
}

export interface VendorUpsertWithoutAuthorsInput {
  update: VendorUpdateWithoutAuthorsDataInput;
  create: VendorCreateWithoutAuthorsInput;
}

export interface AuthorUpdateManyMutationInput {
  name?: String;
}

export interface BehaviorCreateInput {
  user?: UserCreateOneInput;
  ip: String;
  action: String;
  payload: Json;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  userID: ID_Input;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender?: Gender;
  defaultProfilePicture?: String;
  transactions?: TransactionCreateManyWithoutUserInput;
  exchangeTransactions?: ExchangeTransactionCreateManyWithoutUserInput;
}

export interface TransactionCreateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
}

export interface TransactionCreateWithoutUserInput {
  type: TransactionType;
  currencyType: CurrencyType;
  amount: Float;
  exchangeTransaction?: ExchangeTransactionCreateOneInput;
  items?: ItemCreateManyWithoutTransactionInput;
  vendorRevenue?: VendorRevenueCreateManyWithoutTransactionInput;
}

export interface ExchangeTransactionCreateOneInput {
  create?: ExchangeTransactionCreateInput;
  connect?: ExchangeTransactionWhereUniqueInput;
}

export interface ExchangeTransactionCreateInput {
  orderID?: String;
  user: UserCreateOneWithoutExchangeTransactionsInput;
  tier: ExchangeTierCreateOneInput;
  status?: ExchangeTransactionStatusHistoryCreateManyInput;
  currentStatus?: ExchangeTransactionType;
  payload: Json;
  refCode?: String;
}

export interface UserCreateOneWithoutExchangeTransactionsInput {
  create?: UserCreateWithoutExchangeTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutExchangeTransactionsInput {
  userID: ID_Input;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender?: Gender;
  defaultProfilePicture?: String;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface ExchangeTierCreateOneInput {
  create?: ExchangeTierCreateInput;
  connect?: ExchangeTierWhereUniqueInput;
}

export interface ExchangeTierCreateInput {
  type: ExchangeType;
  name: String;
  currencyType: CurrencyType;
  income: Float;
  outcome: Float;
  promotions?: PromotionCreateManyInput;
  isDefault?: Boolean;
  publishTimeline?: PublishTimelineCreateOneInput;
}

export interface PromotionCreateManyInput {
  create?: PromotionCreateInput[] | PromotionCreateInput;
  connect?: PromotionWhereUniqueInput[] | PromotionWhereUniqueInput;
}

export interface PromotionCreateInput {
  name: String;
  unit: PromotionUnit;
  type: PromotionType;
  amount: Float;
}

export interface ExchangeTransactionStatusHistoryCreateManyInput {
  create?:
    | ExchangeTransactionStatusHistoryCreateInput[]
    | ExchangeTransactionStatusHistoryCreateInput;
  connect?:
    | ExchangeTransactionStatusHistoryWhereUniqueInput[]
    | ExchangeTransactionStatusHistoryWhereUniqueInput;
}

export interface ExchangeTransactionStatusHistoryCreateInput {
  status: ExchangeTransactionType;
  message?: String;
}

export interface ItemCreateManyWithoutTransactionInput {
  create?:
    | ItemCreateWithoutTransactionInput[]
    | ItemCreateWithoutTransactionInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface ItemCreateWithoutTransactionInput {
  user: UserCreateOneInput;
  asset?: ItemAssetCreateOneWithoutItemInput;
  amount: Int;
  expireAt?: DateTimeInput;
}

export interface ItemAssetCreateOneWithoutItemInput {
  create?: ItemAssetCreateWithoutItemInput;
  connect?: ItemAssetWhereUniqueInput;
}

export interface ItemAssetCreateWithoutItemInput {
  assetType: String;
  assetID: ID_Input;
}

export interface VendorRevenueCreateManyWithoutTransactionInput {
  create?:
    | VendorRevenueCreateWithoutTransactionInput[]
    | VendorRevenueCreateWithoutTransactionInput;
  connect?: VendorRevenueWhereUniqueInput[] | VendorRevenueWhereUniqueInput;
}

export interface VendorRevenueCreateWithoutTransactionInput {
  weight: Int;
  revenueSharing: RevenueSharingCreateOneInput;
}

export interface RevenueSharingCreateOneInput {
  create?: RevenueSharingCreateInput;
  connect?: RevenueSharingWhereUniqueInput;
}

export interface RevenueSharingCreateInput {
  vendor: VendorCreateOneInput;
  book: BookCreateOneInput;
  commission: Float;
  status: RevenueSharingStatus;
}

export interface VendorCreateOneInput {
  create?: VendorCreateInput;
  connect?: VendorWhereUniqueInput;
}

export interface VendorCreateInput {
  type: VendorType;
  authors?: AuthorCreateManyWithoutVendorInput;
  translators?: TranslatorCreateManyWithoutVendorInput;
  copyrightHolders?: CopyrightHolderCreateManyWithoutVendorInput;
  documents?: DocumentCreateManyInput;
  billingInformation: VendorBillingInformationCreateOneInput;
  phoneNumber?: String;
  email?: String;
}

export interface AuthorCreateManyWithoutVendorInput {
  create?: AuthorCreateWithoutVendorInput[] | AuthorCreateWithoutVendorInput;
  connect?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
}

export interface AuthorCreateWithoutVendorInput {
  name: String;
}

export interface BookCreateOneInput {
  create?: BookCreateInput;
  connect?: BookWhereUniqueInput;
}

export interface BookCreateInput {
  slug?: String;
  name: String;
  introduction: Json;
  synopsis?: String;
  thumbnail?: ImageCreateOneInput;
  copyrightHolder?: CopyrightHolderCreateOneInput;
  authors?: AuthorCreateManyInput;
  mainCategory?: CategoryCreateOneInput;
  secondaryCategory?: CategoryCreateOneInput;
  translators?: TranslatorCreateManyInput;
  volumes?: BookVolumeCreateManyWithoutBookInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  publishTimeline?: PublishTimelineCreateOneInput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface CopyrightHolderCreateOneInput {
  create?: CopyrightHolderCreateInput;
  connect?: CopyrightHolderWhereUniqueInput;
}

export interface CopyrightHolderCreateInput {
  name: String;
  vendor?: VendorCreateOneWithoutCopyrightHoldersInput;
}

export interface VendorCreateOneWithoutCopyrightHoldersInput {
  create?: VendorCreateWithoutCopyrightHoldersInput;
  connect?: VendorWhereUniqueInput;
}

export interface VendorCreateWithoutCopyrightHoldersInput {
  type: VendorType;
  authors?: AuthorCreateManyWithoutVendorInput;
  translators?: TranslatorCreateManyWithoutVendorInput;
  documents?: DocumentCreateManyInput;
  billingInformation: VendorBillingInformationCreateOneInput;
  phoneNumber?: String;
  email?: String;
}

export interface AuthorCreateManyInput {
  create?: AuthorCreateInput[] | AuthorCreateInput;
  connect?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
}

export interface CategoryCreateOneInput {
  create?: CategoryCreateInput;
  connect?: CategoryWhereUniqueInput;
}

export interface CategoryCreateInput {
  name: String;
}

export interface TranslatorCreateManyInput {
  create?: TranslatorCreateInput[] | TranslatorCreateInput;
  connect?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
}

export interface TranslatorCreateInput {
  name: String;
  vendor?: VendorCreateOneWithoutTranslatorsInput;
}

export interface VendorCreateOneWithoutTranslatorsInput {
  create?: VendorCreateWithoutTranslatorsInput;
  connect?: VendorWhereUniqueInput;
}

export interface VendorCreateWithoutTranslatorsInput {
  type: VendorType;
  authors?: AuthorCreateManyWithoutVendorInput;
  copyrightHolders?: CopyrightHolderCreateManyWithoutVendorInput;
  documents?: DocumentCreateManyInput;
  billingInformation: VendorBillingInformationCreateOneInput;
  phoneNumber?: String;
  email?: String;
}

export interface BookVolumeCreateManyWithoutBookInput {
  create?:
    | BookVolumeCreateWithoutBookInput[]
    | BookVolumeCreateWithoutBookInput;
  connect?: BookVolumeWhereUniqueInput[] | BookVolumeWhereUniqueInput;
}

export interface BookVolumeCreateWithoutBookInput {
  slug?: String;
  title: String;
  episodes?: BookEpisodeCreateManyWithoutVolumeInput;
  isPublished?: Boolean;
}

export interface BookEpisodeCreateManyWithoutVolumeInput {
  create?:
    | BookEpisodeCreateWithoutVolumeInput[]
    | BookEpisodeCreateWithoutVolumeInput;
  connect?: BookEpisodeWhereUniqueInput[] | BookEpisodeWhereUniqueInput;
}

export interface BookEpisodeCreateWithoutVolumeInput {
  slug?: String;
  authors?: AuthorCreateManyInput;
  translators?: TranslatorCreateManyInput;
  prices?: PriceCreateManyInput;
  priceHistory?: PriceCreateManyInput;
  publishContent?: BookEpisodeContentCreateOneInput;
  draftContent?: BookEpisodeContentCreateOneInput;
  revisionContents?: BookEpisodeContentCreateManyInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorCreateOneInput;
  publishTimeline?: PublishTimelineCreateOneInput;
  isUnlisted?: Boolean;
  pageView?: PageViewCreateOneWithoutEpisodeInput;
  reviews?: BookEpisodeReviewPostCreateManyWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface PriceCreateManyInput {
  create?: PriceCreateInput[] | PriceCreateInput;
  connect?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
}

export interface PriceCreateInput {
  currencyType: CurrencyType;
  amount: Float;
  archiveAt?: DateTimeInput;
}

export interface BookEpisodeContentCreateOneInput {
  create?: BookEpisodeContentCreateInput;
  connect?: BookEpisodeContentWhereUniqueInput;
}

export interface BookEpisodeContentCreateInput {
  title: String;
  draft?: Json;
}

export interface BookEpisodeContentCreateManyInput {
  create?: BookEpisodeContentCreateInput[] | BookEpisodeContentCreateInput;
  connect?:
    | BookEpisodeContentWhereUniqueInput[]
    | BookEpisodeContentWhereUniqueInput;
}

export interface PageViewCreateOneWithoutEpisodeInput {
  create?: PageViewCreateWithoutEpisodeInput;
  connect?: PageViewWhereUniqueInput;
}

export interface PageViewCreateWithoutEpisodeInput {
  count?: Int;
}

export interface BookEpisodeReviewPostCreateManyWithoutEpisodeInput {
  create?:
    | BookEpisodeReviewPostCreateWithoutEpisodeInput[]
    | BookEpisodeReviewPostCreateWithoutEpisodeInput;
  connect?:
    | BookEpisodeReviewPostWhereUniqueInput[]
    | BookEpisodeReviewPostWhereUniqueInput;
}

export interface BookEpisodeReviewPostCreateWithoutEpisodeInput {
  rating: Int;
  post: PostCreateOneInput;
}

export interface PostCreateOneInput {
  create?: PostCreateInput;
  connect?: PostWhereUniqueInput;
}

export interface PostCreateInput {
  type: PostType;
  user: UserCreateOneInput;
  message: String;
  status?: ReviewPostStatus;
}

export interface ExchangeTransactionCreateManyWithoutUserInput {
  create?:
    | ExchangeTransactionCreateWithoutUserInput[]
    | ExchangeTransactionCreateWithoutUserInput;
  connect?:
    | ExchangeTransactionWhereUniqueInput[]
    | ExchangeTransactionWhereUniqueInput;
}

export interface ExchangeTransactionCreateWithoutUserInput {
  orderID?: String;
  tier: ExchangeTierCreateOneInput;
  status?: ExchangeTransactionStatusHistoryCreateManyInput;
  currentStatus?: ExchangeTransactionType;
  payload: Json;
  refCode?: String;
}

export interface BehaviorUpdateInput {
  user?: UserUpdateOneInput;
  ip?: String;
  action?: String;
  payload?: Json;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  userID?: ID_Input;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender?: Gender;
  defaultProfilePicture?: String;
  transactions?: TransactionUpdateManyWithoutUserInput;
  exchangeTransactions?: ExchangeTransactionUpdateManyWithoutUserInput;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  delete?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  set?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  disconnect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  update?:
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  updateMany?:
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface TransactionUpdateWithoutUserDataInput {
  type?: TransactionType;
  currencyType?: CurrencyType;
  amount?: Float;
  exchangeTransaction?: ExchangeTransactionUpdateOneInput;
  items?: ItemUpdateManyWithoutTransactionInput;
  vendorRevenue?: VendorRevenueUpdateManyWithoutTransactionInput;
}

export interface ExchangeTransactionUpdateOneInput {
  create?: ExchangeTransactionCreateInput;
  update?: ExchangeTransactionUpdateDataInput;
  upsert?: ExchangeTransactionUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExchangeTransactionWhereUniqueInput;
}

export interface ExchangeTransactionUpdateDataInput {
  orderID?: String;
  user?: UserUpdateOneRequiredWithoutExchangeTransactionsInput;
  tier?: ExchangeTierUpdateOneRequiredInput;
  status?: ExchangeTransactionStatusHistoryUpdateManyInput;
  currentStatus?: ExchangeTransactionType;
  payload?: Json;
  refCode?: String;
}

export interface UserUpdateOneRequiredWithoutExchangeTransactionsInput {
  create?: UserCreateWithoutExchangeTransactionsInput;
  update?: UserUpdateWithoutExchangeTransactionsDataInput;
  upsert?: UserUpsertWithoutExchangeTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutExchangeTransactionsDataInput {
  userID?: ID_Input;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender?: Gender;
  defaultProfilePicture?: String;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface UserUpsertWithoutExchangeTransactionsInput {
  update: UserUpdateWithoutExchangeTransactionsDataInput;
  create: UserCreateWithoutExchangeTransactionsInput;
}

export interface ExchangeTierUpdateOneRequiredInput {
  create?: ExchangeTierCreateInput;
  update?: ExchangeTierUpdateDataInput;
  upsert?: ExchangeTierUpsertNestedInput;
  connect?: ExchangeTierWhereUniqueInput;
}

export interface ExchangeTierUpdateDataInput {
  type?: ExchangeType;
  name?: String;
  currencyType?: CurrencyType;
  income?: Float;
  outcome?: Float;
  promotions?: PromotionUpdateManyInput;
  isDefault?: Boolean;
  publishTimeline?: PublishTimelineUpdateOneInput;
}

export interface PromotionUpdateManyInput {
  create?: PromotionCreateInput[] | PromotionCreateInput;
  update?:
    | PromotionUpdateWithWhereUniqueNestedInput[]
    | PromotionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PromotionUpsertWithWhereUniqueNestedInput[]
    | PromotionUpsertWithWhereUniqueNestedInput;
  delete?: PromotionWhereUniqueInput[] | PromotionWhereUniqueInput;
  connect?: PromotionWhereUniqueInput[] | PromotionWhereUniqueInput;
  set?: PromotionWhereUniqueInput[] | PromotionWhereUniqueInput;
  disconnect?: PromotionWhereUniqueInput[] | PromotionWhereUniqueInput;
  deleteMany?: PromotionScalarWhereInput[] | PromotionScalarWhereInput;
  updateMany?:
    | PromotionUpdateManyWithWhereNestedInput[]
    | PromotionUpdateManyWithWhereNestedInput;
}

export interface PromotionUpdateWithWhereUniqueNestedInput {
  where: PromotionWhereUniqueInput;
  data: PromotionUpdateDataInput;
}

export interface PromotionUpdateDataInput {
  name?: String;
  unit?: PromotionUnit;
  type?: PromotionType;
  amount?: Float;
}

export interface PromotionUpsertWithWhereUniqueNestedInput {
  where: PromotionWhereUniqueInput;
  update: PromotionUpdateDataInput;
  create: PromotionCreateInput;
}

export interface PromotionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  unit?: PromotionUnit;
  unit_not?: PromotionUnit;
  unit_in?: PromotionUnit[] | PromotionUnit;
  unit_not_in?: PromotionUnit[] | PromotionUnit;
  type?: PromotionType;
  type_not?: PromotionType;
  type_in?: PromotionType[] | PromotionType;
  type_not_in?: PromotionType[] | PromotionType;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PromotionScalarWhereInput[] | PromotionScalarWhereInput;
  OR?: PromotionScalarWhereInput[] | PromotionScalarWhereInput;
  NOT?: PromotionScalarWhereInput[] | PromotionScalarWhereInput;
}

export interface PromotionUpdateManyWithWhereNestedInput {
  where: PromotionScalarWhereInput;
  data: PromotionUpdateManyDataInput;
}

export interface PromotionUpdateManyDataInput {
  name?: String;
  unit?: PromotionUnit;
  type?: PromotionType;
  amount?: Float;
}

export interface ExchangeTierUpsertNestedInput {
  update: ExchangeTierUpdateDataInput;
  create: ExchangeTierCreateInput;
}

export interface ExchangeTransactionStatusHistoryUpdateManyInput {
  create?:
    | ExchangeTransactionStatusHistoryCreateInput[]
    | ExchangeTransactionStatusHistoryCreateInput;
  update?:
    | ExchangeTransactionStatusHistoryUpdateWithWhereUniqueNestedInput[]
    | ExchangeTransactionStatusHistoryUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ExchangeTransactionStatusHistoryUpsertWithWhereUniqueNestedInput[]
    | ExchangeTransactionStatusHistoryUpsertWithWhereUniqueNestedInput;
  delete?:
    | ExchangeTransactionStatusHistoryWhereUniqueInput[]
    | ExchangeTransactionStatusHistoryWhereUniqueInput;
  connect?:
    | ExchangeTransactionStatusHistoryWhereUniqueInput[]
    | ExchangeTransactionStatusHistoryWhereUniqueInput;
  set?:
    | ExchangeTransactionStatusHistoryWhereUniqueInput[]
    | ExchangeTransactionStatusHistoryWhereUniqueInput;
  disconnect?:
    | ExchangeTransactionStatusHistoryWhereUniqueInput[]
    | ExchangeTransactionStatusHistoryWhereUniqueInput;
  deleteMany?:
    | ExchangeTransactionStatusHistoryScalarWhereInput[]
    | ExchangeTransactionStatusHistoryScalarWhereInput;
  updateMany?:
    | ExchangeTransactionStatusHistoryUpdateManyWithWhereNestedInput[]
    | ExchangeTransactionStatusHistoryUpdateManyWithWhereNestedInput;
}

export interface ExchangeTransactionStatusHistoryUpdateWithWhereUniqueNestedInput {
  where: ExchangeTransactionStatusHistoryWhereUniqueInput;
  data: ExchangeTransactionStatusHistoryUpdateDataInput;
}

export interface ExchangeTransactionStatusHistoryUpdateDataInput {
  status?: ExchangeTransactionType;
  message?: String;
}

export interface ExchangeTransactionStatusHistoryUpsertWithWhereUniqueNestedInput {
  where: ExchangeTransactionStatusHistoryWhereUniqueInput;
  update: ExchangeTransactionStatusHistoryUpdateDataInput;
  create: ExchangeTransactionStatusHistoryCreateInput;
}

export interface ExchangeTransactionStatusHistoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: ExchangeTransactionType;
  status_not?: ExchangeTransactionType;
  status_in?: ExchangeTransactionType[] | ExchangeTransactionType;
  status_not_in?: ExchangeTransactionType[] | ExchangeTransactionType;
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  AND?:
    | ExchangeTransactionStatusHistoryScalarWhereInput[]
    | ExchangeTransactionStatusHistoryScalarWhereInput;
  OR?:
    | ExchangeTransactionStatusHistoryScalarWhereInput[]
    | ExchangeTransactionStatusHistoryScalarWhereInput;
  NOT?:
    | ExchangeTransactionStatusHistoryScalarWhereInput[]
    | ExchangeTransactionStatusHistoryScalarWhereInput;
}

export interface ExchangeTransactionStatusHistoryUpdateManyWithWhereNestedInput {
  where: ExchangeTransactionStatusHistoryScalarWhereInput;
  data: ExchangeTransactionStatusHistoryUpdateManyDataInput;
}

export interface ExchangeTransactionStatusHistoryUpdateManyDataInput {
  status?: ExchangeTransactionType;
  message?: String;
}

export interface ExchangeTransactionUpsertNestedInput {
  update: ExchangeTransactionUpdateDataInput;
  create: ExchangeTransactionCreateInput;
}

export interface ItemUpdateManyWithoutTransactionInput {
  create?:
    | ItemCreateWithoutTransactionInput[]
    | ItemCreateWithoutTransactionInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  set?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  update?:
    | ItemUpdateWithWhereUniqueWithoutTransactionInput[]
    | ItemUpdateWithWhereUniqueWithoutTransactionInput;
  upsert?:
    | ItemUpsertWithWhereUniqueWithoutTransactionInput[]
    | ItemUpsertWithWhereUniqueWithoutTransactionInput;
  deleteMany?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  updateMany?:
    | ItemUpdateManyWithWhereNestedInput[]
    | ItemUpdateManyWithWhereNestedInput;
}

export interface ItemUpdateWithWhereUniqueWithoutTransactionInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutTransactionDataInput;
}

export interface ItemUpdateWithoutTransactionDataInput {
  user?: UserUpdateOneRequiredInput;
  asset?: ItemAssetUpdateOneWithoutItemInput;
  amount?: Int;
  expireAt?: DateTimeInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ItemAssetUpdateOneWithoutItemInput {
  create?: ItemAssetCreateWithoutItemInput;
  update?: ItemAssetUpdateWithoutItemDataInput;
  upsert?: ItemAssetUpsertWithoutItemInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ItemAssetWhereUniqueInput;
}

export interface ItemAssetUpdateWithoutItemDataInput {
  assetType?: String;
  assetID?: ID_Input;
}

export interface ItemAssetUpsertWithoutItemInput {
  update: ItemAssetUpdateWithoutItemDataInput;
  create: ItemAssetCreateWithoutItemInput;
}

export interface ItemUpsertWithWhereUniqueWithoutTransactionInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutTransactionDataInput;
  create: ItemCreateWithoutTransactionInput;
}

export interface ItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  expireAt?: DateTimeInput;
  expireAt_not?: DateTimeInput;
  expireAt_in?: DateTimeInput[] | DateTimeInput;
  expireAt_not_in?: DateTimeInput[] | DateTimeInput;
  expireAt_lt?: DateTimeInput;
  expireAt_lte?: DateTimeInput;
  expireAt_gt?: DateTimeInput;
  expireAt_gte?: DateTimeInput;
  AND?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  OR?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  NOT?: ItemScalarWhereInput[] | ItemScalarWhereInput;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface ItemUpdateManyDataInput {
  amount?: Int;
  expireAt?: DateTimeInput;
}

export interface VendorRevenueUpdateManyWithoutTransactionInput {
  create?:
    | VendorRevenueCreateWithoutTransactionInput[]
    | VendorRevenueCreateWithoutTransactionInput;
  delete?: VendorRevenueWhereUniqueInput[] | VendorRevenueWhereUniqueInput;
  connect?: VendorRevenueWhereUniqueInput[] | VendorRevenueWhereUniqueInput;
  set?: VendorRevenueWhereUniqueInput[] | VendorRevenueWhereUniqueInput;
  disconnect?: VendorRevenueWhereUniqueInput[] | VendorRevenueWhereUniqueInput;
  update?:
    | VendorRevenueUpdateWithWhereUniqueWithoutTransactionInput[]
    | VendorRevenueUpdateWithWhereUniqueWithoutTransactionInput;
  upsert?:
    | VendorRevenueUpsertWithWhereUniqueWithoutTransactionInput[]
    | VendorRevenueUpsertWithWhereUniqueWithoutTransactionInput;
  deleteMany?: VendorRevenueScalarWhereInput[] | VendorRevenueScalarWhereInput;
  updateMany?:
    | VendorRevenueUpdateManyWithWhereNestedInput[]
    | VendorRevenueUpdateManyWithWhereNestedInput;
}

export interface VendorRevenueUpdateWithWhereUniqueWithoutTransactionInput {
  where: VendorRevenueWhereUniqueInput;
  data: VendorRevenueUpdateWithoutTransactionDataInput;
}

export interface VendorRevenueUpdateWithoutTransactionDataInput {
  weight?: Int;
  revenueSharing?: RevenueSharingUpdateOneRequiredInput;
}

export interface RevenueSharingUpdateOneRequiredInput {
  create?: RevenueSharingCreateInput;
  update?: RevenueSharingUpdateDataInput;
  upsert?: RevenueSharingUpsertNestedInput;
  connect?: RevenueSharingWhereUniqueInput;
}

export interface RevenueSharingUpdateDataInput {
  vendor?: VendorUpdateOneRequiredInput;
  book?: BookUpdateOneRequiredInput;
  commission?: Float;
  status?: RevenueSharingStatus;
}

export interface VendorUpdateOneRequiredInput {
  create?: VendorCreateInput;
  update?: VendorUpdateDataInput;
  upsert?: VendorUpsertNestedInput;
  connect?: VendorWhereUniqueInput;
}

export interface VendorUpdateDataInput {
  type?: VendorType;
  authors?: AuthorUpdateManyWithoutVendorInput;
  translators?: TranslatorUpdateManyWithoutVendorInput;
  copyrightHolders?: CopyrightHolderUpdateManyWithoutVendorInput;
  documents?: DocumentUpdateManyInput;
  billingInformation?: VendorBillingInformationUpdateOneRequiredInput;
  phoneNumber?: String;
  email?: String;
}

export interface AuthorUpdateManyWithoutVendorInput {
  create?: AuthorCreateWithoutVendorInput[] | AuthorCreateWithoutVendorInput;
  delete?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
  connect?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
  set?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
  disconnect?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
  update?:
    | AuthorUpdateWithWhereUniqueWithoutVendorInput[]
    | AuthorUpdateWithWhereUniqueWithoutVendorInput;
  upsert?:
    | AuthorUpsertWithWhereUniqueWithoutVendorInput[]
    | AuthorUpsertWithWhereUniqueWithoutVendorInput;
  deleteMany?: AuthorScalarWhereInput[] | AuthorScalarWhereInput;
  updateMany?:
    | AuthorUpdateManyWithWhereNestedInput[]
    | AuthorUpdateManyWithWhereNestedInput;
}

export interface AuthorUpdateWithWhereUniqueWithoutVendorInput {
  where: AuthorWhereUniqueInput;
  data: AuthorUpdateWithoutVendorDataInput;
}

export interface AuthorUpdateWithoutVendorDataInput {
  name?: String;
}

export interface AuthorUpsertWithWhereUniqueWithoutVendorInput {
  where: AuthorWhereUniqueInput;
  update: AuthorUpdateWithoutVendorDataInput;
  create: AuthorCreateWithoutVendorInput;
}

export interface AuthorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: AuthorScalarWhereInput[] | AuthorScalarWhereInput;
  OR?: AuthorScalarWhereInput[] | AuthorScalarWhereInput;
  NOT?: AuthorScalarWhereInput[] | AuthorScalarWhereInput;
}

export interface AuthorUpdateManyWithWhereNestedInput {
  where: AuthorScalarWhereInput;
  data: AuthorUpdateManyDataInput;
}

export interface AuthorUpdateManyDataInput {
  name?: String;
}

export interface VendorUpsertNestedInput {
  update: VendorUpdateDataInput;
  create: VendorCreateInput;
}

export interface BookUpdateOneRequiredInput {
  create?: BookCreateInput;
  update?: BookUpdateDataInput;
  upsert?: BookUpsertNestedInput;
  connect?: BookWhereUniqueInput;
}

export interface BookUpdateDataInput {
  slug?: String;
  name?: String;
  introduction?: Json;
  synopsis?: String;
  thumbnail?: ImageUpdateOneInput;
  copyrightHolder?: CopyrightHolderUpdateOneInput;
  authors?: AuthorUpdateManyInput;
  mainCategory?: CategoryUpdateOneInput;
  secondaryCategory?: CategoryUpdateOneInput;
  translators?: TranslatorUpdateManyInput;
  volumes?: BookVolumeUpdateManyWithoutBookInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  publishTimeline?: PublishTimelineUpdateOneInput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface CopyrightHolderUpdateOneInput {
  create?: CopyrightHolderCreateInput;
  update?: CopyrightHolderUpdateDataInput;
  upsert?: CopyrightHolderUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CopyrightHolderWhereUniqueInput;
}

export interface CopyrightHolderUpdateDataInput {
  name?: String;
  vendor?: VendorUpdateOneWithoutCopyrightHoldersInput;
}

export interface VendorUpdateOneWithoutCopyrightHoldersInput {
  create?: VendorCreateWithoutCopyrightHoldersInput;
  update?: VendorUpdateWithoutCopyrightHoldersDataInput;
  upsert?: VendorUpsertWithoutCopyrightHoldersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VendorWhereUniqueInput;
}

export interface VendorUpdateWithoutCopyrightHoldersDataInput {
  type?: VendorType;
  authors?: AuthorUpdateManyWithoutVendorInput;
  translators?: TranslatorUpdateManyWithoutVendorInput;
  documents?: DocumentUpdateManyInput;
  billingInformation?: VendorBillingInformationUpdateOneRequiredInput;
  phoneNumber?: String;
  email?: String;
}

export interface VendorUpsertWithoutCopyrightHoldersInput {
  update: VendorUpdateWithoutCopyrightHoldersDataInput;
  create: VendorCreateWithoutCopyrightHoldersInput;
}

export interface CopyrightHolderUpsertNestedInput {
  update: CopyrightHolderUpdateDataInput;
  create: CopyrightHolderCreateInput;
}

export interface AuthorUpdateManyInput {
  create?: AuthorCreateInput[] | AuthorCreateInput;
  update?:
    | AuthorUpdateWithWhereUniqueNestedInput[]
    | AuthorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | AuthorUpsertWithWhereUniqueNestedInput[]
    | AuthorUpsertWithWhereUniqueNestedInput;
  delete?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
  connect?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
  set?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
  disconnect?: AuthorWhereUniqueInput[] | AuthorWhereUniqueInput;
  deleteMany?: AuthorScalarWhereInput[] | AuthorScalarWhereInput;
  updateMany?:
    | AuthorUpdateManyWithWhereNestedInput[]
    | AuthorUpdateManyWithWhereNestedInput;
}

export interface AuthorUpdateWithWhereUniqueNestedInput {
  where: AuthorWhereUniqueInput;
  data: AuthorUpdateDataInput;
}

export interface AuthorUpdateDataInput {
  name?: String;
  vendor?: VendorUpdateOneWithoutAuthorsInput;
}

export interface AuthorUpsertWithWhereUniqueNestedInput {
  where: AuthorWhereUniqueInput;
  update: AuthorUpdateDataInput;
  create: AuthorCreateInput;
}

export interface CategoryUpdateOneInput {
  create?: CategoryCreateInput;
  update?: CategoryUpdateDataInput;
  upsert?: CategoryUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CategoryWhereUniqueInput;
}

export interface CategoryUpdateDataInput {
  name?: String;
}

export interface CategoryUpsertNestedInput {
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface TranslatorUpdateManyInput {
  create?: TranslatorCreateInput[] | TranslatorCreateInput;
  update?:
    | TranslatorUpdateWithWhereUniqueNestedInput[]
    | TranslatorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TranslatorUpsertWithWhereUniqueNestedInput[]
    | TranslatorUpsertWithWhereUniqueNestedInput;
  delete?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
  connect?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
  set?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
  disconnect?: TranslatorWhereUniqueInput[] | TranslatorWhereUniqueInput;
  deleteMany?: TranslatorScalarWhereInput[] | TranslatorScalarWhereInput;
  updateMany?:
    | TranslatorUpdateManyWithWhereNestedInput[]
    | TranslatorUpdateManyWithWhereNestedInput;
}

export interface TranslatorUpdateWithWhereUniqueNestedInput {
  where: TranslatorWhereUniqueInput;
  data: TranslatorUpdateDataInput;
}

export interface TranslatorUpdateDataInput {
  name?: String;
  vendor?: VendorUpdateOneWithoutTranslatorsInput;
}

export interface VendorUpdateOneWithoutTranslatorsInput {
  create?: VendorCreateWithoutTranslatorsInput;
  update?: VendorUpdateWithoutTranslatorsDataInput;
  upsert?: VendorUpsertWithoutTranslatorsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VendorWhereUniqueInput;
}

export interface VendorUpdateWithoutTranslatorsDataInput {
  type?: VendorType;
  authors?: AuthorUpdateManyWithoutVendorInput;
  copyrightHolders?: CopyrightHolderUpdateManyWithoutVendorInput;
  documents?: DocumentUpdateManyInput;
  billingInformation?: VendorBillingInformationUpdateOneRequiredInput;
  phoneNumber?: String;
  email?: String;
}

export interface VendorUpsertWithoutTranslatorsInput {
  update: VendorUpdateWithoutTranslatorsDataInput;
  create: VendorCreateWithoutTranslatorsInput;
}

export interface TranslatorUpsertWithWhereUniqueNestedInput {
  where: TranslatorWhereUniqueInput;
  update: TranslatorUpdateDataInput;
  create: TranslatorCreateInput;
}

export interface BookVolumeUpdateManyWithoutBookInput {
  create?:
    | BookVolumeCreateWithoutBookInput[]
    | BookVolumeCreateWithoutBookInput;
  delete?: BookVolumeWhereUniqueInput[] | BookVolumeWhereUniqueInput;
  connect?: BookVolumeWhereUniqueInput[] | BookVolumeWhereUniqueInput;
  set?: BookVolumeWhereUniqueInput[] | BookVolumeWhereUniqueInput;
  disconnect?: BookVolumeWhereUniqueInput[] | BookVolumeWhereUniqueInput;
  update?:
    | BookVolumeUpdateWithWhereUniqueWithoutBookInput[]
    | BookVolumeUpdateWithWhereUniqueWithoutBookInput;
  upsert?:
    | BookVolumeUpsertWithWhereUniqueWithoutBookInput[]
    | BookVolumeUpsertWithWhereUniqueWithoutBookInput;
  deleteMany?: BookVolumeScalarWhereInput[] | BookVolumeScalarWhereInput;
  updateMany?:
    | BookVolumeUpdateManyWithWhereNestedInput[]
    | BookVolumeUpdateManyWithWhereNestedInput;
}

export interface BookVolumeUpdateWithWhereUniqueWithoutBookInput {
  where: BookVolumeWhereUniqueInput;
  data: BookVolumeUpdateWithoutBookDataInput;
}

export interface BookVolumeUpdateWithoutBookDataInput {
  slug?: String;
  title?: String;
  episodes?: BookEpisodeUpdateManyWithoutVolumeInput;
  isPublished?: Boolean;
}

export interface BookEpisodeUpdateManyWithoutVolumeInput {
  create?:
    | BookEpisodeCreateWithoutVolumeInput[]
    | BookEpisodeCreateWithoutVolumeInput;
  delete?: BookEpisodeWhereUniqueInput[] | BookEpisodeWhereUniqueInput;
  connect?: BookEpisodeWhereUniqueInput[] | BookEpisodeWhereUniqueInput;
  set?: BookEpisodeWhereUniqueInput[] | BookEpisodeWhereUniqueInput;
  disconnect?: BookEpisodeWhereUniqueInput[] | BookEpisodeWhereUniqueInput;
  update?:
    | BookEpisodeUpdateWithWhereUniqueWithoutVolumeInput[]
    | BookEpisodeUpdateWithWhereUniqueWithoutVolumeInput;
  upsert?:
    | BookEpisodeUpsertWithWhereUniqueWithoutVolumeInput[]
    | BookEpisodeUpsertWithWhereUniqueWithoutVolumeInput;
  deleteMany?: BookEpisodeScalarWhereInput[] | BookEpisodeScalarWhereInput;
  updateMany?:
    | BookEpisodeUpdateManyWithWhereNestedInput[]
    | BookEpisodeUpdateManyWithWhereNestedInput;
}

export interface BookEpisodeUpdateWithWhereUniqueWithoutVolumeInput {
  where: BookEpisodeWhereUniqueInput;
  data: BookEpisodeUpdateWithoutVolumeDataInput;
}

export interface BookEpisodeUpdateWithoutVolumeDataInput {
  slug?: String;
  authors?: AuthorUpdateManyInput;
  translators?: TranslatorUpdateManyInput;
  prices?: PriceUpdateManyInput;
  priceHistory?: PriceUpdateManyInput;
  publishContent?: BookEpisodeContentUpdateOneInput;
  draftContent?: BookEpisodeContentUpdateOneInput;
  revisionContents?: BookEpisodeContentUpdateManyInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorUpdateOneInput;
  publishTimeline?: PublishTimelineUpdateOneInput;
  isUnlisted?: Boolean;
  pageView?: PageViewUpdateOneWithoutEpisodeInput;
  reviews?: BookEpisodeReviewPostUpdateManyWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface PriceUpdateManyInput {
  create?: PriceCreateInput[] | PriceCreateInput;
  update?:
    | PriceUpdateWithWhereUniqueNestedInput[]
    | PriceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PriceUpsertWithWhereUniqueNestedInput[]
    | PriceUpsertWithWhereUniqueNestedInput;
  delete?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
  connect?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
  set?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
  disconnect?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
  deleteMany?: PriceScalarWhereInput[] | PriceScalarWhereInput;
  updateMany?:
    | PriceUpdateManyWithWhereNestedInput[]
    | PriceUpdateManyWithWhereNestedInput;
}

export interface PriceUpdateWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput;
  data: PriceUpdateDataInput;
}

export interface PriceUpdateDataInput {
  currencyType?: CurrencyType;
  amount?: Float;
  archiveAt?: DateTimeInput;
}

export interface PriceUpsertWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput;
  update: PriceUpdateDataInput;
  create: PriceCreateInput;
}

export interface PriceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  currencyType?: CurrencyType;
  currencyType_not?: CurrencyType;
  currencyType_in?: CurrencyType[] | CurrencyType;
  currencyType_not_in?: CurrencyType[] | CurrencyType;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  archiveAt?: DateTimeInput;
  archiveAt_not?: DateTimeInput;
  archiveAt_in?: DateTimeInput[] | DateTimeInput;
  archiveAt_not_in?: DateTimeInput[] | DateTimeInput;
  archiveAt_lt?: DateTimeInput;
  archiveAt_lte?: DateTimeInput;
  archiveAt_gt?: DateTimeInput;
  archiveAt_gte?: DateTimeInput;
  AND?: PriceScalarWhereInput[] | PriceScalarWhereInput;
  OR?: PriceScalarWhereInput[] | PriceScalarWhereInput;
  NOT?: PriceScalarWhereInput[] | PriceScalarWhereInput;
}

export interface PriceUpdateManyWithWhereNestedInput {
  where: PriceScalarWhereInput;
  data: PriceUpdateManyDataInput;
}

export interface PriceUpdateManyDataInput {
  currencyType?: CurrencyType;
  amount?: Float;
  archiveAt?: DateTimeInput;
}

export interface BookEpisodeContentUpdateOneInput {
  create?: BookEpisodeContentCreateInput;
  update?: BookEpisodeContentUpdateDataInput;
  upsert?: BookEpisodeContentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BookEpisodeContentWhereUniqueInput;
}

export interface BookEpisodeContentUpdateDataInput {
  title?: String;
  draft?: Json;
}

export interface BookEpisodeContentUpsertNestedInput {
  update: BookEpisodeContentUpdateDataInput;
  create: BookEpisodeContentCreateInput;
}

export interface BookEpisodeContentUpdateManyInput {
  create?: BookEpisodeContentCreateInput[] | BookEpisodeContentCreateInput;
  update?:
    | BookEpisodeContentUpdateWithWhereUniqueNestedInput[]
    | BookEpisodeContentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | BookEpisodeContentUpsertWithWhereUniqueNestedInput[]
    | BookEpisodeContentUpsertWithWhereUniqueNestedInput;
  delete?:
    | BookEpisodeContentWhereUniqueInput[]
    | BookEpisodeContentWhereUniqueInput;
  connect?:
    | BookEpisodeContentWhereUniqueInput[]
    | BookEpisodeContentWhereUniqueInput;
  set?:
    | BookEpisodeContentWhereUniqueInput[]
    | BookEpisodeContentWhereUniqueInput;
  disconnect?:
    | BookEpisodeContentWhereUniqueInput[]
    | BookEpisodeContentWhereUniqueInput;
  deleteMany?:
    | BookEpisodeContentScalarWhereInput[]
    | BookEpisodeContentScalarWhereInput;
  updateMany?:
    | BookEpisodeContentUpdateManyWithWhereNestedInput[]
    | BookEpisodeContentUpdateManyWithWhereNestedInput;
}

export interface BookEpisodeContentUpdateWithWhereUniqueNestedInput {
  where: BookEpisodeContentWhereUniqueInput;
  data: BookEpisodeContentUpdateDataInput;
}

export interface BookEpisodeContentUpsertWithWhereUniqueNestedInput {
  where: BookEpisodeContentWhereUniqueInput;
  update: BookEpisodeContentUpdateDataInput;
  create: BookEpisodeContentCreateInput;
}

export interface BookEpisodeContentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?:
    | BookEpisodeContentScalarWhereInput[]
    | BookEpisodeContentScalarWhereInput;
  OR?:
    | BookEpisodeContentScalarWhereInput[]
    | BookEpisodeContentScalarWhereInput;
  NOT?:
    | BookEpisodeContentScalarWhereInput[]
    | BookEpisodeContentScalarWhereInput;
}

export interface BookEpisodeContentUpdateManyWithWhereNestedInput {
  where: BookEpisodeContentScalarWhereInput;
  data: BookEpisodeContentUpdateManyDataInput;
}

export interface BookEpisodeContentUpdateManyDataInput {
  title?: String;
  draft?: Json;
}

export interface VendorUpdateOneInput {
  create?: VendorCreateInput;
  update?: VendorUpdateDataInput;
  upsert?: VendorUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VendorWhereUniqueInput;
}

export interface PageViewUpdateOneWithoutEpisodeInput {
  create?: PageViewCreateWithoutEpisodeInput;
  update?: PageViewUpdateWithoutEpisodeDataInput;
  upsert?: PageViewUpsertWithoutEpisodeInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PageViewWhereUniqueInput;
}

export interface PageViewUpdateWithoutEpisodeDataInput {
  count?: Int;
}

export interface PageViewUpsertWithoutEpisodeInput {
  update: PageViewUpdateWithoutEpisodeDataInput;
  create: PageViewCreateWithoutEpisodeInput;
}

export interface BookEpisodeReviewPostUpdateManyWithoutEpisodeInput {
  create?:
    | BookEpisodeReviewPostCreateWithoutEpisodeInput[]
    | BookEpisodeReviewPostCreateWithoutEpisodeInput;
  delete?:
    | BookEpisodeReviewPostWhereUniqueInput[]
    | BookEpisodeReviewPostWhereUniqueInput;
  connect?:
    | BookEpisodeReviewPostWhereUniqueInput[]
    | BookEpisodeReviewPostWhereUniqueInput;
  set?:
    | BookEpisodeReviewPostWhereUniqueInput[]
    | BookEpisodeReviewPostWhereUniqueInput;
  disconnect?:
    | BookEpisodeReviewPostWhereUniqueInput[]
    | BookEpisodeReviewPostWhereUniqueInput;
  update?:
    | BookEpisodeReviewPostUpdateWithWhereUniqueWithoutEpisodeInput[]
    | BookEpisodeReviewPostUpdateWithWhereUniqueWithoutEpisodeInput;
  upsert?:
    | BookEpisodeReviewPostUpsertWithWhereUniqueWithoutEpisodeInput[]
    | BookEpisodeReviewPostUpsertWithWhereUniqueWithoutEpisodeInput;
  deleteMany?:
    | BookEpisodeReviewPostScalarWhereInput[]
    | BookEpisodeReviewPostScalarWhereInput;
  updateMany?:
    | BookEpisodeReviewPostUpdateManyWithWhereNestedInput[]
    | BookEpisodeReviewPostUpdateManyWithWhereNestedInput;
}

export interface BookEpisodeReviewPostUpdateWithWhereUniqueWithoutEpisodeInput {
  where: BookEpisodeReviewPostWhereUniqueInput;
  data: BookEpisodeReviewPostUpdateWithoutEpisodeDataInput;
}

export interface BookEpisodeReviewPostUpdateWithoutEpisodeDataInput {
  rating?: Int;
  post?: PostUpdateOneRequiredInput;
}

export interface PostUpdateOneRequiredInput {
  create?: PostCreateInput;
  update?: PostUpdateDataInput;
  upsert?: PostUpsertNestedInput;
  connect?: PostWhereUniqueInput;
}

export interface PostUpdateDataInput {
  type?: PostType;
  user?: UserUpdateOneRequiredInput;
  message?: String;
  status?: ReviewPostStatus;
}

export interface PostUpsertNestedInput {
  update: PostUpdateDataInput;
  create: PostCreateInput;
}

export interface BookEpisodeReviewPostUpsertWithWhereUniqueWithoutEpisodeInput {
  where: BookEpisodeReviewPostWhereUniqueInput;
  update: BookEpisodeReviewPostUpdateWithoutEpisodeDataInput;
  create: BookEpisodeReviewPostCreateWithoutEpisodeInput;
}

export interface BookEpisodeReviewPostScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  rating?: Int;
  rating_not?: Int;
  rating_in?: Int[] | Int;
  rating_not_in?: Int[] | Int;
  rating_lt?: Int;
  rating_lte?: Int;
  rating_gt?: Int;
  rating_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?:
    | BookEpisodeReviewPostScalarWhereInput[]
    | BookEpisodeReviewPostScalarWhereInput;
  OR?:
    | BookEpisodeReviewPostScalarWhereInput[]
    | BookEpisodeReviewPostScalarWhereInput;
  NOT?:
    | BookEpisodeReviewPostScalarWhereInput[]
    | BookEpisodeReviewPostScalarWhereInput;
}

export interface BookEpisodeReviewPostUpdateManyWithWhereNestedInput {
  where: BookEpisodeReviewPostScalarWhereInput;
  data: BookEpisodeReviewPostUpdateManyDataInput;
}

export interface BookEpisodeReviewPostUpdateManyDataInput {
  rating?: Int;
}

export interface BookEpisodeUpsertWithWhereUniqueWithoutVolumeInput {
  where: BookEpisodeWhereUniqueInput;
  update: BookEpisodeUpdateWithoutVolumeDataInput;
  create: BookEpisodeCreateWithoutVolumeInput;
}

export interface BookEpisodeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  publishedAt?: DateTimeInput;
  publishedAt_not?: DateTimeInput;
  publishedAt_in?: DateTimeInput[] | DateTimeInput;
  publishedAt_not_in?: DateTimeInput[] | DateTimeInput;
  publishedAt_lt?: DateTimeInput;
  publishedAt_lte?: DateTimeInput;
  publishedAt_gt?: DateTimeInput;
  publishedAt_gte?: DateTimeInput;
  isUnlisted?: Boolean;
  isUnlisted_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  metaTitle?: String;
  metaTitle_not?: String;
  metaTitle_in?: String[] | String;
  metaTitle_not_in?: String[] | String;
  metaTitle_lt?: String;
  metaTitle_lte?: String;
  metaTitle_gt?: String;
  metaTitle_gte?: String;
  metaTitle_contains?: String;
  metaTitle_not_contains?: String;
  metaTitle_starts_with?: String;
  metaTitle_not_starts_with?: String;
  metaTitle_ends_with?: String;
  metaTitle_not_ends_with?: String;
  metaDescription?: String;
  metaDescription_not?: String;
  metaDescription_in?: String[] | String;
  metaDescription_not_in?: String[] | String;
  metaDescription_lt?: String;
  metaDescription_lte?: String;
  metaDescription_gt?: String;
  metaDescription_gte?: String;
  metaDescription_contains?: String;
  metaDescription_not_contains?: String;
  metaDescription_starts_with?: String;
  metaDescription_not_starts_with?: String;
  metaDescription_ends_with?: String;
  metaDescription_not_ends_with?: String;
  metaKeyword?: String;
  metaKeyword_not?: String;
  metaKeyword_in?: String[] | String;
  metaKeyword_not_in?: String[] | String;
  metaKeyword_lt?: String;
  metaKeyword_lte?: String;
  metaKeyword_gt?: String;
  metaKeyword_gte?: String;
  metaKeyword_contains?: String;
  metaKeyword_not_contains?: String;
  metaKeyword_starts_with?: String;
  metaKeyword_not_starts_with?: String;
  metaKeyword_ends_with?: String;
  metaKeyword_not_ends_with?: String;
  AND?: BookEpisodeScalarWhereInput[] | BookEpisodeScalarWhereInput;
  OR?: BookEpisodeScalarWhereInput[] | BookEpisodeScalarWhereInput;
  NOT?: BookEpisodeScalarWhereInput[] | BookEpisodeScalarWhereInput;
}

export interface BookEpisodeUpdateManyWithWhereNestedInput {
  where: BookEpisodeScalarWhereInput;
  data: BookEpisodeUpdateManyDataInput;
}

export interface BookEpisodeUpdateManyDataInput {
  slug?: String;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookVolumeUpsertWithWhereUniqueWithoutBookInput {
  where: BookVolumeWhereUniqueInput;
  update: BookVolumeUpdateWithoutBookDataInput;
  create: BookVolumeCreateWithoutBookInput;
}

export interface BookVolumeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BookVolumeScalarWhereInput[] | BookVolumeScalarWhereInput;
  OR?: BookVolumeScalarWhereInput[] | BookVolumeScalarWhereInput;
  NOT?: BookVolumeScalarWhereInput[] | BookVolumeScalarWhereInput;
}

export interface BookVolumeUpdateManyWithWhereNestedInput {
  where: BookVolumeScalarWhereInput;
  data: BookVolumeUpdateManyDataInput;
}

export interface BookVolumeUpdateManyDataInput {
  slug?: String;
  title?: String;
  isPublished?: Boolean;
}

export interface BookUpsertNestedInput {
  update: BookUpdateDataInput;
  create: BookCreateInput;
}

export interface RevenueSharingUpsertNestedInput {
  update: RevenueSharingUpdateDataInput;
  create: RevenueSharingCreateInput;
}

export interface VendorRevenueUpsertWithWhereUniqueWithoutTransactionInput {
  where: VendorRevenueWhereUniqueInput;
  update: VendorRevenueUpdateWithoutTransactionDataInput;
  create: VendorRevenueCreateWithoutTransactionInput;
}

export interface VendorRevenueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  weight?: Int;
  weight_not?: Int;
  weight_in?: Int[] | Int;
  weight_not_in?: Int[] | Int;
  weight_lt?: Int;
  weight_lte?: Int;
  weight_gt?: Int;
  weight_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: VendorRevenueScalarWhereInput[] | VendorRevenueScalarWhereInput;
  OR?: VendorRevenueScalarWhereInput[] | VendorRevenueScalarWhereInput;
  NOT?: VendorRevenueScalarWhereInput[] | VendorRevenueScalarWhereInput;
}

export interface VendorRevenueUpdateManyWithWhereNestedInput {
  where: VendorRevenueScalarWhereInput;
  data: VendorRevenueUpdateManyDataInput;
}

export interface VendorRevenueUpdateManyDataInput {
  weight?: Int;
}

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface TransactionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  currencyType?: CurrencyType;
  currencyType_not?: CurrencyType;
  currencyType_in?: CurrencyType[] | CurrencyType;
  currencyType_not_in?: CurrencyType[] | CurrencyType;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  OR?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  NOT?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface TransactionUpdateManyDataInput {
  type?: TransactionType;
  currencyType?: CurrencyType;
  amount?: Float;
}

export interface ExchangeTransactionUpdateManyWithoutUserInput {
  create?:
    | ExchangeTransactionCreateWithoutUserInput[]
    | ExchangeTransactionCreateWithoutUserInput;
  delete?:
    | ExchangeTransactionWhereUniqueInput[]
    | ExchangeTransactionWhereUniqueInput;
  connect?:
    | ExchangeTransactionWhereUniqueInput[]
    | ExchangeTransactionWhereUniqueInput;
  set?:
    | ExchangeTransactionWhereUniqueInput[]
    | ExchangeTransactionWhereUniqueInput;
  disconnect?:
    | ExchangeTransactionWhereUniqueInput[]
    | ExchangeTransactionWhereUniqueInput;
  update?:
    | ExchangeTransactionUpdateWithWhereUniqueWithoutUserInput[]
    | ExchangeTransactionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ExchangeTransactionUpsertWithWhereUniqueWithoutUserInput[]
    | ExchangeTransactionUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?:
    | ExchangeTransactionScalarWhereInput[]
    | ExchangeTransactionScalarWhereInput;
  updateMany?:
    | ExchangeTransactionUpdateManyWithWhereNestedInput[]
    | ExchangeTransactionUpdateManyWithWhereNestedInput;
}

export interface ExchangeTransactionUpdateWithWhereUniqueWithoutUserInput {
  where: ExchangeTransactionWhereUniqueInput;
  data: ExchangeTransactionUpdateWithoutUserDataInput;
}

export interface ExchangeTransactionUpdateWithoutUserDataInput {
  orderID?: String;
  tier?: ExchangeTierUpdateOneRequiredInput;
  status?: ExchangeTransactionStatusHistoryUpdateManyInput;
  currentStatus?: ExchangeTransactionType;
  payload?: Json;
  refCode?: String;
}

export interface ExchangeTransactionUpsertWithWhereUniqueWithoutUserInput {
  where: ExchangeTransactionWhereUniqueInput;
  update: ExchangeTransactionUpdateWithoutUserDataInput;
  create: ExchangeTransactionCreateWithoutUserInput;
}

export interface ExchangeTransactionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  orderID?: String;
  orderID_not?: String;
  orderID_in?: String[] | String;
  orderID_not_in?: String[] | String;
  orderID_lt?: String;
  orderID_lte?: String;
  orderID_gt?: String;
  orderID_gte?: String;
  orderID_contains?: String;
  orderID_not_contains?: String;
  orderID_starts_with?: String;
  orderID_not_starts_with?: String;
  orderID_ends_with?: String;
  orderID_not_ends_with?: String;
  currentStatus?: ExchangeTransactionType;
  currentStatus_not?: ExchangeTransactionType;
  currentStatus_in?: ExchangeTransactionType[] | ExchangeTransactionType;
  currentStatus_not_in?: ExchangeTransactionType[] | ExchangeTransactionType;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  refCode?: String;
  refCode_not?: String;
  refCode_in?: String[] | String;
  refCode_not_in?: String[] | String;
  refCode_lt?: String;
  refCode_lte?: String;
  refCode_gt?: String;
  refCode_gte?: String;
  refCode_contains?: String;
  refCode_not_contains?: String;
  refCode_starts_with?: String;
  refCode_not_starts_with?: String;
  refCode_ends_with?: String;
  refCode_not_ends_with?: String;
  AND?:
    | ExchangeTransactionScalarWhereInput[]
    | ExchangeTransactionScalarWhereInput;
  OR?:
    | ExchangeTransactionScalarWhereInput[]
    | ExchangeTransactionScalarWhereInput;
  NOT?:
    | ExchangeTransactionScalarWhereInput[]
    | ExchangeTransactionScalarWhereInput;
}

export interface ExchangeTransactionUpdateManyWithWhereNestedInput {
  where: ExchangeTransactionScalarWhereInput;
  data: ExchangeTransactionUpdateManyDataInput;
}

export interface ExchangeTransactionUpdateManyDataInput {
  orderID?: String;
  currentStatus?: ExchangeTransactionType;
  payload?: Json;
  refCode?: String;
}

export interface BehaviorUpdateManyMutationInput {
  ip?: String;
  action?: String;
  payload?: Json;
}

export interface BookUpdateInput {
  slug?: String;
  name?: String;
  introduction?: Json;
  synopsis?: String;
  thumbnail?: ImageUpdateOneInput;
  copyrightHolder?: CopyrightHolderUpdateOneInput;
  authors?: AuthorUpdateManyInput;
  mainCategory?: CategoryUpdateOneInput;
  secondaryCategory?: CategoryUpdateOneInput;
  translators?: TranslatorUpdateManyInput;
  volumes?: BookVolumeUpdateManyWithoutBookInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  publishTimeline?: PublishTimelineUpdateOneInput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookUpdateManyMutationInput {
  slug?: String;
  name?: String;
  introduction?: Json;
  synopsis?: String;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodeCreateInput {
  slug?: String;
  authors?: AuthorCreateManyInput;
  translators?: TranslatorCreateManyInput;
  prices?: PriceCreateManyInput;
  priceHistory?: PriceCreateManyInput;
  publishContent?: BookEpisodeContentCreateOneInput;
  draftContent?: BookEpisodeContentCreateOneInput;
  revisionContents?: BookEpisodeContentCreateManyInput;
  volume: BookVolumeCreateOneWithoutEpisodesInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorCreateOneInput;
  publishTimeline?: PublishTimelineCreateOneInput;
  isUnlisted?: Boolean;
  pageView?: PageViewCreateOneWithoutEpisodeInput;
  reviews?: BookEpisodeReviewPostCreateManyWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookVolumeCreateOneWithoutEpisodesInput {
  create?: BookVolumeCreateWithoutEpisodesInput;
  connect?: BookVolumeWhereUniqueInput;
}

export interface BookVolumeCreateWithoutEpisodesInput {
  slug?: String;
  title: String;
  book: BookCreateOneWithoutVolumesInput;
  isPublished?: Boolean;
}

export interface BookCreateOneWithoutVolumesInput {
  create?: BookCreateWithoutVolumesInput;
  connect?: BookWhereUniqueInput;
}

export interface BookCreateWithoutVolumesInput {
  slug?: String;
  name: String;
  introduction: Json;
  synopsis?: String;
  thumbnail?: ImageCreateOneInput;
  copyrightHolder?: CopyrightHolderCreateOneInput;
  authors?: AuthorCreateManyInput;
  mainCategory?: CategoryCreateOneInput;
  secondaryCategory?: CategoryCreateOneInput;
  translators?: TranslatorCreateManyInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  publishTimeline?: PublishTimelineCreateOneInput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodeUpdateInput {
  slug?: String;
  authors?: AuthorUpdateManyInput;
  translators?: TranslatorUpdateManyInput;
  prices?: PriceUpdateManyInput;
  priceHistory?: PriceUpdateManyInput;
  publishContent?: BookEpisodeContentUpdateOneInput;
  draftContent?: BookEpisodeContentUpdateOneInput;
  revisionContents?: BookEpisodeContentUpdateManyInput;
  volume?: BookVolumeUpdateOneRequiredWithoutEpisodesInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorUpdateOneInput;
  publishTimeline?: PublishTimelineUpdateOneInput;
  isUnlisted?: Boolean;
  pageView?: PageViewUpdateOneWithoutEpisodeInput;
  reviews?: BookEpisodeReviewPostUpdateManyWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookVolumeUpdateOneRequiredWithoutEpisodesInput {
  create?: BookVolumeCreateWithoutEpisodesInput;
  update?: BookVolumeUpdateWithoutEpisodesDataInput;
  upsert?: BookVolumeUpsertWithoutEpisodesInput;
  connect?: BookVolumeWhereUniqueInput;
}

export interface BookVolumeUpdateWithoutEpisodesDataInput {
  slug?: String;
  title?: String;
  book?: BookUpdateOneRequiredWithoutVolumesInput;
  isPublished?: Boolean;
}

export interface BookUpdateOneRequiredWithoutVolumesInput {
  create?: BookCreateWithoutVolumesInput;
  update?: BookUpdateWithoutVolumesDataInput;
  upsert?: BookUpsertWithoutVolumesInput;
  connect?: BookWhereUniqueInput;
}

export interface BookUpdateWithoutVolumesDataInput {
  slug?: String;
  name?: String;
  introduction?: Json;
  synopsis?: String;
  thumbnail?: ImageUpdateOneInput;
  copyrightHolder?: CopyrightHolderUpdateOneInput;
  authors?: AuthorUpdateManyInput;
  mainCategory?: CategoryUpdateOneInput;
  secondaryCategory?: CategoryUpdateOneInput;
  translators?: TranslatorUpdateManyInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  publishTimeline?: PublishTimelineUpdateOneInput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookUpsertWithoutVolumesInput {
  update: BookUpdateWithoutVolumesDataInput;
  create: BookCreateWithoutVolumesInput;
}

export interface BookVolumeUpsertWithoutEpisodesInput {
  update: BookVolumeUpdateWithoutEpisodesDataInput;
  create: BookVolumeCreateWithoutEpisodesInput;
}

export interface BookEpisodeUpdateManyMutationInput {
  slug?: String;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodeContentUpdateInput {
  title?: String;
  draft?: Json;
}

export interface BookEpisodeContentUpdateManyMutationInput {
  title?: String;
  draft?: Json;
}

export interface BookEpisodeRecentReadCreateInput {
  user: UserCreateOneInput;
  episode: BookEpisodeCreateOneInput;
  offsetKey: String;
  offsetRatio: Float;
}

export interface BookEpisodeCreateOneInput {
  create?: BookEpisodeCreateInput;
  connect?: BookEpisodeWhereUniqueInput;
}

export interface BookEpisodeRecentReadUpdateInput {
  user?: UserUpdateOneRequiredInput;
  episode?: BookEpisodeUpdateOneRequiredInput;
  offsetKey?: String;
  offsetRatio?: Float;
}

export interface BookEpisodeUpdateOneRequiredInput {
  create?: BookEpisodeCreateInput;
  update?: BookEpisodeUpdateDataInput;
  upsert?: BookEpisodeUpsertNestedInput;
  connect?: BookEpisodeWhereUniqueInput;
}

export interface BookEpisodeUpdateDataInput {
  slug?: String;
  authors?: AuthorUpdateManyInput;
  translators?: TranslatorUpdateManyInput;
  prices?: PriceUpdateManyInput;
  priceHistory?: PriceUpdateManyInput;
  publishContent?: BookEpisodeContentUpdateOneInput;
  draftContent?: BookEpisodeContentUpdateOneInput;
  revisionContents?: BookEpisodeContentUpdateManyInput;
  volume?: BookVolumeUpdateOneRequiredWithoutEpisodesInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorUpdateOneInput;
  publishTimeline?: PublishTimelineUpdateOneInput;
  isUnlisted?: Boolean;
  pageView?: PageViewUpdateOneWithoutEpisodeInput;
  reviews?: BookEpisodeReviewPostUpdateManyWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodeUpsertNestedInput {
  update: BookEpisodeUpdateDataInput;
  create: BookEpisodeCreateInput;
}

export interface BookEpisodeRecentReadUpdateManyMutationInput {
  offsetKey?: String;
  offsetRatio?: Float;
}

export interface BookEpisodeReviewPostCreateInput {
  episode: BookEpisodeCreateOneWithoutReviewsInput;
  rating: Int;
  post: PostCreateOneInput;
}

export interface BookEpisodeCreateOneWithoutReviewsInput {
  create?: BookEpisodeCreateWithoutReviewsInput;
  connect?: BookEpisodeWhereUniqueInput;
}

export interface BookEpisodeCreateWithoutReviewsInput {
  slug?: String;
  authors?: AuthorCreateManyInput;
  translators?: TranslatorCreateManyInput;
  prices?: PriceCreateManyInput;
  priceHistory?: PriceCreateManyInput;
  publishContent?: BookEpisodeContentCreateOneInput;
  draftContent?: BookEpisodeContentCreateOneInput;
  revisionContents?: BookEpisodeContentCreateManyInput;
  volume: BookVolumeCreateOneWithoutEpisodesInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorCreateOneInput;
  publishTimeline?: PublishTimelineCreateOneInput;
  isUnlisted?: Boolean;
  pageView?: PageViewCreateOneWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodeReviewPostUpdateInput {
  episode?: BookEpisodeUpdateOneRequiredWithoutReviewsInput;
  rating?: Int;
  post?: PostUpdateOneRequiredInput;
}

export interface BookEpisodeUpdateOneRequiredWithoutReviewsInput {
  create?: BookEpisodeCreateWithoutReviewsInput;
  update?: BookEpisodeUpdateWithoutReviewsDataInput;
  upsert?: BookEpisodeUpsertWithoutReviewsInput;
  connect?: BookEpisodeWhereUniqueInput;
}

export interface BookEpisodeUpdateWithoutReviewsDataInput {
  slug?: String;
  authors?: AuthorUpdateManyInput;
  translators?: TranslatorUpdateManyInput;
  prices?: PriceUpdateManyInput;
  priceHistory?: PriceUpdateManyInput;
  publishContent?: BookEpisodeContentUpdateOneInput;
  draftContent?: BookEpisodeContentUpdateOneInput;
  revisionContents?: BookEpisodeContentUpdateManyInput;
  volume?: BookVolumeUpdateOneRequiredWithoutEpisodesInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorUpdateOneInput;
  publishTimeline?: PublishTimelineUpdateOneInput;
  isUnlisted?: Boolean;
  pageView?: PageViewUpdateOneWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodeUpsertWithoutReviewsInput {
  update: BookEpisodeUpdateWithoutReviewsDataInput;
  create: BookEpisodeCreateWithoutReviewsInput;
}

export interface BookEpisodeReviewPostUpdateManyMutationInput {
  rating?: Int;
}

export interface BookRecommendedCreateInput {
  book: BookCreateOneInput;
  weight: Int;
  publishTimeline?: PublishTimelineCreateOneInput;
}

export interface BookRecommendedUpdateInput {
  book?: BookUpdateOneRequiredInput;
  weight?: Int;
  publishTimeline?: PublishTimelineUpdateOneInput;
}

export interface BookRecommendedUpdateManyMutationInput {
  weight?: Int;
}

export interface BookVolumeCreateInput {
  slug?: String;
  title: String;
  book: BookCreateOneWithoutVolumesInput;
  episodes?: BookEpisodeCreateManyWithoutVolumeInput;
  isPublished?: Boolean;
}

export interface BookVolumeUpdateInput {
  slug?: String;
  title?: String;
  book?: BookUpdateOneRequiredWithoutVolumesInput;
  episodes?: BookEpisodeUpdateManyWithoutVolumeInput;
  isPublished?: Boolean;
}

export interface BookVolumeUpdateManyMutationInput {
  slug?: String;
  title?: String;
  isPublished?: Boolean;
}

export interface CategoryUpdateInput {
  name?: String;
}

export interface CategoryUpdateManyMutationInput {
  name?: String;
}

export interface CopyrightHolderUpdateInput {
  name?: String;
  vendor?: VendorUpdateOneWithoutCopyrightHoldersInput;
}

export interface CopyrightHolderUpdateManyMutationInput {
  name?: String;
}

export interface DashbardDataCacheCreateInput {
  queryName: String;
  arguments?: String;
  result: String;
}

export interface DashbardDataCacheUpdateManyMutationInput {
  queryName?: String;
  arguments?: String;
  result?: String;
}

export interface DocumentUpdateInput {
  file?: FileUpdateOneInput;
  image?: ImageUpdateOneInput;
  type?: DocumentType;
}

export interface DocumentUpdateManyMutationInput {
  type?: DocumentType;
}

export interface ExchangeTierUpdateInput {
  type?: ExchangeType;
  name?: String;
  currencyType?: CurrencyType;
  income?: Float;
  outcome?: Float;
  promotions?: PromotionUpdateManyInput;
  isDefault?: Boolean;
  publishTimeline?: PublishTimelineUpdateOneInput;
}

export interface ExchangeTierUpdateManyMutationInput {
  type?: ExchangeType;
  name?: String;
  currencyType?: CurrencyType;
  income?: Float;
  outcome?: Float;
  isDefault?: Boolean;
}

export interface ExchangeTransactionUpdateInput {
  orderID?: String;
  user?: UserUpdateOneRequiredWithoutExchangeTransactionsInput;
  tier?: ExchangeTierUpdateOneRequiredInput;
  status?: ExchangeTransactionStatusHistoryUpdateManyInput;
  currentStatus?: ExchangeTransactionType;
  payload?: Json;
  refCode?: String;
}

export interface ExchangeTransactionUpdateManyMutationInput {
  orderID?: String;
  currentStatus?: ExchangeTransactionType;
  payload?: Json;
  refCode?: String;
}

export interface ExchangeTransactionStatusHistoryUpdateInput {
  status?: ExchangeTransactionType;
  message?: String;
}

export interface ExchangeTransactionStatusHistoryUpdateManyMutationInput {
  status?: ExchangeTransactionType;
  message?: String;
}

export interface FileUpdateInput {
  path?: String;
  fileName?: String;
}

export interface FileUpdateManyMutationInput {
  path?: String;
  fileName?: String;
}

export interface HistoryCreateInput {
  payload?: Json;
  mutationName: String;
  updateBy: String;
}

export interface HistoryUpdateInput {
  payload?: Json;
  mutationName?: String;
  updateBy?: String;
}

export interface HistoryUpdateManyMutationInput {
  payload?: Json;
  mutationName?: String;
  updateBy?: String;
}

export interface ImageUpdateInput {
  small?: String;
  medium?: String;
  large?: String;
  fileName?: String;
}

export interface ImageUpdateManyMutationInput {
  small?: String;
  medium?: String;
  large?: String;
  fileName?: String;
}

export interface ItemCreateInput {
  user: UserCreateOneInput;
  asset?: ItemAssetCreateOneWithoutItemInput;
  amount: Int;
  expireAt?: DateTimeInput;
  transaction?: TransactionCreateOneWithoutItemsInput;
}

export interface TransactionCreateOneWithoutItemsInput {
  create?: TransactionCreateWithoutItemsInput;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionCreateWithoutItemsInput {
  user: UserCreateOneWithoutTransactionsInput;
  type: TransactionType;
  currencyType: CurrencyType;
  amount: Float;
  exchangeTransaction?: ExchangeTransactionCreateOneInput;
  vendorRevenue?: VendorRevenueCreateManyWithoutTransactionInput;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutTransactionsInput {
  userID: ID_Input;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender?: Gender;
  defaultProfilePicture?: String;
  exchangeTransactions?: ExchangeTransactionCreateManyWithoutUserInput;
}

export interface ItemUpdateInput {
  user?: UserUpdateOneRequiredInput;
  asset?: ItemAssetUpdateOneWithoutItemInput;
  amount?: Int;
  expireAt?: DateTimeInput;
  transaction?: TransactionUpdateOneWithoutItemsInput;
}

export interface TransactionUpdateOneWithoutItemsInput {
  create?: TransactionCreateWithoutItemsInput;
  update?: TransactionUpdateWithoutItemsDataInput;
  upsert?: TransactionUpsertWithoutItemsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionUpdateWithoutItemsDataInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  type?: TransactionType;
  currencyType?: CurrencyType;
  amount?: Float;
  exchangeTransaction?: ExchangeTransactionUpdateOneInput;
  vendorRevenue?: VendorRevenueUpdateManyWithoutTransactionInput;
}

export interface UserUpdateOneRequiredWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  update?: UserUpdateWithoutTransactionsDataInput;
  upsert?: UserUpsertWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutTransactionsDataInput {
  userID?: ID_Input;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender?: Gender;
  defaultProfilePicture?: String;
  exchangeTransactions?: ExchangeTransactionUpdateManyWithoutUserInput;
}

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export interface TransactionUpsertWithoutItemsInput {
  update: TransactionUpdateWithoutItemsDataInput;
  create: TransactionCreateWithoutItemsInput;
}

export interface ItemUpdateManyMutationInput {
  amount?: Int;
  expireAt?: DateTimeInput;
}

export interface ItemAssetCreateInput {
  assetType: String;
  assetID: ID_Input;
  item?: ItemCreateOneWithoutAssetInput;
}

export interface ItemCreateOneWithoutAssetInput {
  create?: ItemCreateWithoutAssetInput;
  connect?: ItemWhereUniqueInput;
}

export interface ItemCreateWithoutAssetInput {
  user: UserCreateOneInput;
  amount: Int;
  expireAt?: DateTimeInput;
  transaction?: TransactionCreateOneWithoutItemsInput;
}

export interface ItemAssetUpdateInput {
  assetType?: String;
  assetID?: ID_Input;
  item?: ItemUpdateOneWithoutAssetInput;
}

export interface ItemUpdateOneWithoutAssetInput {
  create?: ItemCreateWithoutAssetInput;
  update?: ItemUpdateWithoutAssetDataInput;
  upsert?: ItemUpsertWithoutAssetInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ItemWhereUniqueInput;
}

export interface ItemUpdateWithoutAssetDataInput {
  user?: UserUpdateOneRequiredInput;
  amount?: Int;
  expireAt?: DateTimeInput;
  transaction?: TransactionUpdateOneWithoutItemsInput;
}

export interface ItemUpsertWithoutAssetInput {
  update: ItemUpdateWithoutAssetDataInput;
  create: ItemCreateWithoutAssetInput;
}

export interface ItemAssetUpdateManyMutationInput {
  assetType?: String;
  assetID?: ID_Input;
}

export interface MigrationCreateInput {
  num: Int;
}

export interface MigrationUpdateInput {
  num?: Int;
}

export interface MigrationUpdateManyMutationInput {
  num?: Int;
}

export interface PageViewCreateInput {
  episode: BookEpisodeCreateOneWithoutPageViewInput;
  count?: Int;
}

export interface BookEpisodeCreateOneWithoutPageViewInput {
  create?: BookEpisodeCreateWithoutPageViewInput;
  connect?: BookEpisodeWhereUniqueInput;
}

export interface BookEpisodeCreateWithoutPageViewInput {
  slug?: String;
  authors?: AuthorCreateManyInput;
  translators?: TranslatorCreateManyInput;
  prices?: PriceCreateManyInput;
  priceHistory?: PriceCreateManyInput;
  publishContent?: BookEpisodeContentCreateOneInput;
  draftContent?: BookEpisodeContentCreateOneInput;
  revisionContents?: BookEpisodeContentCreateManyInput;
  volume: BookVolumeCreateOneWithoutEpisodesInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorCreateOneInput;
  publishTimeline?: PublishTimelineCreateOneInput;
  isUnlisted?: Boolean;
  reviews?: BookEpisodeReviewPostCreateManyWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface PageViewUpdateInput {
  episode?: BookEpisodeUpdateOneRequiredWithoutPageViewInput;
  count?: Int;
}

export interface BookEpisodeUpdateOneRequiredWithoutPageViewInput {
  create?: BookEpisodeCreateWithoutPageViewInput;
  update?: BookEpisodeUpdateWithoutPageViewDataInput;
  upsert?: BookEpisodeUpsertWithoutPageViewInput;
  connect?: BookEpisodeWhereUniqueInput;
}

export interface BookEpisodeUpdateWithoutPageViewDataInput {
  slug?: String;
  authors?: AuthorUpdateManyInput;
  translators?: TranslatorUpdateManyInput;
  prices?: PriceUpdateManyInput;
  priceHistory?: PriceUpdateManyInput;
  publishContent?: BookEpisodeContentUpdateOneInput;
  draftContent?: BookEpisodeContentUpdateOneInput;
  revisionContents?: BookEpisodeContentUpdateManyInput;
  volume?: BookVolumeUpdateOneRequiredWithoutEpisodesInput;
  isPublished?: Boolean;
  publishedAt?: DateTimeInput;
  vendor?: VendorUpdateOneInput;
  publishTimeline?: PublishTimelineUpdateOneInput;
  isUnlisted?: Boolean;
  reviews?: BookEpisodeReviewPostUpdateManyWithoutEpisodeInput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodeUpsertWithoutPageViewInput {
  update: BookEpisodeUpdateWithoutPageViewDataInput;
  create: BookEpisodeCreateWithoutPageViewInput;
}

export interface PageViewUpdateManyMutationInput {
  count?: Int;
}

export interface PostUpdateInput {
  type?: PostType;
  user?: UserUpdateOneRequiredInput;
  message?: String;
  status?: ReviewPostStatus;
}

export interface PostUpdateManyMutationInput {
  type?: PostType;
  message?: String;
  status?: ReviewPostStatus;
}

export interface PriceUpdateInput {
  currencyType?: CurrencyType;
  amount?: Float;
  archiveAt?: DateTimeInput;
}

export interface PriceUpdateManyMutationInput {
  currencyType?: CurrencyType;
  amount?: Float;
  archiveAt?: DateTimeInput;
}

export interface PromotionUpdateInput {
  name?: String;
  unit?: PromotionUnit;
  type?: PromotionType;
  amount?: Float;
}

export interface PromotionUpdateManyMutationInput {
  name?: String;
  unit?: PromotionUnit;
  type?: PromotionType;
  amount?: Float;
}

export interface PublishTimelineUpdateManyMutationInput {
  startAt?: DateTimeInput;
  endAt?: DateTimeInput;
}

export interface RemoteConfigCreateInput {
  name?: String;
  landing?: Boolean;
}

export interface RemoteConfigUpdateInput {
  name?: String;
  landing?: Boolean;
}

export interface RemoteConfigUpdateManyMutationInput {
  name?: String;
  landing?: Boolean;
}

export interface RevenueSharingUpdateInput {
  vendor?: VendorUpdateOneRequiredInput;
  book?: BookUpdateOneRequiredInput;
  commission?: Float;
  status?: RevenueSharingStatus;
}

export interface RevenueSharingUpdateManyMutationInput {
  commission?: Float;
  status?: RevenueSharingStatus;
}

export interface ShelfCreateInput {
  type: ShelfType;
  user: UserCreateOneInput;
  book?: BookCreateOneInput;
}

export interface ShelfUpdateInput {
  type?: ShelfType;
  user?: UserUpdateOneRequiredInput;
  book?: BookUpdateOneInput;
}

export interface BookUpdateOneInput {
  create?: BookCreateInput;
  update?: BookUpdateDataInput;
  upsert?: BookUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BookWhereUniqueInput;
}

export interface ShelfUpdateManyMutationInput {
  type?: ShelfType;
}

export interface SystemConfigCreateInput {
  name: String;
  value?: String;
}

export interface SystemConfigUpdateInput {
  name?: String;
  value?: String;
}

export interface SystemConfigUpdateManyMutationInput {
  name?: String;
  value?: String;
}

export interface TransactionCreateInput {
  user: UserCreateOneWithoutTransactionsInput;
  type: TransactionType;
  currencyType: CurrencyType;
  amount: Float;
  exchangeTransaction?: ExchangeTransactionCreateOneInput;
  items?: ItemCreateManyWithoutTransactionInput;
  vendorRevenue?: VendorRevenueCreateManyWithoutTransactionInput;
}

export interface TransactionUpdateInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  type?: TransactionType;
  currencyType?: CurrencyType;
  amount?: Float;
  exchangeTransaction?: ExchangeTransactionUpdateOneInput;
  items?: ItemUpdateManyWithoutTransactionInput;
  vendorRevenue?: VendorRevenueUpdateManyWithoutTransactionInput;
}

export interface TransactionUpdateManyMutationInput {
  type?: TransactionType;
  currencyType?: CurrencyType;
  amount?: Float;
}

export interface TranslatorUpdateInput {
  name?: String;
  vendor?: VendorUpdateOneWithoutTranslatorsInput;
}

export interface TranslatorUpdateManyMutationInput {
  name?: String;
}

export interface UserUpdateInput {
  userID?: ID_Input;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender?: Gender;
  defaultProfilePicture?: String;
  transactions?: TransactionUpdateManyWithoutUserInput;
  exchangeTransactions?: ExchangeTransactionUpdateManyWithoutUserInput;
}

export interface UserUpdateManyMutationInput {
  userID?: ID_Input;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender?: Gender;
  defaultProfilePicture?: String;
}

export interface UserAdminCreateInput {
  email?: String;
  hashedPassword?: String;
  roles?: UserAdminRoleCreateManyInput;
}

export interface UserAdminRoleCreateManyInput {
  create?: UserAdminRoleCreateInput[] | UserAdminRoleCreateInput;
  connect?: UserAdminRoleWhereUniqueInput[] | UserAdminRoleWhereUniqueInput;
}

export interface UserAdminRoleCreateInput {
  name: String;
  permissions?: UserAdminPermissionCreateManyInput;
}

export interface UserAdminPermissionCreateManyInput {
  create?: UserAdminPermissionCreateInput[] | UserAdminPermissionCreateInput;
  connect?:
    | UserAdminPermissionWhereUniqueInput[]
    | UserAdminPermissionWhereUniqueInput;
}

export interface UserAdminPermissionCreateInput {
  type: String;
  resource?: String;
}

export interface UserAdminUpdateInput {
  email?: String;
  hashedPassword?: String;
  roles?: UserAdminRoleUpdateManyInput;
}

export interface UserAdminRoleUpdateManyInput {
  create?: UserAdminRoleCreateInput[] | UserAdminRoleCreateInput;
  update?:
    | UserAdminRoleUpdateWithWhereUniqueNestedInput[]
    | UserAdminRoleUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserAdminRoleUpsertWithWhereUniqueNestedInput[]
    | UserAdminRoleUpsertWithWhereUniqueNestedInput;
  delete?: UserAdminRoleWhereUniqueInput[] | UserAdminRoleWhereUniqueInput;
  connect?: UserAdminRoleWhereUniqueInput[] | UserAdminRoleWhereUniqueInput;
  set?: UserAdminRoleWhereUniqueInput[] | UserAdminRoleWhereUniqueInput;
  disconnect?: UserAdminRoleWhereUniqueInput[] | UserAdminRoleWhereUniqueInput;
  deleteMany?: UserAdminRoleScalarWhereInput[] | UserAdminRoleScalarWhereInput;
  updateMany?:
    | UserAdminRoleUpdateManyWithWhereNestedInput[]
    | UserAdminRoleUpdateManyWithWhereNestedInput;
}

export interface UserAdminRoleUpdateWithWhereUniqueNestedInput {
  where: UserAdminRoleWhereUniqueInput;
  data: UserAdminRoleUpdateDataInput;
}

export interface UserAdminRoleUpdateDataInput {
  name?: String;
  permissions?: UserAdminPermissionUpdateManyInput;
}

export interface UserAdminPermissionUpdateManyInput {
  create?: UserAdminPermissionCreateInput[] | UserAdminPermissionCreateInput;
  update?:
    | UserAdminPermissionUpdateWithWhereUniqueNestedInput[]
    | UserAdminPermissionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserAdminPermissionUpsertWithWhereUniqueNestedInput[]
    | UserAdminPermissionUpsertWithWhereUniqueNestedInput;
  delete?:
    | UserAdminPermissionWhereUniqueInput[]
    | UserAdminPermissionWhereUniqueInput;
  connect?:
    | UserAdminPermissionWhereUniqueInput[]
    | UserAdminPermissionWhereUniqueInput;
  set?:
    | UserAdminPermissionWhereUniqueInput[]
    | UserAdminPermissionWhereUniqueInput;
  disconnect?:
    | UserAdminPermissionWhereUniqueInput[]
    | UserAdminPermissionWhereUniqueInput;
  deleteMany?:
    | UserAdminPermissionScalarWhereInput[]
    | UserAdminPermissionScalarWhereInput;
  updateMany?:
    | UserAdminPermissionUpdateManyWithWhereNestedInput[]
    | UserAdminPermissionUpdateManyWithWhereNestedInput;
}

export interface UserAdminPermissionUpdateWithWhereUniqueNestedInput {
  where: UserAdminPermissionWhereUniqueInput;
  data: UserAdminPermissionUpdateDataInput;
}

export interface UserAdminPermissionUpdateDataInput {
  type?: String;
  resource?: String;
}

export interface UserAdminPermissionUpsertWithWhereUniqueNestedInput {
  where: UserAdminPermissionWhereUniqueInput;
  update: UserAdminPermissionUpdateDataInput;
  create: UserAdminPermissionCreateInput;
}

export interface UserAdminPermissionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  resource?: String;
  resource_not?: String;
  resource_in?: String[] | String;
  resource_not_in?: String[] | String;
  resource_lt?: String;
  resource_lte?: String;
  resource_gt?: String;
  resource_gte?: String;
  resource_contains?: String;
  resource_not_contains?: String;
  resource_starts_with?: String;
  resource_not_starts_with?: String;
  resource_ends_with?: String;
  resource_not_ends_with?: String;
  AND?:
    | UserAdminPermissionScalarWhereInput[]
    | UserAdminPermissionScalarWhereInput;
  OR?:
    | UserAdminPermissionScalarWhereInput[]
    | UserAdminPermissionScalarWhereInput;
  NOT?:
    | UserAdminPermissionScalarWhereInput[]
    | UserAdminPermissionScalarWhereInput;
}

export interface UserAdminPermissionUpdateManyWithWhereNestedInput {
  where: UserAdminPermissionScalarWhereInput;
  data: UserAdminPermissionUpdateManyDataInput;
}

export interface UserAdminPermissionUpdateManyDataInput {
  type?: String;
  resource?: String;
}

export interface UserAdminRoleUpsertWithWhereUniqueNestedInput {
  where: UserAdminRoleWhereUniqueInput;
  update: UserAdminRoleUpdateDataInput;
  create: UserAdminRoleCreateInput;
}

export interface UserAdminRoleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserAdminRoleScalarWhereInput[] | UserAdminRoleScalarWhereInput;
  OR?: UserAdminRoleScalarWhereInput[] | UserAdminRoleScalarWhereInput;
  NOT?: UserAdminRoleScalarWhereInput[] | UserAdminRoleScalarWhereInput;
}

export interface UserAdminRoleUpdateManyWithWhereNestedInput {
  where: UserAdminRoleScalarWhereInput;
  data: UserAdminRoleUpdateManyDataInput;
}

export interface UserAdminRoleUpdateManyDataInput {
  name?: String;
}

export interface UserAdminUpdateManyMutationInput {
  email?: String;
  hashedPassword?: String;
}

export interface UserAdminPermissionUpdateInput {
  type?: String;
  resource?: String;
}

export interface UserAdminPermissionUpdateManyMutationInput {
  type?: String;
  resource?: String;
}

export interface UserAdminRoleUpdateInput {
  name?: String;
  permissions?: UserAdminPermissionUpdateManyInput;
}

export interface UserAdminRoleUpdateManyMutationInput {
  name?: String;
}

export interface VendorUpdateInput {
  type?: VendorType;
  authors?: AuthorUpdateManyWithoutVendorInput;
  translators?: TranslatorUpdateManyWithoutVendorInput;
  copyrightHolders?: CopyrightHolderUpdateManyWithoutVendorInput;
  documents?: DocumentUpdateManyInput;
  billingInformation?: VendorBillingInformationUpdateOneRequiredInput;
  phoneNumber?: String;
  email?: String;
}

export interface VendorUpdateManyMutationInput {
  type?: VendorType;
  phoneNumber?: String;
  email?: String;
}

export interface VendorBillingInformationUpdateInput {
  billingType?: VendorBillingType;
  companyName?: String;
  branchId?: String;
  taxID?: String;
  firstName?: String;
  lastName?: String;
  bank?: String;
  bookBankNumber?: String;
  address?: String;
  province?: String;
  zipCode?: String;
}

export interface VendorBillingInformationUpdateManyMutationInput {
  billingType?: VendorBillingType;
  companyName?: String;
  branchId?: String;
  taxID?: String;
  firstName?: String;
  lastName?: String;
  bank?: String;
  bookBankNumber?: String;
  address?: String;
  province?: String;
  zipCode?: String;
}

export interface VendorRevenueCreateInput {
  weight: Int;
  revenueSharing: RevenueSharingCreateOneInput;
  transaction: TransactionCreateOneWithoutVendorRevenueInput;
}

export interface TransactionCreateOneWithoutVendorRevenueInput {
  create?: TransactionCreateWithoutVendorRevenueInput;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionCreateWithoutVendorRevenueInput {
  user: UserCreateOneWithoutTransactionsInput;
  type: TransactionType;
  currencyType: CurrencyType;
  amount: Float;
  exchangeTransaction?: ExchangeTransactionCreateOneInput;
  items?: ItemCreateManyWithoutTransactionInput;
}

export interface VendorRevenueUpdateInput {
  weight?: Int;
  revenueSharing?: RevenueSharingUpdateOneRequiredInput;
  transaction?: TransactionUpdateOneRequiredWithoutVendorRevenueInput;
}

export interface TransactionUpdateOneRequiredWithoutVendorRevenueInput {
  create?: TransactionCreateWithoutVendorRevenueInput;
  update?: TransactionUpdateWithoutVendorRevenueDataInput;
  upsert?: TransactionUpsertWithoutVendorRevenueInput;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionUpdateWithoutVendorRevenueDataInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  type?: TransactionType;
  currencyType?: CurrencyType;
  amount?: Float;
  exchangeTransaction?: ExchangeTransactionUpdateOneInput;
  items?: ItemUpdateManyWithoutTransactionInput;
}

export interface TransactionUpsertWithoutVendorRevenueInput {
  update: TransactionUpdateWithoutVendorRevenueDataInput;
  create: TransactionCreateWithoutVendorRevenueInput;
}

export interface VendorRevenueUpdateManyMutationInput {
  weight?: Int;
}

export interface AdsBannerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AdsBannerWhereInput;
  AND?: AdsBannerSubscriptionWhereInput[] | AdsBannerSubscriptionWhereInput;
  OR?: AdsBannerSubscriptionWhereInput[] | AdsBannerSubscriptionWhereInput;
  NOT?: AdsBannerSubscriptionWhereInput[] | AdsBannerSubscriptionWhereInput;
}

export interface AuthorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AuthorWhereInput;
  AND?: AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput;
  OR?: AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput;
  NOT?: AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput;
}

export interface BehaviorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BehaviorWhereInput;
  AND?: BehaviorSubscriptionWhereInput[] | BehaviorSubscriptionWhereInput;
  OR?: BehaviorSubscriptionWhereInput[] | BehaviorSubscriptionWhereInput;
  NOT?: BehaviorSubscriptionWhereInput[] | BehaviorSubscriptionWhereInput;
}

export interface BookSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookWhereInput;
  AND?: BookSubscriptionWhereInput[] | BookSubscriptionWhereInput;
  OR?: BookSubscriptionWhereInput[] | BookSubscriptionWhereInput;
  NOT?: BookSubscriptionWhereInput[] | BookSubscriptionWhereInput;
}

export interface BookEpisodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookEpisodeWhereInput;
  AND?: BookEpisodeSubscriptionWhereInput[] | BookEpisodeSubscriptionWhereInput;
  OR?: BookEpisodeSubscriptionWhereInput[] | BookEpisodeSubscriptionWhereInput;
  NOT?: BookEpisodeSubscriptionWhereInput[] | BookEpisodeSubscriptionWhereInput;
}

export interface BookEpisodeContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookEpisodeContentWhereInput;
  AND?:
    | BookEpisodeContentSubscriptionWhereInput[]
    | BookEpisodeContentSubscriptionWhereInput;
  OR?:
    | BookEpisodeContentSubscriptionWhereInput[]
    | BookEpisodeContentSubscriptionWhereInput;
  NOT?:
    | BookEpisodeContentSubscriptionWhereInput[]
    | BookEpisodeContentSubscriptionWhereInput;
}

export interface BookEpisodeRecentReadSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookEpisodeRecentReadWhereInput;
  AND?:
    | BookEpisodeRecentReadSubscriptionWhereInput[]
    | BookEpisodeRecentReadSubscriptionWhereInput;
  OR?:
    | BookEpisodeRecentReadSubscriptionWhereInput[]
    | BookEpisodeRecentReadSubscriptionWhereInput;
  NOT?:
    | BookEpisodeRecentReadSubscriptionWhereInput[]
    | BookEpisodeRecentReadSubscriptionWhereInput;
}

export interface BookEpisodeReviewPostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookEpisodeReviewPostWhereInput;
  AND?:
    | BookEpisodeReviewPostSubscriptionWhereInput[]
    | BookEpisodeReviewPostSubscriptionWhereInput;
  OR?:
    | BookEpisodeReviewPostSubscriptionWhereInput[]
    | BookEpisodeReviewPostSubscriptionWhereInput;
  NOT?:
    | BookEpisodeReviewPostSubscriptionWhereInput[]
    | BookEpisodeReviewPostSubscriptionWhereInput;
}

export interface BookRecommendedSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookRecommendedWhereInput;
  AND?:
    | BookRecommendedSubscriptionWhereInput[]
    | BookRecommendedSubscriptionWhereInput;
  OR?:
    | BookRecommendedSubscriptionWhereInput[]
    | BookRecommendedSubscriptionWhereInput;
  NOT?:
    | BookRecommendedSubscriptionWhereInput[]
    | BookRecommendedSubscriptionWhereInput;
}

export interface BookVolumeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BookVolumeWhereInput;
  AND?: BookVolumeSubscriptionWhereInput[] | BookVolumeSubscriptionWhereInput;
  OR?: BookVolumeSubscriptionWhereInput[] | BookVolumeSubscriptionWhereInput;
  NOT?: BookVolumeSubscriptionWhereInput[] | BookVolumeSubscriptionWhereInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoryWhereInput;
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  OR?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  NOT?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
}

export interface CopyrightHolderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CopyrightHolderWhereInput;
  AND?:
    | CopyrightHolderSubscriptionWhereInput[]
    | CopyrightHolderSubscriptionWhereInput;
  OR?:
    | CopyrightHolderSubscriptionWhereInput[]
    | CopyrightHolderSubscriptionWhereInput;
  NOT?:
    | CopyrightHolderSubscriptionWhereInput[]
    | CopyrightHolderSubscriptionWhereInput;
}

export interface DashbardDataCacheSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DashbardDataCacheWhereInput;
  AND?:
    | DashbardDataCacheSubscriptionWhereInput[]
    | DashbardDataCacheSubscriptionWhereInput;
  OR?:
    | DashbardDataCacheSubscriptionWhereInput[]
    | DashbardDataCacheSubscriptionWhereInput;
  NOT?:
    | DashbardDataCacheSubscriptionWhereInput[]
    | DashbardDataCacheSubscriptionWhereInput;
}

export interface DocumentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DocumentWhereInput;
  AND?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
  OR?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
  NOT?: DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput;
}

export interface ExchangeTierSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExchangeTierWhereInput;
  AND?:
    | ExchangeTierSubscriptionWhereInput[]
    | ExchangeTierSubscriptionWhereInput;
  OR?:
    | ExchangeTierSubscriptionWhereInput[]
    | ExchangeTierSubscriptionWhereInput;
  NOT?:
    | ExchangeTierSubscriptionWhereInput[]
    | ExchangeTierSubscriptionWhereInput;
}

export interface ExchangeTransactionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExchangeTransactionWhereInput;
  AND?:
    | ExchangeTransactionSubscriptionWhereInput[]
    | ExchangeTransactionSubscriptionWhereInput;
  OR?:
    | ExchangeTransactionSubscriptionWhereInput[]
    | ExchangeTransactionSubscriptionWhereInput;
  NOT?:
    | ExchangeTransactionSubscriptionWhereInput[]
    | ExchangeTransactionSubscriptionWhereInput;
}

export interface ExchangeTransactionStatusHistorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExchangeTransactionStatusHistoryWhereInput;
  AND?:
    | ExchangeTransactionStatusHistorySubscriptionWhereInput[]
    | ExchangeTransactionStatusHistorySubscriptionWhereInput;
  OR?:
    | ExchangeTransactionStatusHistorySubscriptionWhereInput[]
    | ExchangeTransactionStatusHistorySubscriptionWhereInput;
  NOT?:
    | ExchangeTransactionStatusHistorySubscriptionWhereInput[]
    | ExchangeTransactionStatusHistorySubscriptionWhereInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface HistorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HistoryWhereInput;
  AND?: HistorySubscriptionWhereInput[] | HistorySubscriptionWhereInput;
  OR?: HistorySubscriptionWhereInput[] | HistorySubscriptionWhereInput;
  NOT?: HistorySubscriptionWhereInput[] | HistorySubscriptionWhereInput;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ImageWhereInput;
  AND?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  OR?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  NOT?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemWhereInput;
  AND?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  OR?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  NOT?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
}

export interface ItemAssetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemAssetWhereInput;
  AND?: ItemAssetSubscriptionWhereInput[] | ItemAssetSubscriptionWhereInput;
  OR?: ItemAssetSubscriptionWhereInput[] | ItemAssetSubscriptionWhereInput;
  NOT?: ItemAssetSubscriptionWhereInput[] | ItemAssetSubscriptionWhereInput;
}

export interface MigrationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MigrationWhereInput;
  AND?: MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput;
  OR?: MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput;
  NOT?: MigrationSubscriptionWhereInput[] | MigrationSubscriptionWhereInput;
}

export interface PageViewSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PageViewWhereInput;
  AND?: PageViewSubscriptionWhereInput[] | PageViewSubscriptionWhereInput;
  OR?: PageViewSubscriptionWhereInput[] | PageViewSubscriptionWhereInput;
  NOT?: PageViewSubscriptionWhereInput[] | PageViewSubscriptionWhereInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface PriceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PriceWhereInput;
  AND?: PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput;
  OR?: PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput;
  NOT?: PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput;
}

export interface PromotionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PromotionWhereInput;
  AND?: PromotionSubscriptionWhereInput[] | PromotionSubscriptionWhereInput;
  OR?: PromotionSubscriptionWhereInput[] | PromotionSubscriptionWhereInput;
  NOT?: PromotionSubscriptionWhereInput[] | PromotionSubscriptionWhereInput;
}

export interface PublishTimelineSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PublishTimelineWhereInput;
  AND?:
    | PublishTimelineSubscriptionWhereInput[]
    | PublishTimelineSubscriptionWhereInput;
  OR?:
    | PublishTimelineSubscriptionWhereInput[]
    | PublishTimelineSubscriptionWhereInput;
  NOT?:
    | PublishTimelineSubscriptionWhereInput[]
    | PublishTimelineSubscriptionWhereInput;
}

export interface RemoteConfigSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RemoteConfigWhereInput;
  AND?:
    | RemoteConfigSubscriptionWhereInput[]
    | RemoteConfigSubscriptionWhereInput;
  OR?:
    | RemoteConfigSubscriptionWhereInput[]
    | RemoteConfigSubscriptionWhereInput;
  NOT?:
    | RemoteConfigSubscriptionWhereInput[]
    | RemoteConfigSubscriptionWhereInput;
}

export interface RevenueSharingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RevenueSharingWhereInput;
  AND?:
    | RevenueSharingSubscriptionWhereInput[]
    | RevenueSharingSubscriptionWhereInput;
  OR?:
    | RevenueSharingSubscriptionWhereInput[]
    | RevenueSharingSubscriptionWhereInput;
  NOT?:
    | RevenueSharingSubscriptionWhereInput[]
    | RevenueSharingSubscriptionWhereInput;
}

export interface ShelfSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShelfWhereInput;
  AND?: ShelfSubscriptionWhereInput[] | ShelfSubscriptionWhereInput;
  OR?: ShelfSubscriptionWhereInput[] | ShelfSubscriptionWhereInput;
  NOT?: ShelfSubscriptionWhereInput[] | ShelfSubscriptionWhereInput;
}

export interface SystemConfigSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SystemConfigWhereInput;
  AND?:
    | SystemConfigSubscriptionWhereInput[]
    | SystemConfigSubscriptionWhereInput;
  OR?:
    | SystemConfigSubscriptionWhereInput[]
    | SystemConfigSubscriptionWhereInput;
  NOT?:
    | SystemConfigSubscriptionWhereInput[]
    | SystemConfigSubscriptionWhereInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransactionWhereInput;
  AND?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  OR?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  NOT?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
}

export interface TranslatorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TranslatorWhereInput;
  AND?: TranslatorSubscriptionWhereInput[] | TranslatorSubscriptionWhereInput;
  OR?: TranslatorSubscriptionWhereInput[] | TranslatorSubscriptionWhereInput;
  NOT?: TranslatorSubscriptionWhereInput[] | TranslatorSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface UserAdminSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserAdminWhereInput;
  AND?: UserAdminSubscriptionWhereInput[] | UserAdminSubscriptionWhereInput;
  OR?: UserAdminSubscriptionWhereInput[] | UserAdminSubscriptionWhereInput;
  NOT?: UserAdminSubscriptionWhereInput[] | UserAdminSubscriptionWhereInput;
}

export interface UserAdminPermissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserAdminPermissionWhereInput;
  AND?:
    | UserAdminPermissionSubscriptionWhereInput[]
    | UserAdminPermissionSubscriptionWhereInput;
  OR?:
    | UserAdminPermissionSubscriptionWhereInput[]
    | UserAdminPermissionSubscriptionWhereInput;
  NOT?:
    | UserAdminPermissionSubscriptionWhereInput[]
    | UserAdminPermissionSubscriptionWhereInput;
}

export interface UserAdminRoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserAdminRoleWhereInput;
  AND?:
    | UserAdminRoleSubscriptionWhereInput[]
    | UserAdminRoleSubscriptionWhereInput;
  OR?:
    | UserAdminRoleSubscriptionWhereInput[]
    | UserAdminRoleSubscriptionWhereInput;
  NOT?:
    | UserAdminRoleSubscriptionWhereInput[]
    | UserAdminRoleSubscriptionWhereInput;
}

export interface VendorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VendorWhereInput;
  AND?: VendorSubscriptionWhereInput[] | VendorSubscriptionWhereInput;
  OR?: VendorSubscriptionWhereInput[] | VendorSubscriptionWhereInput;
  NOT?: VendorSubscriptionWhereInput[] | VendorSubscriptionWhereInput;
}

export interface VendorBillingInformationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VendorBillingInformationWhereInput;
  AND?:
    | VendorBillingInformationSubscriptionWhereInput[]
    | VendorBillingInformationSubscriptionWhereInput;
  OR?:
    | VendorBillingInformationSubscriptionWhereInput[]
    | VendorBillingInformationSubscriptionWhereInput;
  NOT?:
    | VendorBillingInformationSubscriptionWhereInput[]
    | VendorBillingInformationSubscriptionWhereInput;
}

export interface VendorRevenueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VendorRevenueWhereInput;
  AND?:
    | VendorRevenueSubscriptionWhereInput[]
    | VendorRevenueSubscriptionWhereInput;
  OR?:
    | VendorRevenueSubscriptionWhereInput[]
    | VendorRevenueSubscriptionWhereInput;
  NOT?:
    | VendorRevenueSubscriptionWhereInput[]
    | VendorRevenueSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AdsBanner {
  id: ID_Output;
  name?: String;
  order?: Float;
  altTag?: String;
  backgroundColor?: String;
  url?: String;
  page?: String;
  position?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AdsBannerPromise extends Promise<AdsBanner>, Fragmentable {
  id: () => Promise<ID_Output>;
  image: <T = ImagePromise>() => T;
  name: () => Promise<String>;
  order: () => Promise<Float>;
  altTag: () => Promise<String>;
  backgroundColor: () => Promise<String>;
  url: () => Promise<String>;
  page: () => Promise<String>;
  position: () => Promise<String>;
  publishTimeline: <T = PublishTimelinePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdsBannerSubscription
  extends Promise<AsyncIterator<AdsBanner>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: <T = ImageSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Float>>;
  altTag: () => Promise<AsyncIterator<String>>;
  backgroundColor: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  page: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  publishTimeline: <T = PublishTimelineSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Image {
  id: ID_Output;
  small: String;
  medium: String;
  large: String;
  fileName: String;
  createdAt: DateTimeOutput;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  small: () => Promise<String>;
  medium: () => Promise<String>;
  large: () => Promise<String>;
  fileName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  small: () => Promise<AsyncIterator<String>>;
  medium: () => Promise<AsyncIterator<String>>;
  large: () => Promise<AsyncIterator<String>>;
  fileName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PublishTimeline {
  startAt: DateTimeOutput;
  endAt?: DateTimeOutput;
}

export interface PublishTimelinePromise
  extends Promise<PublishTimeline>,
    Fragmentable {
  startAt: () => Promise<DateTimeOutput>;
  endAt: () => Promise<DateTimeOutput>;
}

export interface PublishTimelineSubscription
  extends Promise<AsyncIterator<PublishTimeline>>,
    Fragmentable {
  startAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AdsBannerConnection {
  pageInfo: PageInfo;
  edges: AdsBannerEdge[];
}

export interface AdsBannerConnectionPromise
  extends Promise<AdsBannerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdsBannerEdge>>() => T;
  aggregate: <T = AggregateAdsBannerPromise>() => T;
}

export interface AdsBannerConnectionSubscription
  extends Promise<AsyncIterator<AdsBannerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdsBannerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdsBannerSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AdsBannerEdge {
  node: AdsBanner;
  cursor: String;
}

export interface AdsBannerEdgePromise
  extends Promise<AdsBannerEdge>,
    Fragmentable {
  node: <T = AdsBannerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdsBannerEdgeSubscription
  extends Promise<AsyncIterator<AdsBannerEdge>>,
    Fragmentable {
  node: <T = AdsBannerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdsBanner {
  count: Int;
}

export interface AggregateAdsBannerPromise
  extends Promise<AggregateAdsBanner>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdsBannerSubscription
  extends Promise<AsyncIterator<AggregateAdsBanner>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Author {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AuthorPromise extends Promise<Author>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  vendor: <T = VendorPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AuthorSubscription
  extends Promise<AsyncIterator<Author>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  vendor: <T = VendorSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Vendor {
  id: ID_Output;
  type: VendorType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  phoneNumber?: String;
  email?: String;
}

export interface VendorPromise extends Promise<Vendor>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<VendorType>;
  authors: <T = FragmentableArray<Author>>(
    args?: {
      where?: AuthorWhereInput;
      orderBy?: AuthorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  translators: <T = FragmentableArray<Translator>>(
    args?: {
      where?: TranslatorWhereInput;
      orderBy?: TranslatorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  copyrightHolders: <T = FragmentableArray<CopyrightHolder>>(
    args?: {
      where?: CopyrightHolderWhereInput;
      orderBy?: CopyrightHolderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  documents: <T = FragmentableArray<Document>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  billingInformation: <T = VendorBillingInformationPromise>() => T;
  phoneNumber: () => Promise<String>;
  email: () => Promise<String>;
}

export interface VendorSubscription
  extends Promise<AsyncIterator<Vendor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<VendorType>>;
  authors: <T = Promise<AsyncIterator<AuthorSubscription>>>(
    args?: {
      where?: AuthorWhereInput;
      orderBy?: AuthorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  translators: <T = Promise<AsyncIterator<TranslatorSubscription>>>(
    args?: {
      where?: TranslatorWhereInput;
      orderBy?: TranslatorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  copyrightHolders: <T = Promise<AsyncIterator<CopyrightHolderSubscription>>>(
    args?: {
      where?: CopyrightHolderWhereInput;
      orderBy?: CopyrightHolderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  documents: <T = Promise<AsyncIterator<DocumentSubscription>>>(
    args?: {
      where?: DocumentWhereInput;
      orderBy?: DocumentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  billingInformation: <T = VendorBillingInformationSubscription>() => T;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface Translator {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TranslatorPromise extends Promise<Translator>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  vendor: <T = VendorPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TranslatorSubscription
  extends Promise<AsyncIterator<Translator>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  vendor: <T = VendorSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CopyrightHolder {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CopyrightHolderPromise
  extends Promise<CopyrightHolder>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  vendor: <T = VendorPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CopyrightHolderSubscription
  extends Promise<AsyncIterator<CopyrightHolder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  vendor: <T = VendorSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Document {
  id: ID_Output;
  type: DocumentType;
}

export interface DocumentPromise extends Promise<Document>, Fragmentable {
  id: () => Promise<ID_Output>;
  file: <T = FilePromise>() => T;
  image: <T = ImagePromise>() => T;
  type: () => Promise<DocumentType>;
}

export interface DocumentSubscription
  extends Promise<AsyncIterator<Document>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  file: <T = FileSubscription>() => T;
  image: <T = ImageSubscription>() => T;
  type: () => Promise<AsyncIterator<DocumentType>>;
}

export interface File {
  id: ID_Output;
  path: String;
  fileName: String;
  createdAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  path: () => Promise<String>;
  fileName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<String>>;
  fileName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VendorBillingInformation {
  id: ID_Output;
  billingType: VendorBillingType;
  companyName?: String;
  branchId?: String;
  taxID: String;
  firstName: String;
  lastName: String;
  bank?: String;
  bookBankNumber?: String;
  address: String;
  province?: String;
  zipCode?: String;
}

export interface VendorBillingInformationPromise
  extends Promise<VendorBillingInformation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  billingType: () => Promise<VendorBillingType>;
  companyName: () => Promise<String>;
  branchId: () => Promise<String>;
  taxID: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  bank: () => Promise<String>;
  bookBankNumber: () => Promise<String>;
  address: () => Promise<String>;
  province: () => Promise<String>;
  zipCode: () => Promise<String>;
}

export interface VendorBillingInformationSubscription
  extends Promise<AsyncIterator<VendorBillingInformation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  billingType: () => Promise<AsyncIterator<VendorBillingType>>;
  companyName: () => Promise<AsyncIterator<String>>;
  branchId: () => Promise<AsyncIterator<String>>;
  taxID: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  bank: () => Promise<AsyncIterator<String>>;
  bookBankNumber: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  province: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
}

export interface AuthorConnection {
  pageInfo: PageInfo;
  edges: AuthorEdge[];
}

export interface AuthorConnectionPromise
  extends Promise<AuthorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthorEdge>>() => T;
  aggregate: <T = AggregateAuthorPromise>() => T;
}

export interface AuthorConnectionSubscription
  extends Promise<AsyncIterator<AuthorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthorSubscription>() => T;
}

export interface AuthorEdge {
  node: Author;
  cursor: String;
}

export interface AuthorEdgePromise extends Promise<AuthorEdge>, Fragmentable {
  node: <T = AuthorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthorEdgeSubscription
  extends Promise<AsyncIterator<AuthorEdge>>,
    Fragmentable {
  node: <T = AuthorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAuthor {
  count: Int;
}

export interface AggregateAuthorPromise
  extends Promise<AggregateAuthor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthorSubscription
  extends Promise<AsyncIterator<AggregateAuthor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Behavior {
  id: ID_Output;
  ip: String;
  action: String;
  payload: Json;
  createdAt: DateTimeOutput;
}

export interface BehaviorPromise extends Promise<Behavior>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  ip: () => Promise<String>;
  action: () => Promise<String>;
  payload: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BehaviorSubscription
  extends Promise<AsyncIterator<Behavior>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  ip: () => Promise<AsyncIterator<String>>;
  action: () => Promise<AsyncIterator<String>>;
  payload: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface User {
  id: ID_Output;
  userID: ID_Output;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender: Gender;
  defaultProfilePicture?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  userID: () => Promise<ID_Output>;
  displayName: () => Promise<String>;
  email: () => Promise<String>;
  fullName: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<String>;
  gender: () => Promise<Gender>;
  defaultProfilePicture: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  transactions: <T = FragmentableArray<Transaction>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exchangeTransactions: <T = FragmentableArray<ExchangeTransaction>>(
    args?: {
      where?: ExchangeTransactionWhereInput;
      orderBy?: ExchangeTransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userID: () => Promise<AsyncIterator<ID_Output>>;
  displayName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  fullName: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  defaultProfilePicture: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exchangeTransactions: <
    T = Promise<AsyncIterator<ExchangeTransactionSubscription>>
  >(
    args?: {
      where?: ExchangeTransactionWhereInput;
      orderBy?: ExchangeTransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Transaction {
  id: ID_Output;
  type: TransactionType;
  currencyType: CurrencyType;
  amount: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  type: () => Promise<TransactionType>;
  currencyType: () => Promise<CurrencyType>;
  amount: () => Promise<Float>;
  exchangeTransaction: <T = ExchangeTransactionPromise>() => T;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  vendorRevenue: <T = FragmentableArray<VendorRevenue>>(
    args?: {
      where?: VendorRevenueWhereInput;
      orderBy?: VendorRevenueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  type: () => Promise<AsyncIterator<TransactionType>>;
  currencyType: () => Promise<AsyncIterator<CurrencyType>>;
  amount: () => Promise<AsyncIterator<Float>>;
  exchangeTransaction: <T = ExchangeTransactionSubscription>() => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  vendorRevenue: <T = Promise<AsyncIterator<VendorRevenueSubscription>>>(
    args?: {
      where?: VendorRevenueWhereInput;
      orderBy?: VendorRevenueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ExchangeTransaction {
  id: ID_Output;
  orderID?: String;
  currentStatus?: ExchangeTransactionType;
  payload: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  refCode?: String;
}

export interface ExchangeTransactionPromise
  extends Promise<ExchangeTransaction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  orderID: () => Promise<String>;
  user: <T = UserPromise>() => T;
  tier: <T = ExchangeTierPromise>() => T;
  status: <T = FragmentableArray<ExchangeTransactionStatusHistory>>(
    args?: {
      where?: ExchangeTransactionStatusHistoryWhereInput;
      orderBy?: ExchangeTransactionStatusHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  currentStatus: () => Promise<ExchangeTransactionType>;
  payload: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  refCode: () => Promise<String>;
}

export interface ExchangeTransactionSubscription
  extends Promise<AsyncIterator<ExchangeTransaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  orderID: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  tier: <T = ExchangeTierSubscription>() => T;
  status: <
    T = Promise<AsyncIterator<ExchangeTransactionStatusHistorySubscription>>
  >(
    args?: {
      where?: ExchangeTransactionStatusHistoryWhereInput;
      orderBy?: ExchangeTransactionStatusHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  currentStatus: () => Promise<AsyncIterator<ExchangeTransactionType>>;
  payload: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  refCode: () => Promise<AsyncIterator<String>>;
}

export interface ExchangeTier {
  id: ID_Output;
  type: ExchangeType;
  name: String;
  currencyType: CurrencyType;
  income: Float;
  outcome: Float;
  isDefault: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExchangeTierPromise
  extends Promise<ExchangeTier>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ExchangeType>;
  name: () => Promise<String>;
  currencyType: () => Promise<CurrencyType>;
  income: () => Promise<Float>;
  outcome: () => Promise<Float>;
  promotions: <T = FragmentableArray<Promotion>>(
    args?: {
      where?: PromotionWhereInput;
      orderBy?: PromotionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publishTimeline: <T = PublishTimelinePromise>() => T;
}

export interface ExchangeTierSubscription
  extends Promise<AsyncIterator<ExchangeTier>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ExchangeType>>;
  name: () => Promise<AsyncIterator<String>>;
  currencyType: () => Promise<AsyncIterator<CurrencyType>>;
  income: () => Promise<AsyncIterator<Float>>;
  outcome: () => Promise<AsyncIterator<Float>>;
  promotions: <T = Promise<AsyncIterator<PromotionSubscription>>>(
    args?: {
      where?: PromotionWhereInput;
      orderBy?: PromotionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishTimeline: <T = PublishTimelineSubscription>() => T;
}

export interface Promotion {
  id: ID_Output;
  name: String;
  unit: PromotionUnit;
  type: PromotionType;
  amount: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PromotionPromise extends Promise<Promotion>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  unit: () => Promise<PromotionUnit>;
  type: () => Promise<PromotionType>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PromotionSubscription
  extends Promise<AsyncIterator<Promotion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<PromotionUnit>>;
  type: () => Promise<AsyncIterator<PromotionType>>;
  amount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExchangeTransactionStatusHistory {
  id: ID_Output;
  status: ExchangeTransactionType;
  message?: String;
}

export interface ExchangeTransactionStatusHistoryPromise
  extends Promise<ExchangeTransactionStatusHistory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ExchangeTransactionType>;
  message: () => Promise<String>;
}

export interface ExchangeTransactionStatusHistorySubscription
  extends Promise<AsyncIterator<ExchangeTransactionStatusHistory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ExchangeTransactionType>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface Item {
  id: ID_Output;
  amount: Int;
  expireAt?: DateTimeOutput;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  asset: <T = ItemAssetPromise>() => T;
  amount: () => Promise<Int>;
  expireAt: () => Promise<DateTimeOutput>;
  transaction: <T = TransactionPromise>() => T;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  asset: <T = ItemAssetSubscription>() => T;
  amount: () => Promise<AsyncIterator<Int>>;
  expireAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  transaction: <T = TransactionSubscription>() => T;
}

export interface ItemAsset {
  id: ID_Output;
  assetType: String;
  assetID: ID_Output;
}

export interface ItemAssetPromise extends Promise<ItemAsset>, Fragmentable {
  id: () => Promise<ID_Output>;
  assetType: () => Promise<String>;
  assetID: () => Promise<ID_Output>;
  item: <T = ItemPromise>() => T;
}

export interface ItemAssetSubscription
  extends Promise<AsyncIterator<ItemAsset>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  assetType: () => Promise<AsyncIterator<String>>;
  assetID: () => Promise<AsyncIterator<ID_Output>>;
  item: <T = ItemSubscription>() => T;
}

export interface VendorRevenue {
  id: ID_Output;
  weight: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VendorRevenuePromise
  extends Promise<VendorRevenue>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<Int>;
  revenueSharing: <T = RevenueSharingPromise>() => T;
  transaction: <T = TransactionPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VendorRevenueSubscription
  extends Promise<AsyncIterator<VendorRevenue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<Int>>;
  revenueSharing: <T = RevenueSharingSubscription>() => T;
  transaction: <T = TransactionSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RevenueSharing {
  id: ID_Output;
  commission: Float;
  status: RevenueSharingStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RevenueSharingPromise
  extends Promise<RevenueSharing>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  vendor: <T = VendorPromise>() => T;
  book: <T = BookPromise>() => T;
  commission: () => Promise<Float>;
  status: () => Promise<RevenueSharingStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RevenueSharingSubscription
  extends Promise<AsyncIterator<RevenueSharing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vendor: <T = VendorSubscription>() => T;
  book: <T = BookSubscription>() => T;
  commission: () => Promise<AsyncIterator<Float>>;
  status: () => Promise<AsyncIterator<RevenueSharingStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Book {
  id: ID_Output;
  slug?: String;
  name: String;
  introduction: Json;
  synopsis?: String;
  isPublished: Boolean;
  publishedAt?: DateTimeOutput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookPromise extends Promise<Book>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  introduction: () => Promise<Json>;
  synopsis: () => Promise<String>;
  thumbnail: <T = ImagePromise>() => T;
  copyrightHolder: <T = CopyrightHolderPromise>() => T;
  authors: <T = FragmentableArray<Author>>(
    args?: {
      where?: AuthorWhereInput;
      orderBy?: AuthorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  mainCategory: <T = CategoryPromise>() => T;
  secondaryCategory: <T = CategoryPromise>() => T;
  translators: <T = FragmentableArray<Translator>>(
    args?: {
      where?: TranslatorWhereInput;
      orderBy?: TranslatorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  volumes: <T = FragmentableArray<BookVolume>>(
    args?: {
      where?: BookVolumeWhereInput;
      orderBy?: BookVolumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isPublished: () => Promise<Boolean>;
  publishedAt: () => Promise<DateTimeOutput>;
  publishTimeline: <T = PublishTimelinePromise>() => T;
  isUnlisted: () => Promise<Boolean>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
  metaKeyword: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookSubscription
  extends Promise<AsyncIterator<Book>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  introduction: () => Promise<AsyncIterator<Json>>;
  synopsis: () => Promise<AsyncIterator<String>>;
  thumbnail: <T = ImageSubscription>() => T;
  copyrightHolder: <T = CopyrightHolderSubscription>() => T;
  authors: <T = Promise<AsyncIterator<AuthorSubscription>>>(
    args?: {
      where?: AuthorWhereInput;
      orderBy?: AuthorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  mainCategory: <T = CategorySubscription>() => T;
  secondaryCategory: <T = CategorySubscription>() => T;
  translators: <T = Promise<AsyncIterator<TranslatorSubscription>>>(
    args?: {
      where?: TranslatorWhereInput;
      orderBy?: TranslatorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  volumes: <T = Promise<AsyncIterator<BookVolumeSubscription>>>(
    args?: {
      where?: BookVolumeWhereInput;
      orderBy?: BookVolumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishTimeline: <T = PublishTimelineSubscription>() => T;
  isUnlisted: () => Promise<AsyncIterator<Boolean>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  metaKeyword: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Category {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookVolume {
  id: ID_Output;
  slug?: String;
  title: String;
  isPublished: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookVolumePromise extends Promise<BookVolume>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  title: () => Promise<String>;
  book: <T = BookPromise>() => T;
  episodes: <T = FragmentableArray<BookEpisode>>(
    args?: {
      where?: BookEpisodeWhereInput;
      orderBy?: BookEpisodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isPublished: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookVolumeSubscription
  extends Promise<AsyncIterator<BookVolume>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  book: <T = BookSubscription>() => T;
  episodes: <T = Promise<AsyncIterator<BookEpisodeSubscription>>>(
    args?: {
      where?: BookEpisodeWhereInput;
      orderBy?: BookEpisodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookEpisode {
  id: ID_Output;
  slug?: String;
  isPublished: Boolean;
  publishedAt?: DateTimeOutput;
  isUnlisted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodePromise extends Promise<BookEpisode>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  authors: <T = FragmentableArray<Author>>(
    args?: {
      where?: AuthorWhereInput;
      orderBy?: AuthorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  translators: <T = FragmentableArray<Translator>>(
    args?: {
      where?: TranslatorWhereInput;
      orderBy?: TranslatorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  prices: <T = FragmentableArray<Price>>(
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  priceHistory: <T = FragmentableArray<Price>>(
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  publishContent: <T = BookEpisodeContentPromise>() => T;
  draftContent: <T = BookEpisodeContentPromise>() => T;
  revisionContents: <T = FragmentableArray<BookEpisodeContent>>(
    args?: {
      where?: BookEpisodeContentWhereInput;
      orderBy?: BookEpisodeContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  volume: <T = BookVolumePromise>() => T;
  isPublished: () => Promise<Boolean>;
  publishedAt: () => Promise<DateTimeOutput>;
  vendor: <T = VendorPromise>() => T;
  publishTimeline: <T = PublishTimelinePromise>() => T;
  isUnlisted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  pageView: <T = PageViewPromise>() => T;
  reviews: <T = FragmentableArray<BookEpisodeReviewPost>>(
    args?: {
      where?: BookEpisodeReviewPostWhereInput;
      orderBy?: BookEpisodeReviewPostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
  metaKeyword: () => Promise<String>;
}

export interface BookEpisodeSubscription
  extends Promise<AsyncIterator<BookEpisode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  authors: <T = Promise<AsyncIterator<AuthorSubscription>>>(
    args?: {
      where?: AuthorWhereInput;
      orderBy?: AuthorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  translators: <T = Promise<AsyncIterator<TranslatorSubscription>>>(
    args?: {
      where?: TranslatorWhereInput;
      orderBy?: TranslatorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  prices: <T = Promise<AsyncIterator<PriceSubscription>>>(
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  priceHistory: <T = Promise<AsyncIterator<PriceSubscription>>>(
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  publishContent: <T = BookEpisodeContentSubscription>() => T;
  draftContent: <T = BookEpisodeContentSubscription>() => T;
  revisionContents: <
    T = Promise<AsyncIterator<BookEpisodeContentSubscription>>
  >(
    args?: {
      where?: BookEpisodeContentWhereInput;
      orderBy?: BookEpisodeContentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  volume: <T = BookVolumeSubscription>() => T;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  vendor: <T = VendorSubscription>() => T;
  publishTimeline: <T = PublishTimelineSubscription>() => T;
  isUnlisted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  pageView: <T = PageViewSubscription>() => T;
  reviews: <T = Promise<AsyncIterator<BookEpisodeReviewPostSubscription>>>(
    args?: {
      where?: BookEpisodeReviewPostWhereInput;
      orderBy?: BookEpisodeReviewPostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  metaKeyword: () => Promise<AsyncIterator<String>>;
}

export interface Price {
  id: ID_Output;
  currencyType: CurrencyType;
  amount: Float;
  archiveAt?: DateTimeOutput;
}

export interface PricePromise extends Promise<Price>, Fragmentable {
  id: () => Promise<ID_Output>;
  currencyType: () => Promise<CurrencyType>;
  amount: () => Promise<Float>;
  archiveAt: () => Promise<DateTimeOutput>;
}

export interface PriceSubscription
  extends Promise<AsyncIterator<Price>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  currencyType: () => Promise<AsyncIterator<CurrencyType>>;
  amount: () => Promise<AsyncIterator<Float>>;
  archiveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookEpisodeContent {
  id: ID_Output;
  title: String;
  draft?: Json;
}

export interface BookEpisodeContentPromise
  extends Promise<BookEpisodeContent>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  draft: () => Promise<Json>;
}

export interface BookEpisodeContentSubscription
  extends Promise<AsyncIterator<BookEpisodeContent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  draft: () => Promise<AsyncIterator<Json>>;
}

export interface PageView {
  id: ID_Output;
  count: Int;
  updatedAt: DateTimeOutput;
}

export interface PageViewPromise extends Promise<PageView>, Fragmentable {
  id: () => Promise<ID_Output>;
  episode: <T = BookEpisodePromise>() => T;
  count: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageViewSubscription
  extends Promise<AsyncIterator<PageView>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  episode: <T = BookEpisodeSubscription>() => T;
  count: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookEpisodeReviewPost {
  id: ID_Output;
  rating: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookEpisodeReviewPostPromise
  extends Promise<BookEpisodeReviewPost>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  episode: <T = BookEpisodePromise>() => T;
  rating: () => Promise<Int>;
  post: <T = PostPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookEpisodeReviewPostSubscription
  extends Promise<AsyncIterator<BookEpisodeReviewPost>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  episode: <T = BookEpisodeSubscription>() => T;
  rating: () => Promise<AsyncIterator<Int>>;
  post: <T = PostSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Post {
  type: PostType;
  id: ID_Output;
  message: String;
  status?: ReviewPostStatus;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  type: () => Promise<PostType>;
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  message: () => Promise<String>;
  status: () => Promise<ReviewPostStatus>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<PostType>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<ReviewPostStatus>>;
}

export interface BehaviorConnection {
  pageInfo: PageInfo;
  edges: BehaviorEdge[];
}

export interface BehaviorConnectionPromise
  extends Promise<BehaviorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BehaviorEdge>>() => T;
  aggregate: <T = AggregateBehaviorPromise>() => T;
}

export interface BehaviorConnectionSubscription
  extends Promise<AsyncIterator<BehaviorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BehaviorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBehaviorSubscription>() => T;
}

export interface BehaviorEdge {
  node: Behavior;
  cursor: String;
}

export interface BehaviorEdgePromise
  extends Promise<BehaviorEdge>,
    Fragmentable {
  node: <T = BehaviorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BehaviorEdgeSubscription
  extends Promise<AsyncIterator<BehaviorEdge>>,
    Fragmentable {
  node: <T = BehaviorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBehavior {
  count: Int;
}

export interface AggregateBehaviorPromise
  extends Promise<AggregateBehavior>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBehaviorSubscription
  extends Promise<AsyncIterator<AggregateBehavior>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookConnection {
  pageInfo: PageInfo;
  edges: BookEdge[];
}

export interface BookConnectionPromise
  extends Promise<BookConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookEdge>>() => T;
  aggregate: <T = AggregateBookPromise>() => T;
}

export interface BookConnectionSubscription
  extends Promise<AsyncIterator<BookConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookSubscription>() => T;
}

export interface BookEdge {
  node: Book;
  cursor: String;
}

export interface BookEdgePromise extends Promise<BookEdge>, Fragmentable {
  node: <T = BookPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookEdgeSubscription
  extends Promise<AsyncIterator<BookEdge>>,
    Fragmentable {
  node: <T = BookSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBook {
  count: Int;
}

export interface AggregateBookPromise
  extends Promise<AggregateBook>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookSubscription
  extends Promise<AsyncIterator<AggregateBook>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookEpisodeConnection {
  pageInfo: PageInfo;
  edges: BookEpisodeEdge[];
}

export interface BookEpisodeConnectionPromise
  extends Promise<BookEpisodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookEpisodeEdge>>() => T;
  aggregate: <T = AggregateBookEpisodePromise>() => T;
}

export interface BookEpisodeConnectionSubscription
  extends Promise<AsyncIterator<BookEpisodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookEpisodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookEpisodeSubscription>() => T;
}

export interface BookEpisodeEdge {
  node: BookEpisode;
  cursor: String;
}

export interface BookEpisodeEdgePromise
  extends Promise<BookEpisodeEdge>,
    Fragmentable {
  node: <T = BookEpisodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookEpisodeEdgeSubscription
  extends Promise<AsyncIterator<BookEpisodeEdge>>,
    Fragmentable {
  node: <T = BookEpisodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookEpisode {
  count: Int;
}

export interface AggregateBookEpisodePromise
  extends Promise<AggregateBookEpisode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookEpisodeSubscription
  extends Promise<AsyncIterator<AggregateBookEpisode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookEpisodeContentConnection {
  pageInfo: PageInfo;
  edges: BookEpisodeContentEdge[];
}

export interface BookEpisodeContentConnectionPromise
  extends Promise<BookEpisodeContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookEpisodeContentEdge>>() => T;
  aggregate: <T = AggregateBookEpisodeContentPromise>() => T;
}

export interface BookEpisodeContentConnectionSubscription
  extends Promise<AsyncIterator<BookEpisodeContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<BookEpisodeContentEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateBookEpisodeContentSubscription>() => T;
}

export interface BookEpisodeContentEdge {
  node: BookEpisodeContent;
  cursor: String;
}

export interface BookEpisodeContentEdgePromise
  extends Promise<BookEpisodeContentEdge>,
    Fragmentable {
  node: <T = BookEpisodeContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookEpisodeContentEdgeSubscription
  extends Promise<AsyncIterator<BookEpisodeContentEdge>>,
    Fragmentable {
  node: <T = BookEpisodeContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookEpisodeContent {
  count: Int;
}

export interface AggregateBookEpisodeContentPromise
  extends Promise<AggregateBookEpisodeContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookEpisodeContentSubscription
  extends Promise<AsyncIterator<AggregateBookEpisodeContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookEpisodeRecentRead {
  id: ID_Output;
  offsetKey: String;
  offsetRatio: Float;
}

export interface BookEpisodeRecentReadPromise
  extends Promise<BookEpisodeRecentRead>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  episode: <T = BookEpisodePromise>() => T;
  offsetKey: () => Promise<String>;
  offsetRatio: () => Promise<Float>;
}

export interface BookEpisodeRecentReadSubscription
  extends Promise<AsyncIterator<BookEpisodeRecentRead>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  episode: <T = BookEpisodeSubscription>() => T;
  offsetKey: () => Promise<AsyncIterator<String>>;
  offsetRatio: () => Promise<AsyncIterator<Float>>;
}

export interface BookEpisodeRecentReadConnection {
  pageInfo: PageInfo;
  edges: BookEpisodeRecentReadEdge[];
}

export interface BookEpisodeRecentReadConnectionPromise
  extends Promise<BookEpisodeRecentReadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookEpisodeRecentReadEdge>>() => T;
  aggregate: <T = AggregateBookEpisodeRecentReadPromise>() => T;
}

export interface BookEpisodeRecentReadConnectionSubscription
  extends Promise<AsyncIterator<BookEpisodeRecentReadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<BookEpisodeRecentReadEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateBookEpisodeRecentReadSubscription>() => T;
}

export interface BookEpisodeRecentReadEdge {
  node: BookEpisodeRecentRead;
  cursor: String;
}

export interface BookEpisodeRecentReadEdgePromise
  extends Promise<BookEpisodeRecentReadEdge>,
    Fragmentable {
  node: <T = BookEpisodeRecentReadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookEpisodeRecentReadEdgeSubscription
  extends Promise<AsyncIterator<BookEpisodeRecentReadEdge>>,
    Fragmentable {
  node: <T = BookEpisodeRecentReadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookEpisodeRecentRead {
  count: Int;
}

export interface AggregateBookEpisodeRecentReadPromise
  extends Promise<AggregateBookEpisodeRecentRead>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookEpisodeRecentReadSubscription
  extends Promise<AsyncIterator<AggregateBookEpisodeRecentRead>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookEpisodeReviewPostConnection {
  pageInfo: PageInfo;
  edges: BookEpisodeReviewPostEdge[];
}

export interface BookEpisodeReviewPostConnectionPromise
  extends Promise<BookEpisodeReviewPostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookEpisodeReviewPostEdge>>() => T;
  aggregate: <T = AggregateBookEpisodeReviewPostPromise>() => T;
}

export interface BookEpisodeReviewPostConnectionSubscription
  extends Promise<AsyncIterator<BookEpisodeReviewPostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<BookEpisodeReviewPostEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateBookEpisodeReviewPostSubscription>() => T;
}

export interface BookEpisodeReviewPostEdge {
  node: BookEpisodeReviewPost;
  cursor: String;
}

export interface BookEpisodeReviewPostEdgePromise
  extends Promise<BookEpisodeReviewPostEdge>,
    Fragmentable {
  node: <T = BookEpisodeReviewPostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookEpisodeReviewPostEdgeSubscription
  extends Promise<AsyncIterator<BookEpisodeReviewPostEdge>>,
    Fragmentable {
  node: <T = BookEpisodeReviewPostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookEpisodeReviewPost {
  count: Int;
}

export interface AggregateBookEpisodeReviewPostPromise
  extends Promise<AggregateBookEpisodeReviewPost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookEpisodeReviewPostSubscription
  extends Promise<AsyncIterator<AggregateBookEpisodeReviewPost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookRecommended {
  id: ID_Output;
  weight: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookRecommendedPromise
  extends Promise<BookRecommended>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  book: <T = BookPromise>() => T;
  weight: () => Promise<Int>;
  publishTimeline: <T = PublishTimelinePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookRecommendedSubscription
  extends Promise<AsyncIterator<BookRecommended>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  book: <T = BookSubscription>() => T;
  weight: () => Promise<AsyncIterator<Int>>;
  publishTimeline: <T = PublishTimelineSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookRecommendedConnection {
  pageInfo: PageInfo;
  edges: BookRecommendedEdge[];
}

export interface BookRecommendedConnectionPromise
  extends Promise<BookRecommendedConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookRecommendedEdge>>() => T;
  aggregate: <T = AggregateBookRecommendedPromise>() => T;
}

export interface BookRecommendedConnectionSubscription
  extends Promise<AsyncIterator<BookRecommendedConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookRecommendedEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookRecommendedSubscription>() => T;
}

export interface BookRecommendedEdge {
  node: BookRecommended;
  cursor: String;
}

export interface BookRecommendedEdgePromise
  extends Promise<BookRecommendedEdge>,
    Fragmentable {
  node: <T = BookRecommendedPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookRecommendedEdgeSubscription
  extends Promise<AsyncIterator<BookRecommendedEdge>>,
    Fragmentable {
  node: <T = BookRecommendedSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookRecommended {
  count: Int;
}

export interface AggregateBookRecommendedPromise
  extends Promise<AggregateBookRecommended>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookRecommendedSubscription
  extends Promise<AsyncIterator<AggregateBookRecommended>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookVolumeConnection {
  pageInfo: PageInfo;
  edges: BookVolumeEdge[];
}

export interface BookVolumeConnectionPromise
  extends Promise<BookVolumeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookVolumeEdge>>() => T;
  aggregate: <T = AggregateBookVolumePromise>() => T;
}

export interface BookVolumeConnectionSubscription
  extends Promise<AsyncIterator<BookVolumeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookVolumeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookVolumeSubscription>() => T;
}

export interface BookVolumeEdge {
  node: BookVolume;
  cursor: String;
}

export interface BookVolumeEdgePromise
  extends Promise<BookVolumeEdge>,
    Fragmentable {
  node: <T = BookVolumePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookVolumeEdgeSubscription
  extends Promise<AsyncIterator<BookVolumeEdge>>,
    Fragmentable {
  node: <T = BookVolumeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBookVolume {
  count: Int;
}

export interface AggregateBookVolumePromise
  extends Promise<AggregateBookVolume>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookVolumeSubscription
  extends Promise<AsyncIterator<AggregateBookVolume>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CopyrightHolderConnection {
  pageInfo: PageInfo;
  edges: CopyrightHolderEdge[];
}

export interface CopyrightHolderConnectionPromise
  extends Promise<CopyrightHolderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CopyrightHolderEdge>>() => T;
  aggregate: <T = AggregateCopyrightHolderPromise>() => T;
}

export interface CopyrightHolderConnectionSubscription
  extends Promise<AsyncIterator<CopyrightHolderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CopyrightHolderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCopyrightHolderSubscription>() => T;
}

export interface CopyrightHolderEdge {
  node: CopyrightHolder;
  cursor: String;
}

export interface CopyrightHolderEdgePromise
  extends Promise<CopyrightHolderEdge>,
    Fragmentable {
  node: <T = CopyrightHolderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CopyrightHolderEdgeSubscription
  extends Promise<AsyncIterator<CopyrightHolderEdge>>,
    Fragmentable {
  node: <T = CopyrightHolderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCopyrightHolder {
  count: Int;
}

export interface AggregateCopyrightHolderPromise
  extends Promise<AggregateCopyrightHolder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCopyrightHolderSubscription
  extends Promise<AsyncIterator<AggregateCopyrightHolder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DashbardDataCache {
  queryName: String;
  arguments?: String;
  result: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DashbardDataCachePromise
  extends Promise<DashbardDataCache>,
    Fragmentable {
  queryName: () => Promise<String>;
  arguments: () => Promise<String>;
  result: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DashbardDataCacheSubscription
  extends Promise<AsyncIterator<DashbardDataCache>>,
    Fragmentable {
  queryName: () => Promise<AsyncIterator<String>>;
  arguments: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DashbardDataCacheConnection {
  pageInfo: PageInfo;
  edges: DashbardDataCacheEdge[];
}

export interface DashbardDataCacheConnectionPromise
  extends Promise<DashbardDataCacheConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DashbardDataCacheEdge>>() => T;
  aggregate: <T = AggregateDashbardDataCachePromise>() => T;
}

export interface DashbardDataCacheConnectionSubscription
  extends Promise<AsyncIterator<DashbardDataCacheConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DashbardDataCacheEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDashbardDataCacheSubscription>() => T;
}

export interface DashbardDataCacheEdge {
  node: DashbardDataCache;
  cursor: String;
}

export interface DashbardDataCacheEdgePromise
  extends Promise<DashbardDataCacheEdge>,
    Fragmentable {
  node: <T = DashbardDataCachePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DashbardDataCacheEdgeSubscription
  extends Promise<AsyncIterator<DashbardDataCacheEdge>>,
    Fragmentable {
  node: <T = DashbardDataCacheSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDashbardDataCache {
  count: Int;
}

export interface AggregateDashbardDataCachePromise
  extends Promise<AggregateDashbardDataCache>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDashbardDataCacheSubscription
  extends Promise<AsyncIterator<AggregateDashbardDataCache>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DocumentConnection {
  pageInfo: PageInfo;
  edges: DocumentEdge[];
}

export interface DocumentConnectionPromise
  extends Promise<DocumentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DocumentEdge>>() => T;
  aggregate: <T = AggregateDocumentPromise>() => T;
}

export interface DocumentConnectionSubscription
  extends Promise<AsyncIterator<DocumentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DocumentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDocumentSubscription>() => T;
}

export interface DocumentEdge {
  node: Document;
  cursor: String;
}

export interface DocumentEdgePromise
  extends Promise<DocumentEdge>,
    Fragmentable {
  node: <T = DocumentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DocumentEdgeSubscription
  extends Promise<AsyncIterator<DocumentEdge>>,
    Fragmentable {
  node: <T = DocumentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDocument {
  count: Int;
}

export interface AggregateDocumentPromise
  extends Promise<AggregateDocument>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDocumentSubscription
  extends Promise<AsyncIterator<AggregateDocument>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExchangeTierConnection {
  pageInfo: PageInfo;
  edges: ExchangeTierEdge[];
}

export interface ExchangeTierConnectionPromise
  extends Promise<ExchangeTierConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExchangeTierEdge>>() => T;
  aggregate: <T = AggregateExchangeTierPromise>() => T;
}

export interface ExchangeTierConnectionSubscription
  extends Promise<AsyncIterator<ExchangeTierConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExchangeTierEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExchangeTierSubscription>() => T;
}

export interface ExchangeTierEdge {
  node: ExchangeTier;
  cursor: String;
}

export interface ExchangeTierEdgePromise
  extends Promise<ExchangeTierEdge>,
    Fragmentable {
  node: <T = ExchangeTierPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExchangeTierEdgeSubscription
  extends Promise<AsyncIterator<ExchangeTierEdge>>,
    Fragmentable {
  node: <T = ExchangeTierSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExchangeTier {
  count: Int;
}

export interface AggregateExchangeTierPromise
  extends Promise<AggregateExchangeTier>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExchangeTierSubscription
  extends Promise<AsyncIterator<AggregateExchangeTier>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExchangeTransactionConnection {
  pageInfo: PageInfo;
  edges: ExchangeTransactionEdge[];
}

export interface ExchangeTransactionConnectionPromise
  extends Promise<ExchangeTransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExchangeTransactionEdge>>() => T;
  aggregate: <T = AggregateExchangeTransactionPromise>() => T;
}

export interface ExchangeTransactionConnectionSubscription
  extends Promise<AsyncIterator<ExchangeTransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExchangeTransactionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExchangeTransactionSubscription>() => T;
}

export interface ExchangeTransactionEdge {
  node: ExchangeTransaction;
  cursor: String;
}

export interface ExchangeTransactionEdgePromise
  extends Promise<ExchangeTransactionEdge>,
    Fragmentable {
  node: <T = ExchangeTransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExchangeTransactionEdgeSubscription
  extends Promise<AsyncIterator<ExchangeTransactionEdge>>,
    Fragmentable {
  node: <T = ExchangeTransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExchangeTransaction {
  count: Int;
}

export interface AggregateExchangeTransactionPromise
  extends Promise<AggregateExchangeTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExchangeTransactionSubscription
  extends Promise<AsyncIterator<AggregateExchangeTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExchangeTransactionStatusHistoryConnection {
  pageInfo: PageInfo;
  edges: ExchangeTransactionStatusHistoryEdge[];
}

export interface ExchangeTransactionStatusHistoryConnectionPromise
  extends Promise<ExchangeTransactionStatusHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExchangeTransactionStatusHistoryEdge>>() => T;
  aggregate: <T = AggregateExchangeTransactionStatusHistoryPromise>() => T;
}

export interface ExchangeTransactionStatusHistoryConnectionSubscription
  extends Promise<AsyncIterator<ExchangeTransactionStatusHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExchangeTransactionStatusHistoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExchangeTransactionStatusHistorySubscription>() => T;
}

export interface ExchangeTransactionStatusHistoryEdge {
  node: ExchangeTransactionStatusHistory;
  cursor: String;
}

export interface ExchangeTransactionStatusHistoryEdgePromise
  extends Promise<ExchangeTransactionStatusHistoryEdge>,
    Fragmentable {
  node: <T = ExchangeTransactionStatusHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExchangeTransactionStatusHistoryEdgeSubscription
  extends Promise<AsyncIterator<ExchangeTransactionStatusHistoryEdge>>,
    Fragmentable {
  node: <T = ExchangeTransactionStatusHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExchangeTransactionStatusHistory {
  count: Int;
}

export interface AggregateExchangeTransactionStatusHistoryPromise
  extends Promise<AggregateExchangeTransactionStatusHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExchangeTransactionStatusHistorySubscription
  extends Promise<AsyncIterator<AggregateExchangeTransactionStatusHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface History {
  id: ID_Output;
  payload?: Json;
  mutationName: String;
  updateBy: String;
}

export interface HistoryPromise extends Promise<History>, Fragmentable {
  id: () => Promise<ID_Output>;
  payload: () => Promise<Json>;
  mutationName: () => Promise<String>;
  updateBy: () => Promise<String>;
}

export interface HistorySubscription
  extends Promise<AsyncIterator<History>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payload: () => Promise<AsyncIterator<Json>>;
  mutationName: () => Promise<AsyncIterator<String>>;
  updateBy: () => Promise<AsyncIterator<String>>;
}

export interface HistoryConnection {
  pageInfo: PageInfo;
  edges: HistoryEdge[];
}

export interface HistoryConnectionPromise
  extends Promise<HistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HistoryEdge>>() => T;
  aggregate: <T = AggregateHistoryPromise>() => T;
}

export interface HistoryConnectionSubscription
  extends Promise<AsyncIterator<HistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HistoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHistorySubscription>() => T;
}

export interface HistoryEdge {
  node: History;
  cursor: String;
}

export interface HistoryEdgePromise extends Promise<HistoryEdge>, Fragmentable {
  node: <T = HistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HistoryEdgeSubscription
  extends Promise<AsyncIterator<HistoryEdge>>,
    Fragmentable {
  node: <T = HistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHistory {
  count: Int;
}

export interface AggregateHistoryPromise
  extends Promise<AggregateHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHistorySubscription
  extends Promise<AsyncIterator<AggregateHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemAssetConnection {
  pageInfo: PageInfo;
  edges: ItemAssetEdge[];
}

export interface ItemAssetConnectionPromise
  extends Promise<ItemAssetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemAssetEdge>>() => T;
  aggregate: <T = AggregateItemAssetPromise>() => T;
}

export interface ItemAssetConnectionSubscription
  extends Promise<AsyncIterator<ItemAssetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemAssetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemAssetSubscription>() => T;
}

export interface ItemAssetEdge {
  node: ItemAsset;
  cursor: String;
}

export interface ItemAssetEdgePromise
  extends Promise<ItemAssetEdge>,
    Fragmentable {
  node: <T = ItemAssetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemAssetEdgeSubscription
  extends Promise<AsyncIterator<ItemAssetEdge>>,
    Fragmentable {
  node: <T = ItemAssetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItemAsset {
  count: Int;
}

export interface AggregateItemAssetPromise
  extends Promise<AggregateItemAsset>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemAssetSubscription
  extends Promise<AsyncIterator<AggregateItemAsset>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Migration {
  id: ID_Output;
  num: Int;
}

export interface MigrationPromise extends Promise<Migration>, Fragmentable {
  id: () => Promise<ID_Output>;
  num: () => Promise<Int>;
}

export interface MigrationSubscription
  extends Promise<AsyncIterator<Migration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  num: () => Promise<AsyncIterator<Int>>;
}

export interface MigrationConnection {
  pageInfo: PageInfo;
  edges: MigrationEdge[];
}

export interface MigrationConnectionPromise
  extends Promise<MigrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MigrationEdge>>() => T;
  aggregate: <T = AggregateMigrationPromise>() => T;
}

export interface MigrationConnectionSubscription
  extends Promise<AsyncIterator<MigrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MigrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMigrationSubscription>() => T;
}

export interface MigrationEdge {
  node: Migration;
  cursor: String;
}

export interface MigrationEdgePromise
  extends Promise<MigrationEdge>,
    Fragmentable {
  node: <T = MigrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MigrationEdgeSubscription
  extends Promise<AsyncIterator<MigrationEdge>>,
    Fragmentable {
  node: <T = MigrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMigration {
  count: Int;
}

export interface AggregateMigrationPromise
  extends Promise<AggregateMigration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMigrationSubscription
  extends Promise<AsyncIterator<AggregateMigration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageViewConnection {
  pageInfo: PageInfo;
  edges: PageViewEdge[];
}

export interface PageViewConnectionPromise
  extends Promise<PageViewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PageViewEdge>>() => T;
  aggregate: <T = AggregatePageViewPromise>() => T;
}

export interface PageViewConnectionSubscription
  extends Promise<AsyncIterator<PageViewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PageViewEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePageViewSubscription>() => T;
}

export interface PageViewEdge {
  node: PageView;
  cursor: String;
}

export interface PageViewEdgePromise
  extends Promise<PageViewEdge>,
    Fragmentable {
  node: <T = PageViewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PageViewEdgeSubscription
  extends Promise<AsyncIterator<PageViewEdge>>,
    Fragmentable {
  node: <T = PageViewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePageView {
  count: Int;
}

export interface AggregatePageViewPromise
  extends Promise<AggregatePageView>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePageViewSubscription
  extends Promise<AsyncIterator<AggregatePageView>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PriceConnection {
  pageInfo: PageInfo;
  edges: PriceEdge[];
}

export interface PriceConnectionPromise
  extends Promise<PriceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PriceEdge>>() => T;
  aggregate: <T = AggregatePricePromise>() => T;
}

export interface PriceConnectionSubscription
  extends Promise<AsyncIterator<PriceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PriceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePriceSubscription>() => T;
}

export interface PriceEdge {
  node: Price;
  cursor: String;
}

export interface PriceEdgePromise extends Promise<PriceEdge>, Fragmentable {
  node: <T = PricePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PriceEdgeSubscription
  extends Promise<AsyncIterator<PriceEdge>>,
    Fragmentable {
  node: <T = PriceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePrice {
  count: Int;
}

export interface AggregatePricePromise
  extends Promise<AggregatePrice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePriceSubscription
  extends Promise<AsyncIterator<AggregatePrice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PromotionConnection {
  pageInfo: PageInfo;
  edges: PromotionEdge[];
}

export interface PromotionConnectionPromise
  extends Promise<PromotionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PromotionEdge>>() => T;
  aggregate: <T = AggregatePromotionPromise>() => T;
}

export interface PromotionConnectionSubscription
  extends Promise<AsyncIterator<PromotionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PromotionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePromotionSubscription>() => T;
}

export interface PromotionEdge {
  node: Promotion;
  cursor: String;
}

export interface PromotionEdgePromise
  extends Promise<PromotionEdge>,
    Fragmentable {
  node: <T = PromotionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PromotionEdgeSubscription
  extends Promise<AsyncIterator<PromotionEdge>>,
    Fragmentable {
  node: <T = PromotionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePromotion {
  count: Int;
}

export interface AggregatePromotionPromise
  extends Promise<AggregatePromotion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePromotionSubscription
  extends Promise<AsyncIterator<AggregatePromotion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PublishTimelineConnection {
  pageInfo: PageInfo;
  edges: PublishTimelineEdge[];
}

export interface PublishTimelineConnectionPromise
  extends Promise<PublishTimelineConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PublishTimelineEdge>>() => T;
  aggregate: <T = AggregatePublishTimelinePromise>() => T;
}

export interface PublishTimelineConnectionSubscription
  extends Promise<AsyncIterator<PublishTimelineConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PublishTimelineEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePublishTimelineSubscription>() => T;
}

export interface PublishTimelineEdge {
  node: PublishTimeline;
  cursor: String;
}

export interface PublishTimelineEdgePromise
  extends Promise<PublishTimelineEdge>,
    Fragmentable {
  node: <T = PublishTimelinePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PublishTimelineEdgeSubscription
  extends Promise<AsyncIterator<PublishTimelineEdge>>,
    Fragmentable {
  node: <T = PublishTimelineSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePublishTimeline {
  count: Int;
}

export interface AggregatePublishTimelinePromise
  extends Promise<AggregatePublishTimeline>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePublishTimelineSubscription
  extends Promise<AsyncIterator<AggregatePublishTimeline>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RemoteConfig {
  id: ID_Output;
  name?: String;
  landing: Boolean;
}

export interface RemoteConfigPromise
  extends Promise<RemoteConfig>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  landing: () => Promise<Boolean>;
}

export interface RemoteConfigSubscription
  extends Promise<AsyncIterator<RemoteConfig>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  landing: () => Promise<AsyncIterator<Boolean>>;
}

export interface RemoteConfigConnection {
  pageInfo: PageInfo;
  edges: RemoteConfigEdge[];
}

export interface RemoteConfigConnectionPromise
  extends Promise<RemoteConfigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RemoteConfigEdge>>() => T;
  aggregate: <T = AggregateRemoteConfigPromise>() => T;
}

export interface RemoteConfigConnectionSubscription
  extends Promise<AsyncIterator<RemoteConfigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RemoteConfigEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRemoteConfigSubscription>() => T;
}

export interface RemoteConfigEdge {
  node: RemoteConfig;
  cursor: String;
}

export interface RemoteConfigEdgePromise
  extends Promise<RemoteConfigEdge>,
    Fragmentable {
  node: <T = RemoteConfigPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RemoteConfigEdgeSubscription
  extends Promise<AsyncIterator<RemoteConfigEdge>>,
    Fragmentable {
  node: <T = RemoteConfigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRemoteConfig {
  count: Int;
}

export interface AggregateRemoteConfigPromise
  extends Promise<AggregateRemoteConfig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRemoteConfigSubscription
  extends Promise<AsyncIterator<AggregateRemoteConfig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RevenueSharingConnection {
  pageInfo: PageInfo;
  edges: RevenueSharingEdge[];
}

export interface RevenueSharingConnectionPromise
  extends Promise<RevenueSharingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RevenueSharingEdge>>() => T;
  aggregate: <T = AggregateRevenueSharingPromise>() => T;
}

export interface RevenueSharingConnectionSubscription
  extends Promise<AsyncIterator<RevenueSharingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RevenueSharingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRevenueSharingSubscription>() => T;
}

export interface RevenueSharingEdge {
  node: RevenueSharing;
  cursor: String;
}

export interface RevenueSharingEdgePromise
  extends Promise<RevenueSharingEdge>,
    Fragmentable {
  node: <T = RevenueSharingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RevenueSharingEdgeSubscription
  extends Promise<AsyncIterator<RevenueSharingEdge>>,
    Fragmentable {
  node: <T = RevenueSharingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRevenueSharing {
  count: Int;
}

export interface AggregateRevenueSharingPromise
  extends Promise<AggregateRevenueSharing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRevenueSharingSubscription
  extends Promise<AsyncIterator<AggregateRevenueSharing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Shelf {
  id: ID_Output;
  type: ShelfType;
}

export interface ShelfPromise extends Promise<Shelf>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ShelfType>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
}

export interface ShelfSubscription
  extends Promise<AsyncIterator<Shelf>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ShelfType>>;
  user: <T = UserSubscription>() => T;
  book: <T = BookSubscription>() => T;
}

export interface ShelfConnection {
  pageInfo: PageInfo;
  edges: ShelfEdge[];
}

export interface ShelfConnectionPromise
  extends Promise<ShelfConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShelfEdge>>() => T;
  aggregate: <T = AggregateShelfPromise>() => T;
}

export interface ShelfConnectionSubscription
  extends Promise<AsyncIterator<ShelfConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShelfEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShelfSubscription>() => T;
}

export interface ShelfEdge {
  node: Shelf;
  cursor: String;
}

export interface ShelfEdgePromise extends Promise<ShelfEdge>, Fragmentable {
  node: <T = ShelfPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShelfEdgeSubscription
  extends Promise<AsyncIterator<ShelfEdge>>,
    Fragmentable {
  node: <T = ShelfSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShelf {
  count: Int;
}

export interface AggregateShelfPromise
  extends Promise<AggregateShelf>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShelfSubscription
  extends Promise<AsyncIterator<AggregateShelf>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SystemConfig {
  id: ID_Output;
  name: String;
  value?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SystemConfigPromise
  extends Promise<SystemConfig>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SystemConfigSubscription
  extends Promise<AsyncIterator<SystemConfig>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SystemConfigConnection {
  pageInfo: PageInfo;
  edges: SystemConfigEdge[];
}

export interface SystemConfigConnectionPromise
  extends Promise<SystemConfigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SystemConfigEdge>>() => T;
  aggregate: <T = AggregateSystemConfigPromise>() => T;
}

export interface SystemConfigConnectionSubscription
  extends Promise<AsyncIterator<SystemConfigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SystemConfigEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSystemConfigSubscription>() => T;
}

export interface SystemConfigEdge {
  node: SystemConfig;
  cursor: String;
}

export interface SystemConfigEdgePromise
  extends Promise<SystemConfigEdge>,
    Fragmentable {
  node: <T = SystemConfigPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SystemConfigEdgeSubscription
  extends Promise<AsyncIterator<SystemConfigEdge>>,
    Fragmentable {
  node: <T = SystemConfigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSystemConfig {
  count: Int;
}

export interface AggregateSystemConfigPromise
  extends Promise<AggregateSystemConfig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSystemConfigSubscription
  extends Promise<AsyncIterator<AggregateSystemConfig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TranslatorConnection {
  pageInfo: PageInfo;
  edges: TranslatorEdge[];
}

export interface TranslatorConnectionPromise
  extends Promise<TranslatorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TranslatorEdge>>() => T;
  aggregate: <T = AggregateTranslatorPromise>() => T;
}

export interface TranslatorConnectionSubscription
  extends Promise<AsyncIterator<TranslatorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TranslatorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTranslatorSubscription>() => T;
}

export interface TranslatorEdge {
  node: Translator;
  cursor: String;
}

export interface TranslatorEdgePromise
  extends Promise<TranslatorEdge>,
    Fragmentable {
  node: <T = TranslatorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TranslatorEdgeSubscription
  extends Promise<AsyncIterator<TranslatorEdge>>,
    Fragmentable {
  node: <T = TranslatorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTranslator {
  count: Int;
}

export interface AggregateTranslatorPromise
  extends Promise<AggregateTranslator>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTranslatorSubscription
  extends Promise<AsyncIterator<AggregateTranslator>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserAdmin {
  id: ID_Output;
  email?: String;
  hashedPassword?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserAdminPromise extends Promise<UserAdmin>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  hashedPassword: () => Promise<String>;
  roles: <T = FragmentableArray<UserAdminRole>>(
    args?: {
      where?: UserAdminRoleWhereInput;
      orderBy?: UserAdminRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAdminSubscription
  extends Promise<AsyncIterator<UserAdmin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  hashedPassword: () => Promise<AsyncIterator<String>>;
  roles: <T = Promise<AsyncIterator<UserAdminRoleSubscription>>>(
    args?: {
      where?: UserAdminRoleWhereInput;
      orderBy?: UserAdminRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserAdminRole {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserAdminRolePromise
  extends Promise<UserAdminRole>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  permissions: <T = FragmentableArray<UserAdminPermission>>(
    args?: {
      where?: UserAdminPermissionWhereInput;
      orderBy?: UserAdminPermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAdminRoleSubscription
  extends Promise<AsyncIterator<UserAdminRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  permissions: <T = Promise<AsyncIterator<UserAdminPermissionSubscription>>>(
    args?: {
      where?: UserAdminPermissionWhereInput;
      orderBy?: UserAdminPermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserAdminPermission {
  id: ID_Output;
  type: String;
  resource?: String;
}

export interface UserAdminPermissionPromise
  extends Promise<UserAdminPermission>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  resource: () => Promise<String>;
}

export interface UserAdminPermissionSubscription
  extends Promise<AsyncIterator<UserAdminPermission>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  resource: () => Promise<AsyncIterator<String>>;
}

export interface UserAdminConnection {
  pageInfo: PageInfo;
  edges: UserAdminEdge[];
}

export interface UserAdminConnectionPromise
  extends Promise<UserAdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserAdminEdge>>() => T;
  aggregate: <T = AggregateUserAdminPromise>() => T;
}

export interface UserAdminConnectionSubscription
  extends Promise<AsyncIterator<UserAdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserAdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserAdminSubscription>() => T;
}

export interface UserAdminEdge {
  node: UserAdmin;
  cursor: String;
}

export interface UserAdminEdgePromise
  extends Promise<UserAdminEdge>,
    Fragmentable {
  node: <T = UserAdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserAdminEdgeSubscription
  extends Promise<AsyncIterator<UserAdminEdge>>,
    Fragmentable {
  node: <T = UserAdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserAdmin {
  count: Int;
}

export interface AggregateUserAdminPromise
  extends Promise<AggregateUserAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserAdminSubscription
  extends Promise<AsyncIterator<AggregateUserAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserAdminPermissionConnection {
  pageInfo: PageInfo;
  edges: UserAdminPermissionEdge[];
}

export interface UserAdminPermissionConnectionPromise
  extends Promise<UserAdminPermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserAdminPermissionEdge>>() => T;
  aggregate: <T = AggregateUserAdminPermissionPromise>() => T;
}

export interface UserAdminPermissionConnectionSubscription
  extends Promise<AsyncIterator<UserAdminPermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserAdminPermissionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserAdminPermissionSubscription>() => T;
}

export interface UserAdminPermissionEdge {
  node: UserAdminPermission;
  cursor: String;
}

export interface UserAdminPermissionEdgePromise
  extends Promise<UserAdminPermissionEdge>,
    Fragmentable {
  node: <T = UserAdminPermissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserAdminPermissionEdgeSubscription
  extends Promise<AsyncIterator<UserAdminPermissionEdge>>,
    Fragmentable {
  node: <T = UserAdminPermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserAdminPermission {
  count: Int;
}

export interface AggregateUserAdminPermissionPromise
  extends Promise<AggregateUserAdminPermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserAdminPermissionSubscription
  extends Promise<AsyncIterator<AggregateUserAdminPermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserAdminRoleConnection {
  pageInfo: PageInfo;
  edges: UserAdminRoleEdge[];
}

export interface UserAdminRoleConnectionPromise
  extends Promise<UserAdminRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserAdminRoleEdge>>() => T;
  aggregate: <T = AggregateUserAdminRolePromise>() => T;
}

export interface UserAdminRoleConnectionSubscription
  extends Promise<AsyncIterator<UserAdminRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserAdminRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserAdminRoleSubscription>() => T;
}

export interface UserAdminRoleEdge {
  node: UserAdminRole;
  cursor: String;
}

export interface UserAdminRoleEdgePromise
  extends Promise<UserAdminRoleEdge>,
    Fragmentable {
  node: <T = UserAdminRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserAdminRoleEdgeSubscription
  extends Promise<AsyncIterator<UserAdminRoleEdge>>,
    Fragmentable {
  node: <T = UserAdminRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserAdminRole {
  count: Int;
}

export interface AggregateUserAdminRolePromise
  extends Promise<AggregateUserAdminRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserAdminRoleSubscription
  extends Promise<AsyncIterator<AggregateUserAdminRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VendorConnection {
  pageInfo: PageInfo;
  edges: VendorEdge[];
}

export interface VendorConnectionPromise
  extends Promise<VendorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VendorEdge>>() => T;
  aggregate: <T = AggregateVendorPromise>() => T;
}

export interface VendorConnectionSubscription
  extends Promise<AsyncIterator<VendorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VendorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVendorSubscription>() => T;
}

export interface VendorEdge {
  node: Vendor;
  cursor: String;
}

export interface VendorEdgePromise extends Promise<VendorEdge>, Fragmentable {
  node: <T = VendorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VendorEdgeSubscription
  extends Promise<AsyncIterator<VendorEdge>>,
    Fragmentable {
  node: <T = VendorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVendor {
  count: Int;
}

export interface AggregateVendorPromise
  extends Promise<AggregateVendor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVendorSubscription
  extends Promise<AsyncIterator<AggregateVendor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VendorBillingInformationConnection {
  pageInfo: PageInfo;
  edges: VendorBillingInformationEdge[];
}

export interface VendorBillingInformationConnectionPromise
  extends Promise<VendorBillingInformationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VendorBillingInformationEdge>>() => T;
  aggregate: <T = AggregateVendorBillingInformationPromise>() => T;
}

export interface VendorBillingInformationConnectionSubscription
  extends Promise<AsyncIterator<VendorBillingInformationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<VendorBillingInformationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateVendorBillingInformationSubscription>() => T;
}

export interface VendorBillingInformationEdge {
  node: VendorBillingInformation;
  cursor: String;
}

export interface VendorBillingInformationEdgePromise
  extends Promise<VendorBillingInformationEdge>,
    Fragmentable {
  node: <T = VendorBillingInformationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VendorBillingInformationEdgeSubscription
  extends Promise<AsyncIterator<VendorBillingInformationEdge>>,
    Fragmentable {
  node: <T = VendorBillingInformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVendorBillingInformation {
  count: Int;
}

export interface AggregateVendorBillingInformationPromise
  extends Promise<AggregateVendorBillingInformation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVendorBillingInformationSubscription
  extends Promise<AsyncIterator<AggregateVendorBillingInformation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VendorRevenueConnection {
  pageInfo: PageInfo;
  edges: VendorRevenueEdge[];
}

export interface VendorRevenueConnectionPromise
  extends Promise<VendorRevenueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VendorRevenueEdge>>() => T;
  aggregate: <T = AggregateVendorRevenuePromise>() => T;
}

export interface VendorRevenueConnectionSubscription
  extends Promise<AsyncIterator<VendorRevenueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VendorRevenueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVendorRevenueSubscription>() => T;
}

export interface VendorRevenueEdge {
  node: VendorRevenue;
  cursor: String;
}

export interface VendorRevenueEdgePromise
  extends Promise<VendorRevenueEdge>,
    Fragmentable {
  node: <T = VendorRevenuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VendorRevenueEdgeSubscription
  extends Promise<AsyncIterator<VendorRevenueEdge>>,
    Fragmentable {
  node: <T = VendorRevenueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVendorRevenue {
  count: Int;
}

export interface AggregateVendorRevenuePromise
  extends Promise<AggregateVendorRevenue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVendorRevenueSubscription
  extends Promise<AsyncIterator<AggregateVendorRevenue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AdsBannerSubscriptionPayload {
  mutation: MutationType;
  node: AdsBanner;
  updatedFields: String[];
  previousValues: AdsBannerPreviousValues;
}

export interface AdsBannerSubscriptionPayloadPromise
  extends Promise<AdsBannerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdsBannerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdsBannerPreviousValuesPromise>() => T;
}

export interface AdsBannerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdsBannerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdsBannerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdsBannerPreviousValuesSubscription>() => T;
}

export interface AdsBannerPreviousValues {
  id: ID_Output;
  name?: String;
  order?: Float;
  altTag?: String;
  backgroundColor?: String;
  url?: String;
  page?: String;
  position?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AdsBannerPreviousValuesPromise
  extends Promise<AdsBannerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Float>;
  altTag: () => Promise<String>;
  backgroundColor: () => Promise<String>;
  url: () => Promise<String>;
  page: () => Promise<String>;
  position: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AdsBannerPreviousValuesSubscription
  extends Promise<AsyncIterator<AdsBannerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Float>>;
  altTag: () => Promise<AsyncIterator<String>>;
  backgroundColor: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  page: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AuthorSubscriptionPayload {
  mutation: MutationType;
  node: Author;
  updatedFields: String[];
  previousValues: AuthorPreviousValues;
}

export interface AuthorSubscriptionPayloadPromise
  extends Promise<AuthorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthorPreviousValuesPromise>() => T;
}

export interface AuthorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthorPreviousValuesSubscription>() => T;
}

export interface AuthorPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AuthorPreviousValuesPromise
  extends Promise<AuthorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AuthorPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BehaviorSubscriptionPayload {
  mutation: MutationType;
  node: Behavior;
  updatedFields: String[];
  previousValues: BehaviorPreviousValues;
}

export interface BehaviorSubscriptionPayloadPromise
  extends Promise<BehaviorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BehaviorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BehaviorPreviousValuesPromise>() => T;
}

export interface BehaviorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BehaviorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BehaviorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BehaviorPreviousValuesSubscription>() => T;
}

export interface BehaviorPreviousValues {
  id: ID_Output;
  ip: String;
  action: String;
  payload: Json;
  createdAt: DateTimeOutput;
}

export interface BehaviorPreviousValuesPromise
  extends Promise<BehaviorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ip: () => Promise<String>;
  action: () => Promise<String>;
  payload: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BehaviorPreviousValuesSubscription
  extends Promise<AsyncIterator<BehaviorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ip: () => Promise<AsyncIterator<String>>;
  action: () => Promise<AsyncIterator<String>>;
  payload: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookSubscriptionPayload {
  mutation: MutationType;
  node: Book;
  updatedFields: String[];
  previousValues: BookPreviousValues;
}

export interface BookSubscriptionPayloadPromise
  extends Promise<BookSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookPreviousValuesPromise>() => T;
}

export interface BookSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookPreviousValuesSubscription>() => T;
}

export interface BookPreviousValues {
  id: ID_Output;
  slug?: String;
  name: String;
  introduction: Json;
  synopsis?: String;
  isPublished: Boolean;
  publishedAt?: DateTimeOutput;
  isUnlisted?: Boolean;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookPreviousValuesPromise
  extends Promise<BookPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  introduction: () => Promise<Json>;
  synopsis: () => Promise<String>;
  isPublished: () => Promise<Boolean>;
  publishedAt: () => Promise<DateTimeOutput>;
  isUnlisted: () => Promise<Boolean>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
  metaKeyword: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookPreviousValuesSubscription
  extends Promise<AsyncIterator<BookPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  introduction: () => Promise<AsyncIterator<Json>>;
  synopsis: () => Promise<AsyncIterator<String>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isUnlisted: () => Promise<AsyncIterator<Boolean>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  metaKeyword: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookEpisodeSubscriptionPayload {
  mutation: MutationType;
  node: BookEpisode;
  updatedFields: String[];
  previousValues: BookEpisodePreviousValues;
}

export interface BookEpisodeSubscriptionPayloadPromise
  extends Promise<BookEpisodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookEpisodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookEpisodePreviousValuesPromise>() => T;
}

export interface BookEpisodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookEpisodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookEpisodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookEpisodePreviousValuesSubscription>() => T;
}

export interface BookEpisodePreviousValues {
  id: ID_Output;
  slug?: String;
  isPublished: Boolean;
  publishedAt?: DateTimeOutput;
  isUnlisted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  metaTitle?: String;
  metaDescription?: String;
  metaKeyword?: String;
}

export interface BookEpisodePreviousValuesPromise
  extends Promise<BookEpisodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  isPublished: () => Promise<Boolean>;
  publishedAt: () => Promise<DateTimeOutput>;
  isUnlisted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  metaTitle: () => Promise<String>;
  metaDescription: () => Promise<String>;
  metaKeyword: () => Promise<String>;
}

export interface BookEpisodePreviousValuesSubscription
  extends Promise<AsyncIterator<BookEpisodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isUnlisted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  metaTitle: () => Promise<AsyncIterator<String>>;
  metaDescription: () => Promise<AsyncIterator<String>>;
  metaKeyword: () => Promise<AsyncIterator<String>>;
}

export interface BookEpisodeContentSubscriptionPayload {
  mutation: MutationType;
  node: BookEpisodeContent;
  updatedFields: String[];
  previousValues: BookEpisodeContentPreviousValues;
}

export interface BookEpisodeContentSubscriptionPayloadPromise
  extends Promise<BookEpisodeContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookEpisodeContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookEpisodeContentPreviousValuesPromise>() => T;
}

export interface BookEpisodeContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookEpisodeContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookEpisodeContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookEpisodeContentPreviousValuesSubscription>() => T;
}

export interface BookEpisodeContentPreviousValues {
  id: ID_Output;
  title: String;
  draft?: Json;
}

export interface BookEpisodeContentPreviousValuesPromise
  extends Promise<BookEpisodeContentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  draft: () => Promise<Json>;
}

export interface BookEpisodeContentPreviousValuesSubscription
  extends Promise<AsyncIterator<BookEpisodeContentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  draft: () => Promise<AsyncIterator<Json>>;
}

export interface BookEpisodeRecentReadSubscriptionPayload {
  mutation: MutationType;
  node: BookEpisodeRecentRead;
  updatedFields: String[];
  previousValues: BookEpisodeRecentReadPreviousValues;
}

export interface BookEpisodeRecentReadSubscriptionPayloadPromise
  extends Promise<BookEpisodeRecentReadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookEpisodeRecentReadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookEpisodeRecentReadPreviousValuesPromise>() => T;
}

export interface BookEpisodeRecentReadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookEpisodeRecentReadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookEpisodeRecentReadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookEpisodeRecentReadPreviousValuesSubscription>() => T;
}

export interface BookEpisodeRecentReadPreviousValues {
  id: ID_Output;
  offsetKey: String;
  offsetRatio: Float;
}

export interface BookEpisodeRecentReadPreviousValuesPromise
  extends Promise<BookEpisodeRecentReadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  offsetKey: () => Promise<String>;
  offsetRatio: () => Promise<Float>;
}

export interface BookEpisodeRecentReadPreviousValuesSubscription
  extends Promise<AsyncIterator<BookEpisodeRecentReadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  offsetKey: () => Promise<AsyncIterator<String>>;
  offsetRatio: () => Promise<AsyncIterator<Float>>;
}

export interface BookEpisodeReviewPostSubscriptionPayload {
  mutation: MutationType;
  node: BookEpisodeReviewPost;
  updatedFields: String[];
  previousValues: BookEpisodeReviewPostPreviousValues;
}

export interface BookEpisodeReviewPostSubscriptionPayloadPromise
  extends Promise<BookEpisodeReviewPostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookEpisodeReviewPostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookEpisodeReviewPostPreviousValuesPromise>() => T;
}

export interface BookEpisodeReviewPostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookEpisodeReviewPostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookEpisodeReviewPostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookEpisodeReviewPostPreviousValuesSubscription>() => T;
}

export interface BookEpisodeReviewPostPreviousValues {
  id: ID_Output;
  rating: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookEpisodeReviewPostPreviousValuesPromise
  extends Promise<BookEpisodeReviewPostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  rating: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookEpisodeReviewPostPreviousValuesSubscription
  extends Promise<AsyncIterator<BookEpisodeReviewPostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  rating: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookRecommendedSubscriptionPayload {
  mutation: MutationType;
  node: BookRecommended;
  updatedFields: String[];
  previousValues: BookRecommendedPreviousValues;
}

export interface BookRecommendedSubscriptionPayloadPromise
  extends Promise<BookRecommendedSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookRecommendedPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookRecommendedPreviousValuesPromise>() => T;
}

export interface BookRecommendedSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookRecommendedSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookRecommendedSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookRecommendedPreviousValuesSubscription>() => T;
}

export interface BookRecommendedPreviousValues {
  id: ID_Output;
  weight: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookRecommendedPreviousValuesPromise
  extends Promise<BookRecommendedPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookRecommendedPreviousValuesSubscription
  extends Promise<AsyncIterator<BookRecommendedPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookVolumeSubscriptionPayload {
  mutation: MutationType;
  node: BookVolume;
  updatedFields: String[];
  previousValues: BookVolumePreviousValues;
}

export interface BookVolumeSubscriptionPayloadPromise
  extends Promise<BookVolumeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookVolumePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookVolumePreviousValuesPromise>() => T;
}

export interface BookVolumeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookVolumeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookVolumeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookVolumePreviousValuesSubscription>() => T;
}

export interface BookVolumePreviousValues {
  id: ID_Output;
  slug?: String;
  title: String;
  isPublished: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookVolumePreviousValuesPromise
  extends Promise<BookVolumePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  title: () => Promise<String>;
  isPublished: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookVolumePreviousValuesSubscription
  extends Promise<AsyncIterator<BookVolumePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CopyrightHolderSubscriptionPayload {
  mutation: MutationType;
  node: CopyrightHolder;
  updatedFields: String[];
  previousValues: CopyrightHolderPreviousValues;
}

export interface CopyrightHolderSubscriptionPayloadPromise
  extends Promise<CopyrightHolderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CopyrightHolderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CopyrightHolderPreviousValuesPromise>() => T;
}

export interface CopyrightHolderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CopyrightHolderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CopyrightHolderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CopyrightHolderPreviousValuesSubscription>() => T;
}

export interface CopyrightHolderPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CopyrightHolderPreviousValuesPromise
  extends Promise<CopyrightHolderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CopyrightHolderPreviousValuesSubscription
  extends Promise<AsyncIterator<CopyrightHolderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DashbardDataCacheSubscriptionPayload {
  mutation: MutationType;
  node: DashbardDataCache;
  updatedFields: String[];
  previousValues: DashbardDataCachePreviousValues;
}

export interface DashbardDataCacheSubscriptionPayloadPromise
  extends Promise<DashbardDataCacheSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DashbardDataCachePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DashbardDataCachePreviousValuesPromise>() => T;
}

export interface DashbardDataCacheSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DashbardDataCacheSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DashbardDataCacheSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DashbardDataCachePreviousValuesSubscription>() => T;
}

export interface DashbardDataCachePreviousValues {
  queryName: String;
  arguments?: String;
  result: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DashbardDataCachePreviousValuesPromise
  extends Promise<DashbardDataCachePreviousValues>,
    Fragmentable {
  queryName: () => Promise<String>;
  arguments: () => Promise<String>;
  result: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DashbardDataCachePreviousValuesSubscription
  extends Promise<AsyncIterator<DashbardDataCachePreviousValues>>,
    Fragmentable {
  queryName: () => Promise<AsyncIterator<String>>;
  arguments: () => Promise<AsyncIterator<String>>;
  result: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DocumentSubscriptionPayload {
  mutation: MutationType;
  node: Document;
  updatedFields: String[];
  previousValues: DocumentPreviousValues;
}

export interface DocumentSubscriptionPayloadPromise
  extends Promise<DocumentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DocumentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DocumentPreviousValuesPromise>() => T;
}

export interface DocumentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DocumentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DocumentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DocumentPreviousValuesSubscription>() => T;
}

export interface DocumentPreviousValues {
  id: ID_Output;
  type: DocumentType;
}

export interface DocumentPreviousValuesPromise
  extends Promise<DocumentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<DocumentType>;
}

export interface DocumentPreviousValuesSubscription
  extends Promise<AsyncIterator<DocumentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<DocumentType>>;
}

export interface ExchangeTierSubscriptionPayload {
  mutation: MutationType;
  node: ExchangeTier;
  updatedFields: String[];
  previousValues: ExchangeTierPreviousValues;
}

export interface ExchangeTierSubscriptionPayloadPromise
  extends Promise<ExchangeTierSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExchangeTierPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExchangeTierPreviousValuesPromise>() => T;
}

export interface ExchangeTierSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExchangeTierSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExchangeTierSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExchangeTierPreviousValuesSubscription>() => T;
}

export interface ExchangeTierPreviousValues {
  id: ID_Output;
  type: ExchangeType;
  name: String;
  currencyType: CurrencyType;
  income: Float;
  outcome: Float;
  isDefault: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ExchangeTierPreviousValuesPromise
  extends Promise<ExchangeTierPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ExchangeType>;
  name: () => Promise<String>;
  currencyType: () => Promise<CurrencyType>;
  income: () => Promise<Float>;
  outcome: () => Promise<Float>;
  isDefault: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ExchangeTierPreviousValuesSubscription
  extends Promise<AsyncIterator<ExchangeTierPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ExchangeType>>;
  name: () => Promise<AsyncIterator<String>>;
  currencyType: () => Promise<AsyncIterator<CurrencyType>>;
  income: () => Promise<AsyncIterator<Float>>;
  outcome: () => Promise<AsyncIterator<Float>>;
  isDefault: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExchangeTransactionSubscriptionPayload {
  mutation: MutationType;
  node: ExchangeTransaction;
  updatedFields: String[];
  previousValues: ExchangeTransactionPreviousValues;
}

export interface ExchangeTransactionSubscriptionPayloadPromise
  extends Promise<ExchangeTransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExchangeTransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExchangeTransactionPreviousValuesPromise>() => T;
}

export interface ExchangeTransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExchangeTransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExchangeTransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExchangeTransactionPreviousValuesSubscription>() => T;
}

export interface ExchangeTransactionPreviousValues {
  id: ID_Output;
  orderID?: String;
  currentStatus?: ExchangeTransactionType;
  payload: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  refCode?: String;
}

export interface ExchangeTransactionPreviousValuesPromise
  extends Promise<ExchangeTransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  orderID: () => Promise<String>;
  currentStatus: () => Promise<ExchangeTransactionType>;
  payload: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  refCode: () => Promise<String>;
}

export interface ExchangeTransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<ExchangeTransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  orderID: () => Promise<AsyncIterator<String>>;
  currentStatus: () => Promise<AsyncIterator<ExchangeTransactionType>>;
  payload: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  refCode: () => Promise<AsyncIterator<String>>;
}

export interface ExchangeTransactionStatusHistorySubscriptionPayload {
  mutation: MutationType;
  node: ExchangeTransactionStatusHistory;
  updatedFields: String[];
  previousValues: ExchangeTransactionStatusHistoryPreviousValues;
}

export interface ExchangeTransactionStatusHistorySubscriptionPayloadPromise
  extends Promise<ExchangeTransactionStatusHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExchangeTransactionStatusHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = ExchangeTransactionStatusHistoryPreviousValuesPromise
  >() => T;
}

export interface ExchangeTransactionStatusHistorySubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<ExchangeTransactionStatusHistorySubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExchangeTransactionStatusHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ExchangeTransactionStatusHistoryPreviousValuesSubscription
  >() => T;
}

export interface ExchangeTransactionStatusHistoryPreviousValues {
  id: ID_Output;
  status: ExchangeTransactionType;
  message?: String;
}

export interface ExchangeTransactionStatusHistoryPreviousValuesPromise
  extends Promise<ExchangeTransactionStatusHistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ExchangeTransactionType>;
  message: () => Promise<String>;
}

export interface ExchangeTransactionStatusHistoryPreviousValuesSubscription
  extends Promise<
      AsyncIterator<ExchangeTransactionStatusHistoryPreviousValues>
    >,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ExchangeTransactionType>>;
  message: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  path: String;
  fileName: String;
  createdAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  path: () => Promise<String>;
  fileName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<String>>;
  fileName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HistorySubscriptionPayload {
  mutation: MutationType;
  node: History;
  updatedFields: String[];
  previousValues: HistoryPreviousValues;
}

export interface HistorySubscriptionPayloadPromise
  extends Promise<HistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HistoryPreviousValuesPromise>() => T;
}

export interface HistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HistoryPreviousValuesSubscription>() => T;
}

export interface HistoryPreviousValues {
  id: ID_Output;
  payload?: Json;
  mutationName: String;
  updateBy: String;
}

export interface HistoryPreviousValuesPromise
  extends Promise<HistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  payload: () => Promise<Json>;
  mutationName: () => Promise<String>;
  updateBy: () => Promise<String>;
}

export interface HistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<HistoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payload: () => Promise<AsyncIterator<Json>>;
  mutationName: () => Promise<AsyncIterator<String>>;
  updateBy: () => Promise<AsyncIterator<String>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
  small: String;
  medium: String;
  large: String;
  fileName: String;
  createdAt: DateTimeOutput;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  small: () => Promise<String>;
  medium: () => Promise<String>;
  large: () => Promise<String>;
  fileName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  small: () => Promise<AsyncIterator<String>>;
  medium: () => Promise<AsyncIterator<String>>;
  large: () => Promise<AsyncIterator<String>>;
  fileName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  amount: Int;
  expireAt?: DateTimeOutput;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Int>;
  expireAt: () => Promise<DateTimeOutput>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Int>>;
  expireAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ItemAssetSubscriptionPayload {
  mutation: MutationType;
  node: ItemAsset;
  updatedFields: String[];
  previousValues: ItemAssetPreviousValues;
}

export interface ItemAssetSubscriptionPayloadPromise
  extends Promise<ItemAssetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemAssetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemAssetPreviousValuesPromise>() => T;
}

export interface ItemAssetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemAssetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemAssetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemAssetPreviousValuesSubscription>() => T;
}

export interface ItemAssetPreviousValues {
  id: ID_Output;
  assetType: String;
  assetID: ID_Output;
}

export interface ItemAssetPreviousValuesPromise
  extends Promise<ItemAssetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  assetType: () => Promise<String>;
  assetID: () => Promise<ID_Output>;
}

export interface ItemAssetPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemAssetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  assetType: () => Promise<AsyncIterator<String>>;
  assetID: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MigrationSubscriptionPayload {
  mutation: MutationType;
  node: Migration;
  updatedFields: String[];
  previousValues: MigrationPreviousValues;
}

export interface MigrationSubscriptionPayloadPromise
  extends Promise<MigrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MigrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MigrationPreviousValuesPromise>() => T;
}

export interface MigrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MigrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MigrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MigrationPreviousValuesSubscription>() => T;
}

export interface MigrationPreviousValues {
  id: ID_Output;
  num: Int;
}

export interface MigrationPreviousValuesPromise
  extends Promise<MigrationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  num: () => Promise<Int>;
}

export interface MigrationPreviousValuesSubscription
  extends Promise<AsyncIterator<MigrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  num: () => Promise<AsyncIterator<Int>>;
}

export interface PageViewSubscriptionPayload {
  mutation: MutationType;
  node: PageView;
  updatedFields: String[];
  previousValues: PageViewPreviousValues;
}

export interface PageViewSubscriptionPayloadPromise
  extends Promise<PageViewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PageViewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PageViewPreviousValuesPromise>() => T;
}

export interface PageViewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PageViewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PageViewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PageViewPreviousValuesSubscription>() => T;
}

export interface PageViewPreviousValues {
  id: ID_Output;
  count: Int;
  updatedAt: DateTimeOutput;
}

export interface PageViewPreviousValuesPromise
  extends Promise<PageViewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  count: () => Promise<Int>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageViewPreviousValuesSubscription
  extends Promise<AsyncIterator<PageViewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  count: () => Promise<AsyncIterator<Int>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  type: PostType;
  id: ID_Output;
  message: String;
  status?: ReviewPostStatus;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  type: () => Promise<PostType>;
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  status: () => Promise<ReviewPostStatus>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  type: () => Promise<AsyncIterator<PostType>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<ReviewPostStatus>>;
}

export interface PriceSubscriptionPayload {
  mutation: MutationType;
  node: Price;
  updatedFields: String[];
  previousValues: PricePreviousValues;
}

export interface PriceSubscriptionPayloadPromise
  extends Promise<PriceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PricePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricePreviousValuesPromise>() => T;
}

export interface PriceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PriceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PriceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricePreviousValuesSubscription>() => T;
}

export interface PricePreviousValues {
  id: ID_Output;
  currencyType: CurrencyType;
  amount: Float;
  archiveAt?: DateTimeOutput;
}

export interface PricePreviousValuesPromise
  extends Promise<PricePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  currencyType: () => Promise<CurrencyType>;
  amount: () => Promise<Float>;
  archiveAt: () => Promise<DateTimeOutput>;
}

export interface PricePreviousValuesSubscription
  extends Promise<AsyncIterator<PricePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  currencyType: () => Promise<AsyncIterator<CurrencyType>>;
  amount: () => Promise<AsyncIterator<Float>>;
  archiveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PromotionSubscriptionPayload {
  mutation: MutationType;
  node: Promotion;
  updatedFields: String[];
  previousValues: PromotionPreviousValues;
}

export interface PromotionSubscriptionPayloadPromise
  extends Promise<PromotionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PromotionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PromotionPreviousValuesPromise>() => T;
}

export interface PromotionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PromotionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PromotionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PromotionPreviousValuesSubscription>() => T;
}

export interface PromotionPreviousValues {
  id: ID_Output;
  name: String;
  unit: PromotionUnit;
  type: PromotionType;
  amount: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PromotionPreviousValuesPromise
  extends Promise<PromotionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  unit: () => Promise<PromotionUnit>;
  type: () => Promise<PromotionType>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PromotionPreviousValuesSubscription
  extends Promise<AsyncIterator<PromotionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<PromotionUnit>>;
  type: () => Promise<AsyncIterator<PromotionType>>;
  amount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PublishTimelineSubscriptionPayload {
  mutation: MutationType;
  node: PublishTimeline;
  updatedFields: String[];
  previousValues: PublishTimelinePreviousValues;
}

export interface PublishTimelineSubscriptionPayloadPromise
  extends Promise<PublishTimelineSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PublishTimelinePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PublishTimelinePreviousValuesPromise>() => T;
}

export interface PublishTimelineSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PublishTimelineSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PublishTimelineSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PublishTimelinePreviousValuesSubscription>() => T;
}

export interface PublishTimelinePreviousValues {
  startAt: DateTimeOutput;
  endAt?: DateTimeOutput;
}

export interface PublishTimelinePreviousValuesPromise
  extends Promise<PublishTimelinePreviousValues>,
    Fragmentable {
  startAt: () => Promise<DateTimeOutput>;
  endAt: () => Promise<DateTimeOutput>;
}

export interface PublishTimelinePreviousValuesSubscription
  extends Promise<AsyncIterator<PublishTimelinePreviousValues>>,
    Fragmentable {
  startAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RemoteConfigSubscriptionPayload {
  mutation: MutationType;
  node: RemoteConfig;
  updatedFields: String[];
  previousValues: RemoteConfigPreviousValues;
}

export interface RemoteConfigSubscriptionPayloadPromise
  extends Promise<RemoteConfigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RemoteConfigPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RemoteConfigPreviousValuesPromise>() => T;
}

export interface RemoteConfigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RemoteConfigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RemoteConfigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RemoteConfigPreviousValuesSubscription>() => T;
}

export interface RemoteConfigPreviousValues {
  id: ID_Output;
  name?: String;
  landing: Boolean;
}

export interface RemoteConfigPreviousValuesPromise
  extends Promise<RemoteConfigPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  landing: () => Promise<Boolean>;
}

export interface RemoteConfigPreviousValuesSubscription
  extends Promise<AsyncIterator<RemoteConfigPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  landing: () => Promise<AsyncIterator<Boolean>>;
}

export interface RevenueSharingSubscriptionPayload {
  mutation: MutationType;
  node: RevenueSharing;
  updatedFields: String[];
  previousValues: RevenueSharingPreviousValues;
}

export interface RevenueSharingSubscriptionPayloadPromise
  extends Promise<RevenueSharingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RevenueSharingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RevenueSharingPreviousValuesPromise>() => T;
}

export interface RevenueSharingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RevenueSharingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RevenueSharingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RevenueSharingPreviousValuesSubscription>() => T;
}

export interface RevenueSharingPreviousValues {
  id: ID_Output;
  commission: Float;
  status: RevenueSharingStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RevenueSharingPreviousValuesPromise
  extends Promise<RevenueSharingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  commission: () => Promise<Float>;
  status: () => Promise<RevenueSharingStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RevenueSharingPreviousValuesSubscription
  extends Promise<AsyncIterator<RevenueSharingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  commission: () => Promise<AsyncIterator<Float>>;
  status: () => Promise<AsyncIterator<RevenueSharingStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShelfSubscriptionPayload {
  mutation: MutationType;
  node: Shelf;
  updatedFields: String[];
  previousValues: ShelfPreviousValues;
}

export interface ShelfSubscriptionPayloadPromise
  extends Promise<ShelfSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShelfPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShelfPreviousValuesPromise>() => T;
}

export interface ShelfSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShelfSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShelfSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShelfPreviousValuesSubscription>() => T;
}

export interface ShelfPreviousValues {
  id: ID_Output;
  type: ShelfType;
}

export interface ShelfPreviousValuesPromise
  extends Promise<ShelfPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<ShelfType>;
}

export interface ShelfPreviousValuesSubscription
  extends Promise<AsyncIterator<ShelfPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<ShelfType>>;
}

export interface SystemConfigSubscriptionPayload {
  mutation: MutationType;
  node: SystemConfig;
  updatedFields: String[];
  previousValues: SystemConfigPreviousValues;
}

export interface SystemConfigSubscriptionPayloadPromise
  extends Promise<SystemConfigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SystemConfigPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SystemConfigPreviousValuesPromise>() => T;
}

export interface SystemConfigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SystemConfigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SystemConfigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SystemConfigPreviousValuesSubscription>() => T;
}

export interface SystemConfigPreviousValues {
  id: ID_Output;
  name: String;
  value?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SystemConfigPreviousValuesPromise
  extends Promise<SystemConfigPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SystemConfigPreviousValuesSubscription
  extends Promise<AsyncIterator<SystemConfigPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  type: TransactionType;
  currencyType: CurrencyType;
  amount: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<TransactionType>;
  currencyType: () => Promise<CurrencyType>;
  amount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  currencyType: () => Promise<AsyncIterator<CurrencyType>>;
  amount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TranslatorSubscriptionPayload {
  mutation: MutationType;
  node: Translator;
  updatedFields: String[];
  previousValues: TranslatorPreviousValues;
}

export interface TranslatorSubscriptionPayloadPromise
  extends Promise<TranslatorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TranslatorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TranslatorPreviousValuesPromise>() => T;
}

export interface TranslatorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TranslatorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TranslatorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TranslatorPreviousValuesSubscription>() => T;
}

export interface TranslatorPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TranslatorPreviousValuesPromise
  extends Promise<TranslatorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TranslatorPreviousValuesSubscription
  extends Promise<AsyncIterator<TranslatorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  userID: ID_Output;
  displayName?: String;
  email?: String;
  fullName?: String;
  phoneNumber?: String;
  birthday?: String;
  gender: Gender;
  defaultProfilePicture?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userID: () => Promise<ID_Output>;
  displayName: () => Promise<String>;
  email: () => Promise<String>;
  fullName: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  birthday: () => Promise<String>;
  gender: () => Promise<Gender>;
  defaultProfilePicture: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userID: () => Promise<AsyncIterator<ID_Output>>;
  displayName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  fullName: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  defaultProfilePicture: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserAdminSubscriptionPayload {
  mutation: MutationType;
  node: UserAdmin;
  updatedFields: String[];
  previousValues: UserAdminPreviousValues;
}

export interface UserAdminSubscriptionPayloadPromise
  extends Promise<UserAdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserAdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserAdminPreviousValuesPromise>() => T;
}

export interface UserAdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserAdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserAdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserAdminPreviousValuesSubscription>() => T;
}

export interface UserAdminPreviousValues {
  id: ID_Output;
  email?: String;
  hashedPassword?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserAdminPreviousValuesPromise
  extends Promise<UserAdminPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  hashedPassword: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAdminPreviousValuesSubscription
  extends Promise<AsyncIterator<UserAdminPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  hashedPassword: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserAdminPermissionSubscriptionPayload {
  mutation: MutationType;
  node: UserAdminPermission;
  updatedFields: String[];
  previousValues: UserAdminPermissionPreviousValues;
}

export interface UserAdminPermissionSubscriptionPayloadPromise
  extends Promise<UserAdminPermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserAdminPermissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserAdminPermissionPreviousValuesPromise>() => T;
}

export interface UserAdminPermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserAdminPermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserAdminPermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserAdminPermissionPreviousValuesSubscription>() => T;
}

export interface UserAdminPermissionPreviousValues {
  id: ID_Output;
  type: String;
  resource?: String;
}

export interface UserAdminPermissionPreviousValuesPromise
  extends Promise<UserAdminPermissionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  resource: () => Promise<String>;
}

export interface UserAdminPermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<UserAdminPermissionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  resource: () => Promise<AsyncIterator<String>>;
}

export interface UserAdminRoleSubscriptionPayload {
  mutation: MutationType;
  node: UserAdminRole;
  updatedFields: String[];
  previousValues: UserAdminRolePreviousValues;
}

export interface UserAdminRoleSubscriptionPayloadPromise
  extends Promise<UserAdminRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserAdminRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserAdminRolePreviousValuesPromise>() => T;
}

export interface UserAdminRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserAdminRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserAdminRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserAdminRolePreviousValuesSubscription>() => T;
}

export interface UserAdminRolePreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserAdminRolePreviousValuesPromise
  extends Promise<UserAdminRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAdminRolePreviousValuesSubscription
  extends Promise<AsyncIterator<UserAdminRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VendorSubscriptionPayload {
  mutation: MutationType;
  node: Vendor;
  updatedFields: String[];
  previousValues: VendorPreviousValues;
}

export interface VendorSubscriptionPayloadPromise
  extends Promise<VendorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VendorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VendorPreviousValuesPromise>() => T;
}

export interface VendorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VendorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VendorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VendorPreviousValuesSubscription>() => T;
}

export interface VendorPreviousValues {
  id: ID_Output;
  type: VendorType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  phoneNumber?: String;
  email?: String;
}

export interface VendorPreviousValuesPromise
  extends Promise<VendorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<VendorType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  phoneNumber: () => Promise<String>;
  email: () => Promise<String>;
}

export interface VendorPreviousValuesSubscription
  extends Promise<AsyncIterator<VendorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<VendorType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface VendorBillingInformationSubscriptionPayload {
  mutation: MutationType;
  node: VendorBillingInformation;
  updatedFields: String[];
  previousValues: VendorBillingInformationPreviousValues;
}

export interface VendorBillingInformationSubscriptionPayloadPromise
  extends Promise<VendorBillingInformationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VendorBillingInformationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VendorBillingInformationPreviousValuesPromise>() => T;
}

export interface VendorBillingInformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VendorBillingInformationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VendorBillingInformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = VendorBillingInformationPreviousValuesSubscription
  >() => T;
}

export interface VendorBillingInformationPreviousValues {
  id: ID_Output;
  billingType: VendorBillingType;
  companyName?: String;
  branchId?: String;
  taxID: String;
  firstName: String;
  lastName: String;
  bank?: String;
  bookBankNumber?: String;
  address: String;
  province?: String;
  zipCode?: String;
}

export interface VendorBillingInformationPreviousValuesPromise
  extends Promise<VendorBillingInformationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  billingType: () => Promise<VendorBillingType>;
  companyName: () => Promise<String>;
  branchId: () => Promise<String>;
  taxID: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  bank: () => Promise<String>;
  bookBankNumber: () => Promise<String>;
  address: () => Promise<String>;
  province: () => Promise<String>;
  zipCode: () => Promise<String>;
}

export interface VendorBillingInformationPreviousValuesSubscription
  extends Promise<AsyncIterator<VendorBillingInformationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  billingType: () => Promise<AsyncIterator<VendorBillingType>>;
  companyName: () => Promise<AsyncIterator<String>>;
  branchId: () => Promise<AsyncIterator<String>>;
  taxID: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  bank: () => Promise<AsyncIterator<String>>;
  bookBankNumber: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  province: () => Promise<AsyncIterator<String>>;
  zipCode: () => Promise<AsyncIterator<String>>;
}

export interface VendorRevenueSubscriptionPayload {
  mutation: MutationType;
  node: VendorRevenue;
  updatedFields: String[];
  previousValues: VendorRevenuePreviousValues;
}

export interface VendorRevenueSubscriptionPayloadPromise
  extends Promise<VendorRevenueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VendorRevenuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VendorRevenuePreviousValuesPromise>() => T;
}

export interface VendorRevenueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VendorRevenueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VendorRevenueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VendorRevenuePreviousValuesSubscription>() => T;
}

export interface VendorRevenuePreviousValues {
  id: ID_Output;
  weight: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface VendorRevenuePreviousValuesPromise
  extends Promise<VendorRevenuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weight: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VendorRevenuePreviousValuesSubscription
  extends Promise<AsyncIterator<VendorRevenuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weight: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "PublishTimeline",
    embedded: false
  },
  {
    name: "Book",
    embedded: false
  },
  {
    name: "BookVolume",
    embedded: false
  },
  {
    name: "BookEpisodeContent",
    embedded: false
  },
  {
    name: "Price",
    embedded: false
  },
  {
    name: "BookEpisode",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Translator",
    embedded: false
  },
  {
    name: "Author",
    embedded: false
  },
  {
    name: "CopyrightHolder",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "PageView",
    embedded: false
  },
  {
    name: "History",
    embedded: false
  },
  {
    name: "Behavior",
    embedded: false
  },
  {
    name: "UserAdminPermission",
    embedded: false
  },
  {
    name: "UserAdminRole",
    embedded: false
  },
  {
    name: "UserAdmin",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "ItemAsset",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "BookEpisodeRecentRead",
    embedded: false
  },
  {
    name: "ExchangeTransaction",
    embedded: false
  },
  {
    name: "ExchangeTransactionStatusHistory",
    embedded: false
  },
  {
    name: "ExchangeTier",
    embedded: false
  },
  {
    name: "Promotion",
    embedded: false
  },
  {
    name: "BookEpisodeReviewPost",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Shelf",
    embedded: false
  },
  {
    name: "Migration",
    embedded: false
  },
  {
    name: "AdsBanner",
    embedded: false
  },
  {
    name: "Vendor",
    embedded: false
  },
  {
    name: "Document",
    embedded: false
  },
  {
    name: "VendorBillingInformation",
    embedded: false
  },
  {
    name: "RevenueSharing",
    embedded: false
  },
  {
    name: "VendorRevenue",
    embedded: false
  },
  {
    name: "RemoteConfig",
    embedded: false
  },
  {
    name: "SystemConfig",
    embedded: false
  },
  {
    name: "BookRecommended",
    embedded: false
  },
  {
    name: "DashbardDataCache",
    embedded: false
  },
  {
    name: "CurrencyType",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "TransactionType",
    embedded: false
  },
  {
    name: "ExchangeType",
    embedded: false
  },
  {
    name: "ExchangeTransactionType",
    embedded: false
  },
  {
    name: "PromotionUnit",
    embedded: false
  },
  {
    name: "PromotionType",
    embedded: false
  },
  {
    name: "PostType",
    embedded: false
  },
  {
    name: "ReviewPostStatus",
    embedded: false
  },
  {
    name: "ShelfType",
    embedded: false
  },
  {
    name: "VendorType",
    embedded: false
  },
  {
    name: "DocumentType",
    embedded: false
  },
  {
    name: "VendorBillingType",
    embedded: false
  },
  {
    name: "RevenueSharingStatus",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["ENDPOINT"]}`,
  secret: `${process.env["PRISMA_MANAGEMENT_API_SECRET"]}`
});
export const prisma = new Prisma();
